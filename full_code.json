{
  "clustered": true,
  "link_data": {
    "directed": true,
    "multigraph": true,
    "graph": {},
    "nodes": [
      {
        "kind": "ChunkNode",
        "og_id": "moatless/__init__.py::2",
        "metadata": {
          "file_path": "moatless\\__init__.py",
          "file_name": "__init__.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 36,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 5,
          "community": null
        },
        "content": "from moatless.repository import FileRepository\nfrom moatless.workspace import Workspace\nfrom moatless.transition_rules import TransitionRules\nfrom moatless.loop import AgenticLoop",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/__init__.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 479,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 66,
          "community": null
        },
        "content": "import json\nimport logging\nfrom typing import Optional\n\nimport instructor\n\nfrom moatless.transition_rules import TransitionRules\nfrom moatless.benchmark.evaluation import create_evaluation_name, Evaluation\nfrom moatless.edit.edit import EditCode\nfrom moatless.edit.plan import PlanToCode\nfrom moatless.find.decide import DecideRelevance\nfrom moatless.find.identify import IdentifyCode\nfrom moatless.find.search import SearchCode\nfrom moatless.transition_rules import TransitionRule\nfrom moatless.state import Finished, Rejected\nfrom moatless.transitions import (\n    search_and_code_transitions,\n    search_transitions,\n    code_transitions,\n)\n\n# model = \"claude-3-5-sonnet-20240620\"\n\n# model = \"gpt-4o-2024-05-13\"\nmodel = \"azure/gpt-4o\"\n\n# model = \"openrouter/anthropic/claude-3.5-sonnet\"\n\nglobal_params = {\n    \"model\": model,\n    \"temperature\": 0.2,\n    \"max_tokens\": 2000,\n    \"max_prompt_file_tokens\": 8000,\n}\n\nstate_params = {\n    SearchCode: {\n        \"provide_initial_context\": True,\n        \"max_search_results\": 75,\n        \"initial_context_tokens\": 6000,\n        \"initial_search_results\": 100,\n        \"initial_context_spans_per_file\": 5,\n    },\n    IdentifyCode: {\"expand_context\": True},\n    DecideRelevance: {\n        \"finish_after_relevant_count\": 1,\n    },\n    PlanToCode: {\n        \"max_tokens_in_edit_prompt\": 750,\n        \"expand_context_with_related_spans\": False,\n        \"finish_on_review\": True,\n    },\n    EditCode: {\n        \"chain_of_thought\": False,\n        \"show_file_context\": False,\n        \"max_prompt_file_tokens\": 8000,\n    },\n}\n\nindex_store_dir = f\"/home/albert/20240522-voyage-code-2\"\nrepo_base_dir = \"/tmp/repos\"\nevaluations_dir = \"/home/albert/repos/albert/moatless/evaluations\"\n\nsearch_and_code = search_and_code_transitions(\n    global_params=global_params, state_params=state_params\n)",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::2",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 703,
          "span_ids": [
            "imports",
            "impl:17"
          ],
          "start_line": 68,
          "end_line": 134,
          "community": null
        },
        "content": "identified_spans_but_failed_implementation = [\n    \"django__django-11583\",\n    \"django__django-11179\",\n    \"django__django-12286\",\n    \"django__django-12700\",\n    \"django__django-12708\",\n    \"django__django-13315\",\n    \"django__django-13933\",\n    \"django__django-14382\",\n    \"django__django-14608\",\n    \"django__django-14787\",\n    \"django__django-14999\",\n    \"django__django-15347\",\n    \"django__django-15789\",\n    \"django__django-16041\",\n    \"django__django-16046\",\n    \"django__django-16595\",\n    \"matplotlib__matplotlib-26020\",\n    \"matplotlib__matplotlib-24149\",\n    \"mwaskom__seaborn-3190\",\n    \"psf__requests-3362\",\n    \"pytest-dev__pytest-5692\",\n    \"scikit-learn__scikit-learn-11281\",\n    \"django__django-2708\",\n    \"scikit-learn__scikit-learn-13241\",\n    \"scikit-learn__scikit-learn-13779\",\n    \"scikit-learn__scikit-learn-14894\",\n    \"scikit-learn__scikit-learn-15535\",\n    \"scikit-learn__scikit-learn-25570\",\n    \"sympy__sympy-18621\",\n    \"sympy__sympy-23117\",\n    \"sympy__sympy-22714\",\n    \"sympy__sympy-24213\",\n]\n\ncoding_test_set = [\n    \"django__django-11848\",\n    \"django__django-12308\",\n    \"django__django-12497\",\n    \"django__django-13551\",\n    \"django__django-13660\",\n    \"django__django-14238\",\n    \"django__django-14411\",\n    \"django__django-14787\",\n    \"django__django-16041\",\n    \"django__django-17051\",\n    \"matplotlib__matplotlib-24149\",\n    \"mwaskom__seaborn-3190\",\n    \"psf__requests-1963\",\n    \"pylint-dev__pylint-6506\",\n    \"pylint-dev__pylint-7993\",\n    \"pytest-dev__pytest-7432\",\n    \"scikit-learn__scikit-learn-13142\",\n    \"scikit-learn__scikit-learn-25570\",\n    \"sphinx-doc__sphinx-7975\",\n    \"sympy__sympy-12481\",\n    \"sympy__sympy-14396\",\n    \"sympy__sympy-14817\",\n    \"sympy__sympy-15609\",\n    \"sympy__sympy-16988\",\n    \"sympy__sympy-18189\",\n    \"sympy__sympy-18532\",\n    \"sympy__sympy-21847\",\n    \"sympy__sympy-22005\",\n    \"sympy__sympy-22714\",\n    \"sympy__sympy-24066\",\n]",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::3",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 277,
          "span_ids": [
            "impl:17",
            "run_evaluation"
          ],
          "start_line": 136,
          "end_line": 169,
          "community": null
        },
        "content": "search_and_identify_set = [\n    \"matplotlib__matplotlib-25442\",\n    \"matplotlib__matplotlib-23562\",\n    \"pytest-dev__pytest-11148\",\n    \"sphinx-doc__sphinx-8721\",\n    \"sphinx-doc__sphinx-10325\",\n    \"scikit-learn__scikit-learn-15535\",\n    \"scikit-learn__scikit-learn-11281\",\n    \"astropy__astropy-6938\",\n    \"sympy__sympy-17022\",\n    \"sympy__sympy-17139\",\n    \"sympy__sympy-13031\",\n    \"django__django-15814\",\n    \"django__django-15498\",\n    \"django__django-12125\",\n    \"django__django-13964\",\n    \"django__django-11964\",\n    \"django__django-14580\",\n    \"django__django-17087\",\n]\n\n\ndef run_evaluation():\n    max_file_context_lines = 1000\n\n    transitions = search_and_code_transitions(\n        state_params={\n            PlanToCode: {\n                \"max_prompt_file_tokens\": 16000,\n                \"max_tokens_in_edit_prompt\": 500,\n                \"max_file_context_lines\": max_file_context_lines,\n            }\n        },\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::4",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 188,
          "span_ids": [
            "evaluate_search"
          ],
          "start_line": 172,
          "end_line": 198,
          "community": null
        },
        "content": "def evaluate_search():\n    transitions = TransitionRules(\n        global_params=global_params,\n        state_params={\n            SearchCode: {\"max_search_results\": 50, \"provide_initial_context\": True},\n        },\n        initial_state=SearchCode,\n        transitions=[\n            TransitionRule(source=SearchCode, dest=Finished, trigger=\"did_search\"),\n            TransitionRule(source=SearchCode, dest=Finished, trigger=\"finish\"),\n        ],\n    )\n\n    evaluation_name = create_evaluation_name(model, \"search\")\n\n    evaluation = Evaluation(\n        transitions=transitions,\n        evaluations_dir=evaluations_dir + \"/search\",\n        evaluation_name=evaluation_name,\n        index_store_dir=index_store_dir,\n        repo_base_dir=repo_base_dir,\n        max_file_context_tokens=16000,\n        litellm_callback=\"langfuse\",\n        detailed_report=True,\n    )\n\n    evaluation.run_evaluation_with_moatless_dataset(use_test_subset=True)",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::5",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 217,
          "span_ids": [
            "evaluate_search_and_identify"
          ],
          "start_line": 201,
          "end_line": 228,
          "community": null
        },
        "content": "def evaluate_search_and_identify(\n    resolved_by: Optional[int] = 4,\n    previous_trajectory_dir: Optional[str] = None,\n    instance_ids: Optional[list] = None,\n):\n    transitions = search_transitions(\n        global_params=global_params,\n        state_params=state_params,\n    )\n\n    evaluation_name = create_evaluation_name(\"search_and_identify_3\", model)\n    # evaluation_name = \"20240624_search_and_identify_claude-3-5-sonnet-20240620\"\n\n    evaluation = Evaluation(\n        transitions=transitions,\n        evaluations_dir=evaluations_dir + \"/search_and_identify\",\n        evaluation_name=evaluation_name,\n        index_store_dir=index_store_dir,\n        repo_base_dir=repo_base_dir,\n        previous_trajectory_dir=previous_trajectory_dir,\n        max_file_context_tokens=16000,\n        litellm_callback=\"langfuse\",\n        detailed_report=True,\n    )\n\n    evaluation.run_evaluation_with_moatless_dataset(\n        resolved_by=resolved_by, instance_ids=instance_ids\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::6",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 233,
          "span_ids": [
            "evaluate_search_and_code"
          ],
          "start_line": 231,
          "end_line": 258,
          "community": null
        },
        "content": "def evaluate_search_and_code(\n    resolved_by: Optional[int],\n    previous_trajectory_dir: Optional[str] = None,\n    retry_state: Optional[str] = None,\n    instance_ids: Optional[list] = None,\n):\n    evaluation_name = create_evaluation_name(\"search_and_code\", model)\n    # evaluation_name = \"20240624_search_and_code_2_claude-3-5-sonnet-20240620\"\n    # evaluation_name = \"20240623_moatless_claude-3.5-sonnet\"\n\n    evaluation = Evaluation(\n        transitions=search_and_code,\n        evaluations_dir=evaluations_dir + \"/search_and_code\",\n        evaluation_name=evaluation_name,\n        index_store_dir=index_store_dir,\n        repo_base_dir=repo_base_dir,\n        previous_trajectory_dir=previous_trajectory_dir,\n        retry_state=retry_state,\n        max_file_context_tokens=16000,\n        num_workers=3,\n        litellm_callback=\"langfuse\",\n        detailed_report=True,\n    )\n\n    evaluation.run_evaluation_with_moatless_dataset(\n        resolved_by=resolved_by,\n        instance_ids=instance_ids,\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::7",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 154,
          "span_ids": [
            "evaluate_coding"
          ],
          "start_line": 261,
          "end_line": 279,
          "community": null
        },
        "content": "def evaluate_coding():\n    evaluation_name = create_evaluation_name(\"coding\", model)\n    # evaluation_name = \"20240623_coding_2_claude-3.5-sonnet\"\n\n    evaluation = Evaluation(\n        transitions=code_transitions(\n            global_params=global_params, state_params=state_params\n        ),\n        use_expected_file_context=True,\n        evaluations_dir=evaluations_dir + \"/coding\",\n        evaluation_name=evaluation_name,\n        index_store_dir=index_store_dir,\n        repo_base_dir=repo_base_dir,\n        max_file_context_tokens=16000,\n        litellm_callback=\"langfuse\",\n        detailed_report=True,\n    )\n\n    df = evaluation.run_evaluation_with_moatless_dataset(instance_ids=coding_test_set)",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::8",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 476,
          "span_ids": [
            "evaluate_plan"
          ],
          "start_line": 282,
          "end_line": 338,
          "community": null
        },
        "content": "def evaluate_plan(previous_trajectory_dir: Optional[str] = None):\n    transitions = TransitionRules(\n        global_params=global_params,\n        state_params={\n            SearchCode: {\n                \"provide_initial_context\": True,\n                \"max_search_results\": 75,\n                \"initial_context_tokens\": 6000,\n                \"initial_search_results\": 100,\n                \"initial_context_spans_per_file\": 5,\n            },\n            PlanToCode: {\n                \"max_prompt_file_tokens\": 16000,\n                \"max_tokens_in_edit_prompt\": 750,\n                \"expand_context_with_related_spans\": False,\n            },\n        },\n        initial_state=SearchCode,\n        transitions=[\n            TransitionRule(source=SearchCode, dest=IdentifyCode, trigger=\"did_search\"),\n            TransitionRule(source=IdentifyCode, dest=SearchCode, trigger=\"search\"),\n            TransitionRule(source=IdentifyCode, dest=DecideRelevance, trigger=\"finish\"),\n            TransitionRule(source=DecideRelevance, dest=SearchCode, trigger=\"search\"),\n            TransitionRule(\n                source=DecideRelevance,\n                dest=PlanToCode,\n                trigger=\"finish\",\n                exclude_fields={\"message\"},\n            ),\n            TransitionRule(source=PlanToCode, dest=Finished, trigger=\"edit_code\"),\n            TransitionRule(source=PlanToCode, dest=Rejected, trigger=\"finish\"),\n            TransitionRule(source=PlanToCode, dest=Rejected, trigger=\"reject\"),\n        ],\n    )\n\n    evaluation_name = create_evaluation_name(\"search_and_plan_2\", model)\n\n    evaluation = Evaluation(\n        transitions=transitions,\n        evaluations_dir=evaluations_dir + \"/search_and_plan\",\n        evaluation_name=evaluation_name,\n        index_store_dir=index_store_dir,\n        repo_base_dir=repo_base_dir,\n        previous_trajectory_dir=previous_trajectory_dir,\n        retry_state=\"PlanToCode\",\n        max_file_context_tokens=16000,\n        litellm_callback=\"langfuse\",\n        detailed_report=True,\n    )\n\n    df = evaluation.run_evaluation_with_moatless_dataset(\n        instance_ids=identified_spans_but_failed_implementation\n    )\n\n    # print out instance id and if planned\n    for instance_id in df.index:\n        print(df.loc[instance_id, \"instance_id\"], df.loc[instance_id, \"planned\"])",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/claude_evaluation.py::9",
        "metadata": {
          "file_path": "moatless\\benchmark\\claude_evaluation.py",
          "file_name": "claude_evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 201,
          "span_ids": [
            "impl:21"
          ],
          "start_line": 341,
          "end_line": 361,
          "community": null
        },
        "content": "if __name__ == \"__main__\":\n    logging.basicConfig(\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        level=logging.INFO,\n    )\n    logging.getLogger().setLevel(logging.INFO)\n    logging.getLogger(\"LiteLLM\").setLevel(logging.WARNING)\n    logging.getLogger(\"Evaluator\").setLevel(logging.INFO)\n\n    # evaluate_coding()\n    # evaluate_search_and_identify()\n    evaluate_search_and_code(\n        1,\n        \"/home/albert/repos/albert/moatless/evaluations/20240623_moatless_claude-3.5-sonnet/trajs\",\n        retry_state=\"PlanToCode\",\n    )\n    # evaluate_search_and_code()\n    # evaluate_search_and_code(\n    #    # \"/home/albert/repos/albert/moatless/evaluations/search_and_code/20240622_search_and_code_6_claude-3.5-sonnet/trajs\"\n    # )\r",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/claude_evaluation.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/create_dataset.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\create_dataset.py",
          "file_name": "create_dataset.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 298,
          "span_ids": [
            "imports",
            "read_predictions"
          ],
          "start_line": 1,
          "end_line": 36,
          "community": null
        },
        "content": "import json\n\nimport pandas as pd\n\nfrom moatless.benchmark.swebench import setup_swebench_repo, sorted_instances\nfrom moatless.benchmark.utils import get_file_spans_from_patch\nfrom moatless.repository import FileRepository\n\nexperiments_runs = [\n    \"20240402_sweagent_claude3opus\",\n    \"20240402_sweagent_gpt4\",\n    \"20240509_amazon-q-developer-agent-20240430-dev\",\n    \"20240523_aider\",\n    \"20240524_opencsg_starship_gpt4\",\n    \"20240530_autocoderover-v20240408\",\n    \"20240604_CodeR\",\n    \"20240612_IBM_Research_Agent101\",\n    \"20240612_marscode-agent-dev\",\n    \"20240612_MASAI_gpt4o\",\n    \"20240615_appmap-navie_gpt4o\",\n    \"20240617_factory_code_droid\",\n    \"20240617_moatless_gpt4o\",\n]\n\ndataset_path = (\n    \"/home/albert/repos/albert/moatless/datasets/swebench_lite_all_evaluations.json\"\n)\n\n\ndef read_predictions(pred_path: str):\n    predictions = {}\n    with open(pred_path) as f:\n        for line in f.readlines():\n            prediction = json.loads(line)\n            predictions[prediction[\"instance_id\"]] = prediction[\"model_patch\"]\n    return predictions",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/create_dataset.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/create_dataset.py::2",
        "metadata": {
          "file_path": "moatless\\benchmark\\create_dataset.py",
          "file_name": "create_dataset.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 791,
          "span_ids": [
            "impl:5",
            "generate_report"
          ],
          "start_line": 39,
          "end_line": 156,
          "community": null
        },
        "content": "def generate_report():\n    results = {}\n\n    experiments_dir = \"/home/albert/repos/stuffs/experiments/evaluation/lite\"\n\n    runs = []\n    for run_name in experiments_runs:\n        runs.append(\n            (\n                run_name,\n                f\"{experiments_dir}/{run_name}/all_preds.jsonl\",\n                f\"{experiments_dir}/{run_name}/results/results.json\",\n            )\n        )\n\n    runs.append(\n        (\n            \"autocoderover_v20240620\",\n            \"/home/albert/repos/stuffs/acr-experiments/evaluation/lite/20240621_autocoderover-v20240620/all_preds.jsonl\",\n            \"/home/albert/repos/stuffs/acr-experiments/evaluation/lite/20240621_autocoderover-v20240620/results.json\",\n        )\n    )\n\n    runs.append(\n        (\n            \"20240622_Lingma_Agent\",\n            \"/home/albert/repos/stuffs/alibaba-experiments/evaluation/lite/20240622_Lingma_Agent/all_preds.jsonl\",\n            \"/home/albert/repos/stuffs/alibaba-experiments/evaluation/lite/20240622_Lingma_Agent/results.json\",\n        )\n    )\n\n    for run_name, prediction_file, result_file in runs:\n        with open(result_file) as file:\n            final_report = json.load(file)\n\n        resolved_tasks = final_report[\"resolved\"]\n        predictions_by_id = read_predictions(prediction_file)\n\n        results[run_name] = {\n            \"resolved_tasks\": resolved_tasks,\n            \"predictions\": predictions_by_id,\n        }\n\n    evaluation_dataset = []\n\n    report = []\n\n    instances = sorted_instances(\n        split=\"test\", dataset_name=\"princeton-nlp/SWE-bench_Lite\"\n    )\n    for instance in instances:\n        instance_id = instance[\"instance_id\"]\n        expected_patch = instance[\"patch\"]\n        repo_dir = setup_swebench_repo(instance, repo_base_dir=\"/tmp/repos_2\")\n        file_repo = FileRepository(repo_dir)\n\n        expected_file_spans = get_file_spans_from_patch(file_repo, expected_patch)\n\n        evaluation_instance = {\n            \"instance_id\": instance_id,\n            \"repo\": instance[\"repo\"],\n            \"base_commit\": instance[\"base_commit\"],\n            \"problem_statement\": instance[\"problem_statement\"],\n            \"golden_patch\": instance[\"patch\"],\n            \"expected_spans\": expected_file_spans,\n            \"resolved_by\": [],\n            \"alternative_spans\": [],\n        }\n\n        for run_name, _, _ in runs:\n            prediction = results[run_name][\"predictions\"].get(instance_id)\n\n            if instance_id not in results[run_name][\"resolved_tasks\"]:\n                continue\n\n            file_spans = get_file_spans_from_patch(file_repo, prediction)\n\n            is_different = False\n            alternative_spans = {}\n            for file_path, span_ids in file_spans.items():\n                if file_path in expected_file_spans:\n                    alternative_spans[file_path] = span_ids\n\n                    if set(expected_file_spans[file_path]).difference(set(span_ids)):\n                        is_different = True\n\n            if is_different:\n                evaluation_instance[\"alternative_spans\"].append(\n                    {\"run_name\": run_name, \"spans\": alternative_spans}\n                )\n\n            resolved = {\n                \"name\": run_name,\n                \"patch\": prediction,\n                \"updated_spans\": file_spans,\n                \"alternative_spans\": alternative_spans,\n            }\n\n            evaluation_instance[\"resolved_by\"].append(resolved)\n\n        report.append(\n            {\n                \"instance_id\": instance_id,\n                \"resolved_by\": len(evaluation_instance[\"resolved_by\"]),\n            }\n        )\n\n        evaluation_dataset.append(evaluation_instance)\n\n        with open(dataset_path, \"w\") as f:\n            json.dump(evaluation_dataset, f, indent=2)\n\n    return pd.DataFrame(report)\n\n\nif __name__ == \"__main__\":\n    df = generate_report()",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/create_dataset.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 553,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 70,
          "community": null
        },
        "content": "import concurrent.futures\nimport json\nimport logging\nimport os\nimport subprocess\nimport time\nimport traceback\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom typing import Optional, Tuple\n\nimport instructor\nimport litellm\nimport pandas as pd\nfrom tqdm.auto import tqdm\n\nfrom moatless.benchmark.report_v2 import to_result, generate_md_report\nfrom moatless.trajectory import Trajectory\nfrom moatless.transition_rules import TransitionRules\nfrom moatless.benchmark.swebench import (\n    found_in_alternative_spans,\n    found_in_expected_spans,\n    get_repo_dir_name,\n    load_instance,\n    setup_swebench_repo,\n    sorted_instances,\n)\nfrom moatless.benchmark.utils import (\n    get_missing_files,\n    trace_metadata,\n)\nfrom moatless.file_context import FileContext\nfrom moatless.loop import AgenticLoop\nfrom moatless.repository import FileRepository, GitRepository\nfrom moatless.workspace import Workspace\n\nlogger = logging.getLogger(__name__)\n\nTEST_SUBSET = [\n    \"astropy__astropy-14995\",\n    \"django__django-10914\",\n    \"django__django-11039\",\n    \"django__django-11179\",\n    \"django__django-12286\",\n    \"django__django-12453\",\n    \"django__django-12983\",\n    \"django__django-13230\",\n    \"django__django-13710\",\n    \"django__django-13757\",\n    \"django__django-14915\",\n    \"django__django-14999\",\n    \"django__django-15789\",\n    \"matplotlib__matplotlib-23913\",\n    \"matplotlib__matplotlib-23964\",\n    \"pydata__xarray-5131\",\n    \"pytest-dev__pytest-11143\",\n    \"pytest-dev__pytest-5692\",\n    \"pytest-dev__pytest-7373\",\n    \"scikit-learn__scikit-learn-13142\",\n    \"scikit-learn__scikit-learn-13241\",\n    \"scikit-learn__scikit-learn-13439\",\n    \"scikit-learn__scikit-learn-13496\",\n    \"scikit-learn__scikit-learn-13779\",\n    \"scikit-learn__scikit-learn-14894\",\n    \"scikit-learn__scikit-learn-25570\",\n    \"sympy__sympy-13480\",\n    \"sympy__sympy-13647\",\n    \"sympy__sympy-20212\",\n    \"sympy__sympy-24213\",\n]",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::2",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 572,
          "span_ids": [
            "Evaluation.__init__",
            "Evaluation"
          ],
          "start_line": 73,
          "end_line": 138,
          "community": null
        },
        "content": "class Evaluation:\n    def __init__(\n        self,\n        index_store_dir: str,\n        repo_base_dir: str,\n        evaluations_dir: str,\n        evaluation_name: str,\n        transitions: TransitionRules,\n        instructor_mode: instructor.Mode | None = None,\n        max_cost: float = 0.5,\n        max_transitions: int = 25,\n        max_expansions: int = 2,\n        max_file_context_tokens: int = 16000,\n        markdown_report: bool = False,\n        litellm_callback: Optional[str] = None,\n        previous_trajectory_dir: Optional[str] = None,\n        retry_state: Optional[str] = None,\n        num_workers: int = 1,\n        detailed_report: bool = False,\n    ):\n        self.index_store_dir = index_store_dir\n        self.repo_base_dir = repo_base_dir\n        self.evaluations_dir = evaluations_dir\n        self.num_workers = num_workers\n        self.detailed_report = detailed_report\n        self.markdown_report = markdown_report\n\n        self.evaluation_name = evaluation_name\n        self.max_file_context_tokens = max_file_context_tokens\n        self.max_cost = max_cost\n        self.max_expansions = max_expansions\n        self.max_transitions = max_transitions\n        self.instructor_mode = instructor_mode\n\n        self.transitions = transitions\n\n        litellm.drop_params = True\n\n        self.evaluation_dir = f\"{evaluations_dir}/{evaluation_name}\"\n        self.trajectory_dir = f\"{self.evaluations_dir}/{evaluation_name}/trajs\"\n        self.logs_dir = f\"{self.evaluations_dir}/{evaluation_name}/prompt_logs\"\n        self.predictions_path = f\"{self.evaluation_dir}/all_preds.jsonl\"\n\n        self.previous_trajectory_dir = previous_trajectory_dir\n        self.retry_state = retry_state\n\n        logger.info(f\"Save trajectories to directory: {self.trajectory_dir}\")\n        if not os.path.exists(self.trajectory_dir):\n            os.makedirs(self.trajectory_dir)\n\n        logger.info(f\"Save logs to directory: {self.logs_dir}\")\n        if not os.path.exists(self.logs_dir):\n            os.makedirs(self.logs_dir)\n\n        if litellm_callback:\n            litellm.success_callback = [litellm_callback]\n            litellm.failure_callback = [litellm_callback]\n\n        # This is only to set instances as resolved after all evaluations have been run to generate the report\n        # TODO: Run swe-bench-docker after the prediction is generated\n        result_file = f\"{self.evaluation_dir}/result.json\"\n        if os.path.exists(result_file):\n            with open(os.path.join(result_file)) as f:\n                self.report = json.load(f)\n        else:\n            self.report = {\"resolved_ids\": []}",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::3",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 217,
          "span_ids": [
            "Evaluation.run_evaluation_with_moatless_dataset"
          ],
          "start_line": 140,
          "end_line": 175,
          "community": null
        },
        "content": "class Evaluation:\n\n    def run_evaluation_with_moatless_dataset(\n        self,\n        resolved_by: Optional[int] = None,\n        use_test_subset: bool = False,\n        instance_ids: list[str] | None = None,\n    ):\n        file_path = os.path.join(\n            os.path.dirname(__file__), \"swebench_lite_all_evaluations.json\"\n        )\n        with open(file_path) as f:\n            instances = json.load(f)\n\n        instances = sorted(instances, key=lambda x: len(x[\"resolved_by\"]), reverse=True)\n\n        if use_test_subset:\n            instances = [\n                instance\n                for instance in instances\n                if instance[\"instance_id\"] in TEST_SUBSET\n            ]\n\n        if instance_ids:\n            instances = [\n                instance\n                for instance in instances\n                if instance[\"instance_id\"] in instance_ids\n            ]\n\n        if resolved_by:\n            instances = [\n                instance\n                for instance in instances\n                if len(instance[\"resolved_by\"]) >= resolved_by\n            ]\n\n        return self._run_evaluation(instances)",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::4",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 174,
          "span_ids": [
            "Evaluation.run_swebench_evaluation",
            "Evaluation.run_single_instance"
          ],
          "start_line": 177,
          "end_line": 202,
          "community": null
        },
        "content": "class Evaluation:\n\n    def run_swebench_evaluation(\n        self,\n        dataset: str = \"princeton-nlp/SWE-bench_Lite\",\n        split=\"test\",\n        instance_ids: list[str] | None = None,\n    ):\n        instances = sorted_instances(dataset, split)\n\n        if instance_ids:\n            instances = [\n                instance\n                for instance in instances\n                if instance[\"instance_id\"] in instance_ids\n            ]\n\n        return self._run_evaluation_simple(instances)\n\n    def run_single_instance(\n        self,\n        instance_id: str,\n        dataset: str = \"princeton-nlp/SWE-bench_Lite\",\n        split=\"test\",\n    ) -> dict:\n        instance = load_instance(instance_id, dataset, split)\n        trajectory = self._evaluate_instance(instance)\n        return to_result(instance, trajectory, self.report)",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::5",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 582,
          "span_ids": [
            "Evaluation._evaluate_instance"
          ],
          "start_line": 204,
          "end_line": 289,
          "community": null
        },
        "content": "class Evaluation:\n\n    def _evaluate_instance(self, instance: dict, retry: bool = False) -> Trajectory:\n        instance_id = instance[\"instance_id\"]\n        trajectory_path = os.path.join(self.trajectory_dir, f\"{instance_id}.json\")\n        prompt_log_dir = os.path.join(self.logs_dir, f\"{instance_id}\")\n        if not os.path.exists(prompt_log_dir):\n            os.makedirs(prompt_log_dir)\n\n        if os.path.exists(trajectory_path) and not retry:\n            # TODO: Retry when failed or not finished?\n            return Trajectory.load(trajectory_path)\n\n        repo_dir = setup_swebench_repo(instance)\n        persist_dir = os.path.join(self.index_store_dir, get_repo_dir_name(instance_id))\n        workspace = Workspace.from_dirs(\n            repo_path=repo_dir, index_dir=persist_dir, max_file_context_tokens=16000\n        )\n\n        problem_statement = instance[\"problem_statement\"]\n\n        previous_actions = []\n        if self.previous_trajectory_dir:\n            previous_trajectory_path = os.path.join(\n                self.previous_trajectory_dir, f\"{instance_id}.json\"\n            )\n            previous_trajectory = self.read_trajectory(previous_trajectory_path)\n            if previous_trajectory:\n                previous_actions = self.get_actions(previous_trajectory)\n\n        metadata = trace_metadata(\n            instance_id=instance_id,\n            session_id=self.evaluation_name,\n            trace_name=\"moatless\",\n        )\n\n        loop = AgenticLoop(\n            transition_rules=self.transitions,\n            workspace=workspace,\n            metadata=metadata,\n            mocked_actions=previous_actions,\n            reset_mocks_at_state=self.retry_state,\n            trajectory_path=trajectory_path,\n            prompt_log_dir=prompt_log_dir,\n            max_cost=self.max_cost,\n            max_transitions=self.max_transitions,\n            max_actions=self.max_expansions,\n            instructor_mode=self.instructor_mode,\n        )\n\n        info = {\n            \"evaluation_name\": self.evaluation_name,\n            \"instance_id\": instance[\"instance_id\"],\n        }\n\n        start_time = time.time()\n        try:\n            response = loop.run(problem_statement)\n            info[\"status\"] = response.status\n        except Exception:\n            info[\"error\"] = traceback.format_exc()\n            info[\"status\"] = \"error\"\n            logging.exception(f\"Error in evaluation of {instance['instance_id']} \")\n\n        info[\"duration\"] = time.time() - start_time\n        info[\"total_cost\"] = loop.total_cost()\n\n        if isinstance(workspace.file_repo, GitRepository):\n            diff = workspace.file_repo.diff()\n        else:\n            workspace.save()\n\n            output = subprocess.run(\n                [\"git\", \"diff\"],\n                capture_output=True,\n                text=True,\n                cwd=repo_dir,\n            )\n\n            if output:\n                diff = output.stdout\n            else:\n                diff = None\n\n        info[\"submission\"] = diff\n\n        loop.trajectory.save_info(info)\n        return loop.trajectory",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::6",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 166,
          "span_ids": [
            "Evaluation._process_instance"
          ],
          "start_line": 291,
          "end_line": 312,
          "community": null
        },
        "content": "class Evaluation:\n\n    def _process_instance(self, instance) -> Tuple[dict, str]:\n        trajectory = self._evaluate_instance(instance)\n\n        result = to_result(instance, trajectory, self.report)\n        submission = trajectory.info.get(\"submission\", \"\")\n\n        if self.markdown_report:\n            try:\n                md_report = generate_md_report(trajectory, instance)\n                if not os.path.exists(f\"{self.evaluation_dir}/reports\"):\n                    os.makedirs(f\"{self.evaluation_dir}/reports\")\n                with open(\n                    f\"{self.evaluation_dir}/reports/{instance['instance_id']}.md\",\n                    \"w\",\n                ) as file:\n                    file.write(md_report)\n            except Exception:\n                logging.exception(\n                    f\"Error in generating report for {instance['instance_id']} \"\n                )\n\n        return result, submission",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::7",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 336,
          "span_ids": [
            "Evaluation._run_evaluation",
            "Evaluation._process_repo_group"
          ],
          "start_line": 314,
          "end_line": 359,
          "community": null
        },
        "content": "class Evaluation:\n\n    def _process_repo_group(self, repo, instances):\n        results = []\n        transition_results = []\n        for i, instance in enumerate(instances):\n            logger.info(\n                f\"Processing {instance['instance_id']} ({i+1}/{len(instances)} in {repo})\"\n            )\n\n            trajectory = self._evaluate_instance(instance)\n            if not trajectory:\n                return None, None\n\n            result = to_result(instance, trajectory, report=self.report)\n            results.append(result)\n\n            try:\n                md_report = generate_md_report(trajectory, instance)\n                if not os.path.exists(f\"{self.evaluation_dir}/reports\"):\n                    os.makedirs(f\"{self.evaluation_dir}/reports\")\n                with open(\n                    f\"{self.evaluation_dir}/reports/{instance['instance_id']}.md\",\n                    \"w\",\n                ) as file:\n                    file.write(md_report)\n            except Exception:\n                logging.exception(\n                    f\"Error in generating report for {instance['instance_id']} \"\n                )\n\n            prediction = {\n                \"model_name_or_path\": self.evaluation_name,\n                \"instance_id\": result[\"instance_id\"],\n                \"model_patch\": trajectory[\"info\"].get(\"submission\", \"\"),\n            }\n\n            with open(self.predictions_path, \"a\") as file:\n                json_string = json.dumps(prediction)\n                file.write(json_string + \"\\n\")\n\n        return results, transition_results\n\n    def _run_evaluation(self, instances: list[dict]):\n        if self.detailed_report or self.num_workers > 1:\n            self._run_evaluation_detailed(instances)\n        else:\n            self._run_evaluation_simple(instances)",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::8",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 459,
          "span_ids": [
            "Evaluation._run_evaluation_detailed"
          ],
          "start_line": 361,
          "end_line": 428,
          "community": null
        },
        "content": "class Evaluation:\n\n    def _run_evaluation_detailed(self, instances: list[dict]):\n        error = 0\n\n        with open(self.predictions_path, \"w\") as file:\n            file.write(\"\")\n\n        repo_groups = defaultdict(list)\n        for instance in instances:\n            repo_groups[instance.get(\"repo\")].append(instance)\n\n        results = []\n        transition_results = []\n\n        logger.info(f\"Processing {len(instances)} instances with {len(repo_groups)} repos with {self.num_workers} workers\")\n\n        with concurrent.futures.ProcessPoolExecutor(\n            max_workers=self.num_workers\n        ) as executor:\n            futures = []\n            for repo, group in repo_groups.items():\n                futures.append(executor.submit(self._process_repo_group, repo, group))\n\n            pbar = tqdm(concurrent.futures.as_completed(futures), total=len(futures))\n\n            for future in pbar:\n                try:\n                    group_results, group_transition_results = future.result()\n                    if not group_results:\n                        logger.warning(\"Error in processing repo group\")\n                        error += 1\n                        continue\n                except Exception:\n                    error += 1\n                    logger.exception(\"Error in processing repo group\")\n                    continue\n\n                results.extend(group_results)\n                transition_results.extend(group_transition_results)\n\n                df = pd.DataFrame(results)\n                df.to_csv(\n                    f\"{self.evaluation_dir}/result.csv\",\n                    index=False,\n                    sep=\",\",\n                    decimal=\",\",\n                    quoting=1,\n                )\n\n                avg_duration = df[\"duration\"].mean()\n                avg_cost = df[\"total_cost\"].mean()\n                total_identified = df[\"identified\"].sum()\n                total_processed = len(df)\n\n                logger.info(f\"Average duration: {avg_duration:.2f} seconds\")\n                logger.info(f\"Average cost: ${avg_cost:.4f}\")\n                logger.info(f\"Total identified: {total_identified}\")\n                logger.info(f\"Total processed: {total_processed}\")\n                logger.info(f\"Error count: {error}\")\n\n                if transition_results:\n                    df_search = pd.DataFrame(transition_results)\n                    df_search.to_csv(\n                        f\"{self.evaluation_dir}/transition_results.csv\",\n                        index=False,\n                        sep=\",\",\n                        decimal=\",\",\n                        quoting=1,\n                    )",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/evaluation.py::9",
        "metadata": {
          "file_path": "moatless\\benchmark\\evaluation.py",
          "file_name": "evaluation.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 555,
          "span_ids": [
            "Evaluation.read_trajectory",
            "create_evaluation_name",
            "Evaluation._run_evaluation_simple",
            "Evaluation.get_actions"
          ],
          "start_line": 430,
          "end_line": 518,
          "community": null
        },
        "content": "class Evaluation:\n\n    def _run_evaluation_simple(self, instances: list[dict]):\n        with open(self.predictions_path, \"w\") as file:\n            file.write(\"\")\n\n        count = 0\n        identified = 0\n        generated = 0\n        error = 0\n\n        sum_duration = 0\n        sum_total_cost = 0\n\n        stats = {}\n        pbar = tqdm(instances)\n        for instance in pbar:\n            trajectory = self._evaluate_instance(instance)\n            if not trajectory:\n                continue\n\n            result, transition_result = to_result(instance, trajectory, report=self.report)\n\n            sum_duration += result[\"duration\"]\n            sum_total_cost += result[\"total_cost\"]\n\n            if result[\"status\"] == \"error\":\n                error += 1\n\n            if result[\"status\"] in [\"generated\", \"failed\", \"resolved\"]:\n                generated += 1\n\n            if result[\"identified\"] is not None:\n                identified += 1\n\n            count += 1\n\n            if sum_duration > 0:\n                stats[\"avg_duration\"] = sum_duration / count\n\n            if sum_total_cost > 0:\n                stats[\"avg_cost\"] = sum_total_cost / count\n                stats[\"total_cost\"] = sum_total_cost\n\n            if identified > 0:\n                success_rate = (identified / count) * 100\n                stats[\"identified\"] = f\"{success_rate:.2f}%\"\n\n            if generated > 0:\n                success_rate = (generated / count) * 100\n                stats[\"generated\"] = f\"{success_rate:.2f}%\"\n\n            stats[\"error\"] = error\n\n            pbar.set_postfix(stats)\n\n            prediction = {\n                \"model_name_or_path\": self.evaluation_name,\n                \"instance_id\": instance[\"instance_id\"],\n                \"model_patch\": trajectory[\"info\"].get(\"submission\", \"\"),\n            }\n\n            with open(self.predictions_path, \"a\") as file:\n                json_string = json.dumps(prediction)\n                file.write(json_string + \"\\n\")\n\n\n    def read_trajectory(self, path) -> Optional[dict]:\n        if os.path.exists(path):\n            with open(path) as f:\n                return json.load(f)\n        else:\n            return None\n\n    def get_actions(self, trajectory: dict):\n        actions = []\n        for transition in trajectory[\"transitions\"]:\n            for action in transition[\"actions\"]:\n                actions.append(action)\n        return actions\n\n\ndef create_evaluation_name(\n    name: str,\n    model: str,\n):\n    date_str = datetime.now(tz=timezone.utc).strftime(\"%Y%m%d\")\n    model_name = model.split(\"/\")[-1]\n    return f\"{date_str}_{name}_{model_name}\"",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/evaluation.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v1.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v1.py",
          "file_name": "report_v1.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 428,
          "span_ids": [
            "imports",
            "to_result"
          ],
          "start_line": 1,
          "end_line": 295,
          "community": null
        },
        "content": "import json\nimport logging\nimport os\n\nfrom moatless import FileRepository\nfrom moatless.benchmark.swebench import found_in_expected_spans, found_in_alternative_spans, setup_swebench_repo\nfrom moatless.benchmark.utils import get_missing_files\nfrom moatless.file_context import FileContext\n\nlogger = logging.getLogger(__name__)\n\n\ndef to_result(instance: dict, trajectory: dict, report: dict | None) -> tuple[dict, list]:\n    \"\"\"\n    Generate reports from saved trajectories with version 1 format.\n    \"\"\"\n\n    info = trajectory[\"info\"]\n\n    resolved = report and info.get(\"instance_id\", \"\") in report[\"resolved\"]\n\n    try:\n        transitions = []\n        result = {\n            \"instance_id\": instance[\"instance_id\"],\n            \"duration\": info.get(\"duration\", 0),\n            \"total_cost\": info.get(\"total_cost\", 0),\n            \"resolved_by\": (len(instance.get(\"resolved_by\", []))),\n            \"status\": None,\n            \"transitions\": len(trajectory[\"transitions\"]),\n            \"edited\": False,\n            \"planned\": False,\n            \"identified\": None,\n            \"expected_identified\": None,\n            \"alt_identified\": None,\n            \"found_in_search\": None,\n            \"file_identified\": None,\n            \"file_in_search\": None,\n            \"edit_retries\": 0,\n            \"has_diff\": False,\n            \"lint_codes\": None,\n            \"review\": False,\n            \"p_query\": 0,\n            \"p_file\": 0,\n            \"p_code\": 0,\n            \"p_class\": 0,\n            \"p_function\": 0,\n            \"lints\": \"\",\n        }\n\n        lint_codes = set()\n        search_results_spans = {}\n        identified_spans = {}\n        planned_spans = {}\n        edited_spans = {}\n\n        id_iterations = 0\n        search_iterations = 0\n\n        if instance.get(\"expected_spans\"):\n            # ... other code\n    # ... other code\n    # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v1.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v1.py::2",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v1.py",
          "file_name": "report_v1.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 1685,
          "span_ids": [
            "to_result"
          ],
          "start_line": 61,
          "end_line": 295,
          "community": null
        },
        "content": "def to_result(instance: dict, trajectory: dict, report: dict | None) -> tuple[dict, list]:\n\n    try:\n\n        if instance.get(\"expected_spans\"):\n            for transition in trajectory[\"transitions\"]:\n                if transition[\"name\"] not in result:\n                    result[transition[\"name\"]] = 0\n                    result[f\"{transition['name']}_cost\"] = 0\n\n                result[transition[\"name\"]] += 1\n\n                expected_span_str = \"\"\n                for file_path, span_ids in instance[\"expected_spans\"].items():\n                    expected_span_str += f\"{file_path}: {span_ids} \"\n\n                transition_result = {\n                    \"instance_id\": instance[\"instance_id\"],\n                    \"resolved\": resolved,\n                    \"name\": transition[\"name\"],\n                    \"cost\": 0,\n                    \"expected_spans\": expected_span_str,\n                    \"actual_spans\": \"\",\n                }\n\n                if not transition[\"actions\"]:\n                    continue\n\n                for traj_action in transition[\"actions\"]:\n                    result[f\"{transition['name']}_cost\"] += traj_action.get(\n                        \"completion_cost\", 0\n                    )\n                    transition_result[\"cost\"] += traj_action.get(\n                        \"completion_cost\", 0\n                    )\n\n                if transition[\"name\"] == \"SearchCode\":\n                    search_iterations += 1\n\n                    action = transition[\"actions\"][-1]\n\n                    if \"search_requests\" in action[\"action\"]:\n                        for search_request in action[\"action\"][\"search_requests\"]:\n                            if search_request.get(\"query\"):\n                                result[\"p_query\"] += 1\n\n                            if search_request.get(\"file_pattern\"):\n                                result[\"p_file\"] += 1\n\n                            if search_request.get(\"code_snippet\"):\n                                result[\"p_code\"] += 1\n\n                            if search_request.get(\n                                    \"class_name\"\n                            ) or search_request.get(\"class_names\"):\n                                result[\"p_class\"] += 1\n\n                            if search_request.get(\n                                    \"function_name\"\n                            ) or search_request.get(\"function_names\"):\n                                result[\"p_function\"] += 1\n\n                    if \"output\" in action and action.get(\"output\"):\n                        output = action[\"output\"]\n\n                        if \"query\" in output:\n                            result[\"p_query\"] += 1\n\n                        if \"file_pattern\" in output:\n                            result[\"p_file\"] += 1\n\n                        if \"code_snippet\" in output:\n                            result[\"p_code\"] += 1\n\n                        if \"class_name\" in output or \"class_names\" in output:\n                            result[\"p_class\"] += 1\n\n                        if \"function_name\" in output or \"function_names\" in output:\n                            result[\"p_function\"] += 1\n\n                        if output.get(\"ranked_spans\"):\n                            for ranked_span in output[\"ranked_spans\"]:\n                                if (\n                                        ranked_span[\"file_path\"]\n                                        not in search_results_spans\n                                ):\n                                    search_results_spans[\n                                        ranked_span[\"file_path\"]\n                                    ] = []\n                                search_results_spans[\n                                    ranked_span[\"file_path\"]\n                                ].append(ranked_span[\"span_id\"])\n\n                            if not result[\"found_in_search\"] and (\n                                    found_in_expected_spans(\n                                        instance, search_results_spans\n                                    )\n                                    or found_in_alternative_spans(\n                                instance, search_results_spans\n                            )\n                            ):\n                                result[\"found_in_search\"] = search_iterations\n\n                            if not result[\"file_in_search\"]:\n                                missing_files = get_missing_files(\n                                    instance[\"expected_spans\"],\n                                    search_results_spans,\n                                )\n                                if not missing_files:\n                                    result[\"file_in_search\"] = search_iterations\n\n                if transition[\"name\"] == \"IdentifyCode\":\n                    id_iterations += 1\n\n                    action = transition[\"actions\"][-1]\n                    if action.get(\"action\"):\n                        identified_str = \"\"\n                        if action[\"action\"].get(\"identified_spans\"):\n                            for span in action[\"action\"][\"identified_spans\"]:\n                                identified_str += (\n                                    f\"{span['file_path']}: {span['span_ids']} \"\n                                )\n                                if span[\"file_path\"] not in identified_spans:\n                                    identified_spans[span[\"file_path\"]] = []\n\n                                transition_result[\"actual_spans\"] += (\n                                    f\"{span['file_path']}: {','.join(span['span_ids'])} \"\n                                )\n                                for span_id in span[\"span_ids\"]:\n                                    identified_spans[span[\"file_path\"]].append(\n                                        span_id\n                                    )\n                        result[\"identified_spans\"] = identified_str\n\n                    if not result[\"file_identified\"]:\n                        missing_files = get_missing_files(\n                            instance[\"expected_spans\"],\n                            identified_spans,\n                        )\n                        if not missing_files:\n                            result[\"file_identified\"] = id_iterations\n\n                    if result[\n                        \"expected_identified\"\n                    ] is None and found_in_expected_spans(\n                        instance, identified_spans\n                    ):\n                        result[\"expected_identified\"] = id_iterations\n\n                    if result[\n                        \"alt_identified\"\n                    ] is None and found_in_alternative_spans(\n                        instance, identified_spans\n                    ):\n                        result[\"alt_identified\"] = id_iterations\n\n                    if result.get(\"alt_identified\") or result.get(\n                            \"expected_identified\"\n                    ):\n                        result[\"identified\"] = min(\n                            result.get(\"alt_identified\") or 1000,\n                            result.get(\"expected_identified\") or 1000,\n                        )\n\n                if transition[\"name\"] == \"PlanToCode\":\n                    action = transition[\"actions\"][-1][\"action\"]\n                    if action.get(\"action\") == \"review\":\n                        result[\"review\"] = True\n\n                    if \"file_path\" in action:\n                        if \"span_id\" not in action:\n                            logger.warning(\n                                f\"Span id missing in planning action in {instance['instance_id']}\"\n                            )\n                        else:\n                            file_path = action[\"file_path\"]\n                            if file_path not in planned_spans:\n                                planned_spans[file_path] = []\n                            planned_spans[file_path].append(action[\"span_id\"])\n                            transition_result[\"actual_spans\"] = (\n                                f\"{file_path}: {action['span_id']} \"\n                            )\n\n                    if not result.get(\"planned\") and (\n                            found_in_expected_spans(\n                                instance,\n                                planned_spans,\n                            )\n                            or found_in_alternative_spans(instance, planned_spans)\n                    ):\n                        result[\"planned\"] = True\n\n                if transition[\"name\"] == \"EditCode\":\n                    result[\"edit_retries\"] = len(transition[\"actions\"]) - 1\n\n                    action = transition[\"actions\"][-1]\n                    output = action.get(\"output\", {})\n\n                    if output:\n                        edited = output.get(\"diff\")\n\n                        if edited:\n                            result[\"has_diff\"] = True\n\n                        for lint in output.get(\"verification_errors\", []):\n                            lint_codes.add(lint[\"code\"])\n\n                        if edited and \"file_path\" in transition[\"state\"]:\n                            file_path = transition[\"state\"][\"file_path\"]\n                            if file_path not in edited_spans:\n                                edited_spans[file_path] = []\n                            edited_spans[file_path].append(\n                                transition[\"state\"][\"span_id\"]\n                            )\n                            transition_result[\"actual_spans\"] = (\n                                f\"{file_path}: {transition['state']['span_id']} \"\n                            )\n\n                        if not result.get(\"edited\") and (\n                                found_in_expected_spans(\n                                    instance,\n                                    edited_spans,\n                                )\n                                or found_in_alternative_spans(instance, edited_spans)\n                        ):\n                            result[\"edited\"] = True\n\n                transitions.append(transition_result)\n\n            if result.get(\"alt_identified\") or result.get(\"expected_identified\"):\n                result[\"identified\"] = min(\n                    result.get(\"alt_identified\") or 1000,\n                    result.get(\"expected_identified\") or 1000,\n                )\n\n            result[\"expected_files\"] = list(instance[\"expected_spans\"].keys())\n            result[\"edited_files\"] = list(edited_spans.keys())\n            result[\"identified_spans\"] = sum(\n                [len(v) for v in identified_spans.values()]\n            )\n    # ... other code\n    # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v1.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v1.py::3",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v1.py",
          "file_name": "report_v1.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 199,
          "span_ids": [
            "to_result"
          ],
          "start_line": 297,
          "end_line": 320,
          "community": null
        },
        "content": "def to_result(instance: dict, trajectory: dict, report: dict | None) -> tuple[dict, list]:\n\n    try:\n        # ... other code\n\n        result[\"lints\"] = \",\".join(lint_codes)\n\n        if report and info.get(\"instance_id\", \"\") in report[\"resolved\"]:\n            result[\"status\"] = \"resolved\"\n        elif result[\"edited\"]:\n            result[\"status\"] = \"edited\"\n        elif result[\"identified\"]:\n            result[\"status\"] = \"identified\"\n        elif result[\"found_in_search\"]:\n            result[\"status\"] = \"found_in_search\"\n        elif result[\"file_identified\"]:\n            result[\"status\"] = \"file_identified\"\n        else:\n            result[\"status\"] = \"\"\n\n        if \"error\" in info:\n            result[\"error\"] = info[\"error\"].split(\"\\n\")[0]\n        else:\n            result[\"error\"] = \"\"\n\n    except Exception as e:\n        raise e\n\n    return result, transitions",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v1.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v1.py::4",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v1.py",
          "file_name": "report_v1.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 802,
          "span_ids": [
            "generate_md_report"
          ],
          "start_line": 323,
          "end_line": 419,
          "community": null
        },
        "content": "def generate_md_report(trajectory: dict, instance: dict):\n    info = trajectory[\"info\"]\n    markdown = f\"# {instance['instance_id']}\\n\"\n\n    markdown += \"\\n## Problem statement\\n\"\n    markdown += f\"```\\n{instance['problem_statement']}\\n```\\n\"\n\n    if \"error\" in trajectory[\"info\"]:\n        markdown += \"\\n## Error\\n\"\n        markdown += f\"```\\n{trajectory['info']['error']}\\n```\\n\"\n    else:\n        markdown += \"\\n## Prediction\\n\"\n        markdown += f\"```diff\\n{info['submission']}\\n```\\n\"\n\n    markdown += \"\\n## Golden patch\\n\"\n    markdown += f\"```diff\\n{instance['golden_patch']}\\n```\\n\"\n\n    markdown += \"\\n## Trajectory\\n\"\n\n    repo_dir = setup_swebench_repo(instance)\n    file_repo = FileRepository(repo_dir)\n\n    for j, step in enumerate(trajectory[\"transitions\"]):\n        for i, traj_action in enumerate(step[\"actions\"]):\n            state_name = step['state']\n            markdown += f\"### {j+1} {state_name} ({i+1})\\n\\n\"\n\n            if not traj_action.get(\"action\"):\n                continue\n            action = traj_action[\"action\"]\n\n            if state_name == \"PlanToCode\":\n                if action.get(\"scratch_pad\"):\n                    markdown += \"*\" + action[\"scratch_pad\"] + \"*\"\n\n                if action.get(\"instructions\"):\n                    markdown += f\"\\n\\n * {action['instructions']}\"\n\n                if action.get(\"file_path\"):\n                    markdown += f\"\\n * {action['file_path']}\"\n\n                if action.get(\"span_id\"):\n                    markdown += f\"\\n * {action['span_id']}\"\n\n                if action.get(\"file_path\") and action.get(\"span_id\"):\n                    markdown += \"\\n\\n#### File context \\n\\n\"\n                    try:\n                        file_context = FileContext(file_repo)\n                        file_context.add_span_to_context(\n                            action.get(\"file_path\"),\n                            action.get(\"span_id\"),\n                        )\n                        markdown += file_context.create_prompt(\n                            show_outcommented_code=True\n                        )\n                    except Exception as e:\n                        logger.error(e)\n\n            if state_name == \"EditCode\":\n                markdown += \"#### LLM Response\\n\\n\"\n                markdown += f\"```\\n{action.get('content', '')}\\n```\\n\"\n\n                output = traj_action.get(\"output\")\n                if output:\n                    if output.get(\"diff\"):\n                        markdown += \"#### Diff\\n\\n\"\n                        markdown += f\"```diff\\n{output['diff']}\\n```\\n\"\n\n                    if output.get(\"errors\"):\n                        markdown += \"#### Errors\\n\\n\"\n                        markdown += f\"{output['errors']}\\n\\n\"\n\n                    if output.get(\"message\"):\n                        markdown += \"#### Message\\n\\n\"\n                        markdown += f\"{output['message']}\\n\\n\"\n\n            if state_name == \"ClarifyCodeChange\":\n                if action.get(\"thoughts\"):\n                    markdown += \"*\" + action[\"thoughts\"] + \"*\"\n\n                if action.get(\"output\") and action.get(\"output\").get(\"start_line\"):\n                    markdown += f\"\\n* Start Line: {action['output']['start_line']}\\n\"\n                    markdown += f\"\\n* End Line: {action['output']['end_line']}\\n\"\n\n            if state_name == \"Finished\":\n                markdown += f\"*{action['properties']['message']}*\\n\"\n\n            if state_name == \"Rejected\":\n                markdown += f\"*{action['properties']['message']}*\\n\"\n\n    markdown += \"## Alternative patches\\n\"\n    for alternative in instance[\"resolved_by\"]:\n        markdown += f\"### {alternative['name']}\\n\"\n        markdown += f\"```diff\\n{alternative['patch']}\\n```\\n\"\n\n    return markdown",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v1.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v2.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v2.py",
          "file_name": "report_v2.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 366,
          "span_ids": [
            "imports",
            "to_result"
          ],
          "start_line": 1,
          "end_line": 262,
          "community": null
        },
        "content": "import logging\n\nfrom moatless import FileRepository\nfrom moatless.benchmark.swebench import found_in_expected_spans, found_in_alternative_spans, setup_swebench_repo\nfrom moatless.benchmark.utils import get_missing_files\nfrom moatless.edit.plan import ApplyChange\nfrom moatless.file_context import FileContext\nfrom moatless.find.search import SearchRequest\n\nlogger = logging.getLogger(__name__)\n\nimport logging\n\nfrom moatless import FileRepository\nfrom moatless.benchmark.swebench import found_in_expected_spans, found_in_alternative_spans, setup_swebench_repo\nfrom moatless.benchmark.utils import get_missing_files\nfrom moatless.file_context import FileContext\n\nlogger = logging.getLogger(__name__)\n\nimport logging\nfrom typing import Dict, List, Tuple, Optional\n\nfrom moatless import FileRepository\nfrom moatless.benchmark.swebench import found_in_expected_spans, found_in_alternative_spans, setup_swebench_repo\nfrom moatless.benchmark.utils import get_missing_files\nfrom moatless.file_context import FileContext\nfrom moatless.trajectory import Trajectory\nfrom moatless.types import ActionTransaction, Usage, Content\nfrom moatless.state import AgenticState\n\nlogger = logging.getLogger(__name__)\n\n\ndef to_result(instance: Dict, trajectory: Trajectory, report: Optional[Dict] = None) -> Dict:\n    info = trajectory._info\n\n    if report and \"resolved_ids\" in report and instance[\"instance_id\"] in report[\"resolved_ids\"]:\n        result_status = \"resolved\"\n    else:\n        result_status = info.get(\"status\")\n\n    resolved = result_status == \"resolved\"\n\n    try:\n    # ... other code\n    # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v2.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v2.py::2",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v2.py",
          "file_name": "report_v2.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 1702,
          "span_ids": [
            "to_result"
          ],
          "start_line": 46,
          "end_line": 264,
          "community": null
        },
        "content": "def to_result(instance: Dict, trajectory: Trajectory, report: Optional[Dict] = None) -> Dict:\n\n    try:\n        result = {\n            \"instance_id\": instance[\"instance_id\"],\n            \"duration\": info.get(\"duration\", 0),\n            \"total_cost\": info.get(\"total_cost\", 0),\n            \"resolved_by\": (len(instance.get(\"resolved_by\", []))),\n            \"status\": None,\n            \"result_status\": result_status,\n            \"transitions\": len(trajectory.transitions),\n            \"edited\": False,\n            \"planned\": False,\n            \"identified\": None,\n            \"expected_identified\": None,\n            \"alt_identified\": None,\n            \"found_in_search\": None,\n            \"file_identified\": None,\n            \"file_in_search\": None,\n            \"edit_retries\": 0,\n            \"has_diff\": False,\n            \"lint_codes\": None,\n            \"review\": False,\n            \"p_query\": 0,\n            \"p_file\": 0,\n            \"p_code\": 0,\n            \"p_class\": 0,\n            \"p_function\": 0,\n            \"lints\": \"\",\n        }\n\n        lint_codes = set()\n        search_results_spans: Dict[str, List[str]] = {}\n        identified_spans: Dict[str, List[str]] = {}\n        planned_spans: Dict[str, List[str]] = {}\n        edited_spans: Dict[str, List[str]] = {}\n\n        id_iterations = 0\n        search_iterations = 0\n\n        selected_transition_ids = []\n        current_state = trajectory.get_current_state()\n        while current_state:\n            selected_transition_ids.append(current_state.id)\n            current_state = current_state.previous_state\n\n        logger.info(f\"Selected transitions: {selected_transition_ids}\")\n\n        if instance.get(\"expected_spans\"):\n            for transition in trajectory.transitions:\n                if selected_transition_ids and transition.id not in selected_transition_ids:\n                    continue\n\n                state: AgenticState = transition.state\n                state_name = state.name\n\n                if state_name not in result:\n                    result[state_name] = 0\n                    result[f\"{state_name}_cost\"] = 0\n\n                result[state_name] += 1\n\n                expected_span_str = \"\"\n                for file_path, span_ids in instance[\"expected_spans\"].items():\n                    expected_span_str += f\"{file_path}: {span_ids} \"\n\n                if not state._actions:\n                    continue\n\n                for action in state._actions:\n                    result[f\"{state_name}_cost\"] += action.usage.completion_cost if action.usage else 0\n\n                if state_name == \"SearchCode\":\n                    search_iterations += 1\n\n                    action = state._actions[-1]\n\n                    if isinstance(action.request, SearchRequest):\n                        for search_request in action.request.search_requests:\n                            if search_request.query:\n                                result[\"p_query\"] += 1\n                            if search_request.file_pattern:\n                                result[\"p_file\"] += 1\n                            if search_request.code_snippet:\n                                result[\"p_code\"] += 1\n                            if search_request.class_name or search_request.class_names:\n                                result[\"p_class\"] += 1\n                            if search_request.function_name or search_request.function_names:\n                                result[\"p_function\"] += 1\n\n                if state_name == \"IdentifyCode\":\n                    id_iterations += 1\n\n                    if state.ranked_spans:\n                        for ranked_span in state.ranked_spans:\n                            if ranked_span.file_path not in search_results_spans:\n                                search_results_spans[ranked_span.file_path] = []\n                            search_results_spans[ranked_span.file_path].append(ranked_span.span_id)\n\n                        if not result[\"found_in_search\"] and (\n                                found_in_expected_spans(instance, search_results_spans)\n                                or found_in_alternative_spans(instance, search_results_spans)\n                        ):\n                            result[\"found_in_search\"] = search_iterations\n\n                        if not result[\"file_in_search\"]:\n                            missing_files = get_missing_files(\n                                instance[\"expected_spans\"],\n                                search_results_spans,\n                            )\n                            if not missing_files:\n                                result[\"file_in_search\"] = search_iterations\n\n                    if state._actions:\n                        action = state._actions[-1]\n                        identified_str = \"\"\n                        if action.request.identified_spans:\n                            for span in action.request.identified_spans:\n                                identified_str += f\"{span.file_path}: {span.span_ids} \"\n                                if span.file_path not in identified_spans:\n                                    identified_spans[span.file_path] = []\n\n                                for span_id in span.span_ids:\n                                    identified_spans[span.file_path].append(span_id)\n                        result[\"identified_spans\"] = identified_str\n\n                    if not result[\"file_identified\"]:\n                        missing_files = get_missing_files(\n                            instance[\"expected_spans\"],\n                            identified_spans,\n                        )\n                        if not missing_files:\n                            result[\"file_identified\"] = id_iterations\n\n                    if result[\"expected_identified\"] is None and found_in_expected_spans(instance, identified_spans):\n                        result[\"expected_identified\"] = id_iterations\n\n                    if result[\"alt_identified\"] is None and found_in_alternative_spans(instance, identified_spans):\n                        result[\"alt_identified\"] = id_iterations\n\n                    if result.get(\"alt_identified\") or result.get(\"expected_identified\"):\n                        result[\"identified\"] = min(\n                            result.get(\"alt_identified\") or 1000,\n                            result.get(\"expected_identified\") or 1000,\n                        )\n\n                if state_name == \"PlanToCode\":\n                    action = state._actions[-1]\n\n                    if action.request.action == \"review\":\n                        result[\"review\"] = True\n\n                    if action.request.file_path:\n                        file_path = action.request.file_path\n                        if file_path not in planned_spans:\n                            planned_spans[file_path] = []\n                        planned_spans[file_path].append(action.request.span_id)\n\n                    if not result.get(\"planned\") and (\n                            found_in_expected_spans(instance, planned_spans)\n                            or found_in_alternative_spans(instance, planned_spans)\n                    ):\n                        result[\"planned\"] = True\n\n                if state_name == \"EditCode\":\n                    result[\"edit_retries\"] = len(state._actions) - 1\n\n                    action = state._actions[-1]\n                    edited = action.response and action.response.trigger == \"finish\"\n\n                    if edited and hasattr(state, 'file_path'):\n                        file_path = state.file_path\n                        if file_path not in edited_spans:\n                            edited_spans[file_path] = []\n                        edited_spans[file_path].append(state.span_id)\n\n                    if not result.get(\"edited\") and (\n                            found_in_expected_spans(instance, edited_spans)\n                            or found_in_alternative_spans(instance, edited_spans)\n                    ):\n                        result[\"edited\"] = True\n\n                    if action.response and action.response.output:\n                        output = action.response.output\n                        if edited:\n                            result[\"has_diff\"] = True\n\n                        for lint in output.get(\"verification_errors\", []):\n                            lint_codes.add(lint[\"code\"])\n\n            if result.get(\"alt_identified\") or result.get(\"expected_identified\"):\n                result[\"identified\"] = min(\n                    result.get(\"alt_identified\") or 1000,\n                    result.get(\"expected_identified\") or 1000,\n                )\n\n            result[\"expected_files\"] = list(instance[\"expected_spans\"].keys())\n            result[\"edited_files\"] = list(edited_spans.keys())\n            result[\"identified_spans\"] = sum(len(v) for v in identified_spans.values())\n\n        result[\"lints\"] = \",\".join(lint_codes)\n\n        if result[\"edited\"]:\n            result[\"status\"] = \"edited\"\n        elif result[\"identified\"]:\n            result[\"status\"] = \"identified\"\n        elif result[\"found_in_search\"]:\n            result[\"status\"] = \"found_in_search\"\n        elif result[\"file_identified\"]:\n            result[\"status\"] = \"file_identified\"\n        else:\n            result[\"status\"] = \"\"\n\n        if \"error\" in info:\n            result[\"error\"] = info[\"error\"].split(\"\\n\")[0]\n        else:\n            result[\"error\"] = \"\"\n\n    except Exception as e:\n        raise e\n\n    return result",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v2.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v2.py::3",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v2.py",
          "file_name": "report_v2.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 739,
          "span_ids": [
            "generate_md_report"
          ],
          "start_line": 266,
          "end_line": 353,
          "community": null
        },
        "content": "def generate_md_report(trajectory: Trajectory, instance: Dict) -> str:\n    info = trajectory._info\n    markdown = f\"# {instance['instance_id']}\\n\"\n\n    markdown += \"\\n## Problem statement\\n\"\n    markdown += f\"```\\n{instance['problem_statement']}\\n```\\n\"\n\n    if \"error\" in trajectory._info:\n        markdown += \"\\n## Error\\n\"\n        markdown += f\"```\\n{trajectory._info['error']}\\n```\\n\"\n    else:\n        markdown += \"\\n## Prediction\\n\"\n        markdown += f\"```diff\\n{info['submission']}\\n```\\n\"\n\n    markdown += \"\\n## Golden patch\\n\"\n    markdown += f\"```diff\\n{instance['golden_patch']}\\n```\\n\"\n\n    markdown += \"\\n## Trajectory\\n\"\n\n    repo_dir = setup_swebench_repo(instance)\n    file_repo = FileRepository(repo_dir)\n\n    for j, transition in enumerate(trajectory.transitions):\n        state = transition.state\n        for i, action in enumerate(state._actions):\n            markdown += f\"### {j+1} {state.name} ({i+1})\\n\\n\"\n\n            if state.name == \"PlanToCode\":\n                if action.request.file_path:\n                    if action.request.instructions:\n                        markdown += f\"\\n\\n * {action.request.instructions}\"\n                    markdown += f\"\\n * {action.request.file_path}\"\n                    markdown += f\"\\n * {action.request.span_id}\"\n\n                    markdown += \"\\n\\n#### File context \\n\\n\"\n                    try:\n                        file_context = FileContext(file_repo)\n                        file_context.add_span_to_context(\n                            action.request.file_path,\n                            action.request.span_id,\n                        )\n                        markdown += file_context.create_prompt(\n                            show_outcommented_code=True\n                        )\n                    except Exception as e:\n                        logger.error(e)\n\n            if state.name == \"EditCode\":\n                markdown += \"#### LLM Response\\n\\n\"\n                markdown += f\"```\\n{action.request.content if isinstance(action.request, Content) else ''}\\n```\\n\"\n\n                if action.response and action.response.output:\n                    output = action.response.output\n                    if output.get(\"diff\"):\n                        markdown += \"#### Diff\\n\\n\"\n                        markdown += f\"```diff\\n{output['diff']}\\n```\\n\"\n\n                    if output.get(\"errors\"):\n                        markdown += \"#### Errors\\n\\n\"\n                        markdown += f\"{output['errors']}\\n\\n\"\n\n                    if output.get(\"message\"):\n                        markdown += \"#### Message\\n\\n\"\n                        markdown += f\"{output['message']}\\n\\n\"\n\n            if state.name == \"ClarifyCodeChange\":\n\n                if action.request.scratch_pad:\n                    markdown += f\"*{action.request.scratch_pad}*\"\n\n                if action.response and action.response.output:\n                    output = action.response.output\n                    if output.get(\"start_line\"):\n                        markdown += f\"\\n* Start Line: {output['start_line']}\\n\"\n                        markdown += f\"\\n* End Line: {output['end_line']}\\n\"\n\n            if state.name == \"Finished\":\n                markdown += f\"*{action.request.thoughts}*\\n\"\n\n            if state.name == \"Rejected\":\n                markdown += f\"*{action.request.thoughts}*\\n\"\n\n    markdown += \"## Alternative patches\\n\"\n    for alternative in instance[\"resolved_by\"]:\n        markdown += f\"### {alternative['name']}\\n\"\n        markdown += f\"```diff\\n{alternative['patch']}\\n```\\n\"\n\n    return markdown",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v2.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/report_v2.py::4",
        "metadata": {
          "file_path": "moatless\\benchmark\\report_v2.py",
          "file_name": "report_v2.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 802,
          "span_ids": [
            "generate_md_report_2"
          ],
          "start_line": 354,
          "end_line": 450,
          "community": null
        },
        "content": "def generate_md_report(trajectory: dict, instance: dict):\n    info = trajectory[\"info\"]\n    markdown = f\"# {instance['instance_id']}\\n\"\n\n    markdown += \"\\n## Problem statement\\n\"\n    markdown += f\"```\\n{instance['problem_statement']}\\n```\\n\"\n\n    if \"error\" in trajectory[\"info\"]:\n        markdown += \"\\n## Error\\n\"\n        markdown += f\"```\\n{trajectory['info']['error']}\\n```\\n\"\n    else:\n        markdown += \"\\n## Prediction\\n\"\n        markdown += f\"```diff\\n{info['submission']}\\n```\\n\"\n\n    markdown += \"\\n## Golden patch\\n\"\n    markdown += f\"```diff\\n{instance['golden_patch']}\\n```\\n\"\n\n    markdown += \"\\n## Trajectory\\n\"\n\n    repo_dir = setup_swebench_repo(instance)\n    file_repo = FileRepository(repo_dir)\n\n    for j, step in enumerate(trajectory[\"transitions\"]):\n        for i, traj_action in enumerate(step[\"actions\"]):\n            state_name = step['state']\n            markdown += f\"### {j+1} {state_name} ({i+1})\\n\\n\"\n\n            if not traj_action.get(\"action\"):\n                continue\n            action = traj_action[\"action\"]\n\n            if state_name == \"PlanToCode\":\n                if action.get(\"scratch_pad\"):\n                    markdown += \"*\" + action[\"scratch_pad\"] + \"*\"\n\n                if action.get(\"instructions\"):\n                    markdown += f\"\\n\\n * {action['instructions']}\"\n\n                if action.get(\"file_path\"):\n                    markdown += f\"\\n * {action['file_path']}\"\n\n                if action.get(\"span_id\"):\n                    markdown += f\"\\n * {action['span_id']}\"\n\n                if action.get(\"file_path\") and action.get(\"span_id\"):\n                    markdown += \"\\n\\n#### File context \\n\\n\"\n                    try:\n                        file_context = FileContext(file_repo)\n                        file_context.add_span_to_context(\n                            action.get(\"file_path\"),\n                            action.get(\"span_id\"),\n                        )\n                        markdown += file_context.create_prompt(\n                            show_outcommented_code=True\n                        )\n                    except Exception as e:\n                        logger.error(e)\n\n            if state_name == \"EditCode\":\n                markdown += \"#### LLM Response\\n\\n\"\n                markdown += f\"```\\n{action.get('content', '')}\\n```\\n\"\n\n                output = traj_action.get(\"output\")\n                if output:\n                    if output.get(\"diff\"):\n                        markdown += \"#### Diff\\n\\n\"\n                        markdown += f\"```diff\\n{output['diff']}\\n```\\n\"\n\n                    if output.get(\"errors\"):\n                        markdown += \"#### Errors\\n\\n\"\n                        markdown += f\"{output['errors']}\\n\\n\"\n\n                    if output.get(\"message\"):\n                        markdown += \"#### Message\\n\\n\"\n                        markdown += f\"{output['message']}\\n\\n\"\n\n            if state_name == \"ClarifyCodeChange\":\n                if action.get(\"thoughts\"):\n                    markdown += \"*\" + action[\"thoughts\"] + \"*\"\n\n                if action.get(\"output\") and action.get(\"output\").get(\"start_line\"):\n                    markdown += f\"\\n* Start Line: {action['output']['start_line']}\\n\"\n                    markdown += f\"\\n* End Line: {action['output']['end_line']}\\n\"\n\n            if state_name == \"Finished\":\n                markdown += f\"*{action['properties']['message']}*\\n\"\n\n            if state_name == \"Rejected\":\n                markdown += f\"*{action['properties']['message']}*\\n\"\n\n    markdown += \"## Alternative patches\\n\"\n    for alternative in instance[\"resolved_by\"]:\n        markdown += f\"### {alternative['name']}\\n\"\n        markdown += f\"```diff\\n{alternative['patch']}\\n```\\n\"\n\n    return markdown",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/report_v2.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "swebench/__init__.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\swebench\\__init__.py",
          "file_name": "__init__.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 16,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 2,
          "community": null
        },
        "content": "from moatless.benchmark.swebench.utils import *  # noqa\r",
        "summary": null,
        "ctxt_list": [],
        "id": "swebench/__init__.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "swebench/utils.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\swebench\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 393,
          "span_ids": [
            "load_instance",
            "get_repo_dir_name",
            "found_in_expected_spans",
            "imports",
            "sorted_instances",
            "load_instances"
          ],
          "start_line": 1,
          "end_line": 60,
          "community": null
        },
        "content": "import logging\nimport os\nfrom typing import Optional\n\nfrom datasets import load_dataset\n\nfrom moatless.benchmark.utils import (\n    file_spans_to_dict,\n    get_missing_files,\n    get_missing_spans,\n)\nfrom moatless.file_context import FileContext\nfrom moatless.index import CodeIndex\nfrom moatless.repository import FileRepository, GitRepository\nfrom moatless.utils.repo import setup_github_repo\nfrom moatless.workspace import Workspace\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef load_instances(\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\", split: str = \"test\"\n):\n    data = load_dataset(dataset_name, split=split)\n    return {d[\"instance_id\"]: d for d in data}\n\n\ndef load_instance(\n    instance_id: str,\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\",\n    split: str = \"test\",\n):\n    data = load_instances(dataset_name, split=split)\n    return data[instance_id]\n\n\ndef sorted_instances(\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\",\n    split: str = \"test\",\n    sort_by: str = \"created_at\",\n):\n    data = load_dataset(dataset_name, split=split)\n    instances = list(data)\n    instances = sorted(instances, key=lambda x: x[sort_by])\n    return instances\n\n\ndef get_repo_dir_name(repo: str):\n    return repo.replace(\"/\", \"_\")\n\n\ndef found_in_expected_spans(instance: dict, spans: dict):\n    for file_path, span_ids in instance[\"expected_spans\"].items():\n        if not span_ids:\n            logging.warning(\n                f\"{instance['instance_id']} Expected spans for {file_path} is empty\"\n            )\n    missing_spans = get_missing_spans(instance[\"expected_spans\"], spans)\n    return not missing_spans",
        "summary": null,
        "ctxt_list": [],
        "id": "swebench/utils.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "swebench/utils.py::2",
        "metadata": {
          "file_path": "moatless\\benchmark\\swebench\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 203,
          "span_ids": [
            "sync_file_context_with_search_trajectory",
            "found_in_alternative_spans"
          ],
          "start_line": 63,
          "end_line": 87,
          "community": null
        },
        "content": "def found_in_alternative_spans(instance: dict, spans: dict):\n    if \"alternative_spans\" not in instance:\n        return False\n    for alternative_spans in instance[\"alternative_spans\"]:\n        for file_path, span_ids in alternative_spans[\"spans\"].items():\n            if not span_ids:\n                logging.warning(\n                    f\"{instance['instance_id']} Alternative spans for {file_path} is empty\"\n                )\n\n        missing_spans = get_missing_spans(alternative_spans[\"spans\"], spans)\n        if not missing_spans:\n            return True\n\n    return False\n\n\ndef sync_file_context_with_search_trajectory(workspace: Workspace, trajectory: dict):\n    for transition in trajectory[\"transitions\"]:\n        for action in transition[\"actions\"]:\n            if action[\"action\"].get(\"identified_spans\"):\n                for span in action[\"action\"][\"identified_spans\"]:\n                    workspace.file_context.add_spans_to_context(\n                        span[\"file_path\"], span[\"span_ids\"]\n                    )",
        "summary": null,
        "ctxt_list": [],
        "id": "swebench/utils.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "swebench/utils.py::3",
        "metadata": {
          "file_path": "moatless\\benchmark\\swebench\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 854,
          "span_ids": [
            "verify_search_trajectory"
          ],
          "start_line": 90,
          "end_line": 199,
          "community": null
        },
        "content": "def verify_search_trajectory(\n    trajectory: dict, instance: dict, workspace: Workspace\n) -> dict:\n    result = {\n        \"transitions\": len(trajectory[\"transitions\"]),\n        \"identifieed\": None,\n        \"expected_identified\": None,\n        \"alt_identified\": None,\n        \"identified\": None,\n        \"file_identified\": None,\n        \"found_in_search\": None,\n        \"tokens\": 0,\n        \"expanded_imports\": False,\n        \"expanded_related\": False,\n        \"expanded_small_classes\": False,\n        \"expanded_tokens\": 0,\n    }\n\n    file_context = workspace.create_file_context()\n    search_file_context = workspace.create_file_context()\n\n    iterations = 0\n    for transition in trajectory[\"transitions\"]:\n        if transition[\"name\"] == \"SearchCode\":\n            iterations += 1\n\n        for action in transition[\"actions\"]:\n            if (\n                \"output\" in action\n                and action.get(\"output\")\n                and action[\"output\"].get(\"ranked_spans\")\n            ):\n                for ranked_span in action[\"output\"][\"ranked_spans\"]:\n                    search_file_context.add_spans_to_context(\n                        ranked_span[\"file_path\"], [ranked_span[\"span_id\"]]\n                    )\n\n            if action[\"action\"].get(\"identified_spans\"):\n                for span in action[\"action\"][\"identified_spans\"]:\n                    file_context.add_spans_to_context(\n                        span[\"file_path\"], span[\"span_ids\"]\n                    )\n\n            if result[\"found_in_search\"] is None and (\n                found_in_expected_spans(\n                    instance,\n                    file_spans_to_dict(search_file_context.to_files_with_spans()),\n                )\n                or found_in_alternative_spans(\n                    instance, file_spans_to_dict(file_context.to_files_with_spans())\n                )\n            ):\n                result[\"found_in_search\"] = iterations\n\n            if result[\"file_identified\"] is None:\n                missing_files = get_missing_files(\n                    instance[\"expected_spans\"],\n                    file_spans_to_dict(file_context.to_files_with_spans()),\n                )\n                if not missing_files:\n                    result[\"file_identified\"] = iterations\n\n            if result[\"expected_identified\"] is None and found_in_expected_spans(\n                instance, file_spans_to_dict(file_context.to_files_with_spans())\n            ):\n                result[\"expected_identified\"] = iterations\n\n            if result[\"alt_identified\"] is None and found_in_alternative_spans(\n                instance, file_spans_to_dict(file_context.to_files_with_spans())\n            ):\n                result[\"alt_identified\"] = iterations\n\n    if result[\"expected_identified\"] is not None:\n        result[\"identified\"] = result[\"expected_identified\"]\n\n    if result[\"alt_identified\"] is not None and (\n        result[\"identified\"] is None or result[\"alt_identified\"] < result[\"identified\"]\n    ):\n        result[\"identified\"] = result[\"alt_identified\"]\n\n    result[\"tokens\"] = file_context.context_size()\n\n    file_context.expand_context_with_init_spans()\n    actual_span_dicts = file_spans_to_dict(file_context.to_files_with_spans())\n\n    if found_in_expected_spans(\n        instance, actual_span_dicts\n    ) or found_in_alternative_spans(instance, actual_span_dicts):\n        result[\"expanded_imports\"] = True\n\n    file_context.expand_context_with_related_spans(max_tokens=8000)\n    if found_in_expected_spans(\n        instance, file_spans_to_dict(file_context.to_files_with_spans())\n    ) or found_in_alternative_spans(\n        instance, file_spans_to_dict(file_context.to_files_with_spans())\n    ):\n        result[\"expanded_related\"] = True\n\n    file_context.expand_small_classes(max_tokens=500)\n    if found_in_expected_spans(\n        instance, file_spans_to_dict(file_context.to_files_with_spans())\n    ) or found_in_alternative_spans(\n        instance, file_spans_to_dict(file_context.to_files_with_spans())\n    ):\n        result[\"expanded_small_classes\"] = True\n\n    result[\"expanded_tokens\"] = file_context.context_size()\n\n    result[\"iterations\"] = iterations\n    return result",
        "summary": null,
        "ctxt_list": [],
        "id": "swebench/utils.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "swebench/utils.py::4",
        "metadata": {
          "file_path": "moatless\\benchmark\\swebench\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 718,
          "span_ids": [
            "generate_md_report"
          ],
          "start_line": 202,
          "end_line": 278,
          "community": null
        },
        "content": "def generate_md_report(trajectory: dict, instance: dict):\n    info = trajectory[\"info\"]\n    markdown = f\"# {info['instance_id']}\\n\"\n\n    markdown += \"\\n## Problem statement\\n\"\n    markdown += f\"```\\n{instance['problem_statement']}\\n```\\n\"\n\n    if \"error\" in trajectory[\"info\"]:\n        markdown += \"\\n## Error\\n\"\n        markdown += f\"```\\n{trajectory['info']['error']}\\n```\\n\"\n    else:\n        markdown += \"\\n## Prediction\\n\"\n        markdown += f\"```diff\\n{info['submission']}\\n```\\n\"\n\n    markdown += \"\\n## Golden patch\\n\"\n    markdown += f\"```diff\\n{instance['golden_patch']}\\n```\\n\"\n\n    markdown += \"\\n## Trajectory\\n\"\n\n    repo_dir = setup_swebench_repo(instance)\n    file_repo = FileRepository(repo_dir)\n\n    for step in trajectory[\"transitions\"]:\n        for i, action in enumerate(step[\"actions\"]):\n            markdown += f\"### {step['name']} ({i})\\n\\n\"\n\n            if step[\"name\"] == \"PlanToCode\":\n                if action.get(\"action\").get(\"thoughts\"):\n                    markdown += \"*\" + action[\"action\"][\"thoughts\"] + \"*\"\n\n                if action.get(\"action\", {}).get(\"action\", {}).get(\"description\"):\n                    markdown += f\"\\n\\n * {action['action']['action']['description']}\"\n\n                if action.get(\"action\", {}).get(\"action\", {}).get(\"file_path\"):\n                    markdown += f\"\\n * {action['action']['action']['file_path']}\"\n\n                if action.get(\"action\", {}).get(\"action\", {}).get(\"span_id\"):\n                    markdown += f\"\\n * {action['action']['action']['span_id']}\"\n\n                    markdown += \"\\n\\n#### File context \\n\\n\"\n\n                    file_context = FileContext(file_repo)\n                    file_context.add_span_to_context(\n                        action[\"action\"][\"action\"][\"file_path\"],\n                        action[\"action\"][\"action\"][\"span_id\"],\n                    )\n\n                    markdown += file_context.create_prompt(show_outcommented_code=True)\n\n            if step[\"name\"] == \"EditCode\":\n                markdown += \"#### LLM Response\\n\\n\"\n                markdown += f\"```\\n{action['action']['content']}\\n```\\n\"\n\n                if action.get(\"output\", {}).get(\"message\"):\n                    markdown += \"#### Output\\n\\n\"\n                    markdown += f\"{action['output']['message']}\\n\\n\"\n\n            if step[\"name\"] == \"ClarifyCodeChange\":\n                if action.get(\"thoughts\"):\n                    markdown += \"*\" + action[\"thoughts\"] + \"*\"\n\n                if action.get(\"output\", {}).get(\"start_line\"):\n                    markdown += f\"\\n* Start Line: {action['output']['start_line']}\\n\"\n                    markdown += f\"\\n* End Line: {action['output']['end_line']}\\n\"\n\n            if step[\"name\"] == \"Finished\":\n                markdown += f\"*{action['properties']['message']}*\\n\"\n\n            if step[\"name\"] == \"Rejected\":\n                markdown += f\"*{action['properties']['message']}*\\n\"\n\n    markdown += \"## Alternative patches\\n\"\n    for alternative in instance[\"resolved_by\"]:\n        markdown += f\"### {alternative['name']}\\n\"\n        markdown += f\"```diff\\n{alternative['patch']}\\n```\\n\"\n\n    return markdown",
        "summary": null,
        "ctxt_list": [],
        "id": "swebench/utils.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "swebench/utils.py::5",
        "metadata": {
          "file_path": "moatless\\benchmark\\swebench\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 165,
          "span_ids": [
            "setup_swebench_repo"
          ],
          "start_line": 281,
          "end_line": 301,
          "community": null
        },
        "content": "def setup_swebench_repo(\n    instance_data: Optional[dict] = None,\n    instance_id: str = None,\n    repo_base_dir: Optional[str] = None,\n) -> str:\n    assert (\n        instance_data or instance_id\n    ), \"Either instance_data or instance_id must be provided\"\n    if not instance_data:\n        instance_data = load_instance(instance_id)\n\n    if not repo_base_dir:\n        repo_base_dir = os.getenv(\"REPO_DIR\", \"/tmp/repos\")\n\n    repo_dir_name = instance_data[\"repo\"].replace(\"/\", \"__\")\n    github_repo_path = f\"swe-bench/{repo_dir_name}\"\n    return setup_github_repo(\n        repo=github_repo_path,\n        base_commit=instance_data[\"base_commit\"],\n        base_dir=repo_base_dir,\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "swebench/utils.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "swebench/utils.py::6",
        "metadata": {
          "file_path": "moatless\\benchmark\\swebench\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 273,
          "span_ids": [
            "create_workspace"
          ],
          "start_line": 304,
          "end_line": 338,
          "community": null
        },
        "content": "def create_workspace(\n    instance: Optional[dict] = None,\n    instance_id: Optional[str] = None,\n    repo_base_dir: Optional[str] = None,\n    index_store_dir: Optional[str] = None,\n):\n    \"\"\"\n    Create a workspace for the given SWE-bench instance.\n    \"\"\"\n    assert instance or instance_id, \"Either instance or instance_id must be provided\"\n    if not instance:\n        instance = load_instance(instance_id)\n\n    if not index_store_dir:\n        index_store_dir = os.getenv(\"INDEX_STORE_DIR\", \"/tmp/index_store\")\n\n    if not repo_base_dir:\n        repo_base_dir = os.getenv(\"REPO_DIR\", \"/tmp/repos\")\n\n    repo_dir_name = instance[\"repo\"].replace(\"/\", \"__\")\n    repo_url = f\"https://github.com/swe-bench/{repo_dir_name}.git\"\n    repo_dir = f\"{repo_base_dir}/swe-bench_{repo_dir_name}\"\n    repo = GitRepository.from_repo(\n        git_repo_url=repo_url, repo_path=repo_dir, commit=instance[\"base_commit\"]\n    )\n\n    code_index = CodeIndex.from_index_name(\n        instance[\"instance_id\"], index_store_dir=index_store_dir, file_repo=repo\n    )\n\n    return Workspace(\n        file_repo=repo,\n        code_index=code_index,\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "swebench/utils.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::1",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 337,
          "span_ids": [
            "imports",
            "find_relevant_spans"
          ],
          "start_line": 1,
          "end_line": 46,
          "community": null
        },
        "content": "import logging\nimport re\nimport time\n\nfrom moatless.codeblocks.module import Module\nfrom moatless.repository import FileRepository\nfrom moatless.types import FileWithSpans\n\nlogger = logging.getLogger(__name__)\n\n\ndef find_relevant_spans(original_block: Module, updated_block: Module):\n    \"\"\"Find relevant spans in test content. Used for finding the \"perfect\" context in benchmark instances.\"\"\"\n\n    relevant_spans = set()\n\n    for span in updated_block.spans_by_id.values():\n        if span.span_id in relevant_spans:\n            continue\n\n        if original_block.has_span(span.span_id):\n            updated_content = updated_block.to_prompt(\n                span_ids=set(span.span_id), show_outcommented_code=False\n            ).strip()\n            original_content = original_block.to_prompt(\n                span_ids=set(span.span_id), show_outcommented_code=False\n            ).strip()\n            if original_content != updated_content:\n                relevant_spans.add(span.span_id)\n\n            # TODO: Second prio after token count\n            related_span_ids = original_block.find_related_span_ids(span.span_id)\n            relevant_spans.update(related_span_ids)\n        else:\n            parent_block = updated_block.find_first_by_span_id(span.span_id).parent\n            original_parent_block = original_block.find_by_path(\n                parent_block.full_path()\n            )\n            span_ids = list(original_parent_block.belongs_to_span.span_id)\n\n            related_span_ids = updated_block.find_related_span_ids(span.span_id)\n            for related_span_id in related_span_ids:\n                if original_block.has_span(related_span_id):\n                    span_ids.append(related_span_id)\n\n    return relevant_spans",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::2",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 277,
          "span_ids": [
            "get_diff_lines"
          ],
          "start_line": 49,
          "end_line": 87,
          "community": null
        },
        "content": "def get_diff_lines(diff_input):\n    if not diff_input:\n        return []\n    file_name_re = re.compile(r\"diff --git a/(.+) b/.+\")\n    file_name_no_git_re = re.compile(r\"--- a/(.+)\")\n\n    line_change_re = re.compile(r\"^@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@\")\n\n    changes = []\n\n    current_file = None\n    for line in diff_input.splitlines():\n        file_match = file_name_re.match(line)\n        if file_match:\n            current_file = file_match.group(1)\n            continue\n\n        if not current_file:\n            file_match = file_name_no_git_re.match(line)\n            if file_match:\n                current_file = file_match.group(1)\n\n            continue\n\n        line_change_match = line_change_re.match(line)\n        if line_change_match:\n            old_start, old_length, new_start, new_length = map(\n                int, line_change_match.groups()\n            )\n\n            adjustment_start = max(1, min(3, old_start - 3))\n            adjusted_start = old_start + adjustment_start\n\n            relevant_diff_lines = max(0, old_length - 7)\n            adjusted_end = adjusted_start + relevant_diff_lines\n\n            changes.append((current_file, adjusted_start, adjusted_end))\n\n    return changes",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::3",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 274,
          "span_ids": [
            "create_file_spans_from_patch",
            "compare_patches"
          ],
          "start_line": 90,
          "end_line": 126,
          "community": null
        },
        "content": "def compare_patches(expected_patch, actual_patch):\n    expected_diffs = get_diff_lines(expected_patch)\n    actual_diffs = get_diff_lines(actual_patch)\n\n    expected_files = set()\n    file_hits = set()\n    line_hits = 0\n\n    for patch_diff in expected_diffs:\n        change_file, change_start, change_end = patch_diff\n\n        for actual_diff in actual_diffs:\n            actual_change_file, actual_change_start, actual_change_end = actual_diff\n            expected_files.add(change_file)\n            if change_file == actual_change_file:\n                file_hits.add(change_file)\n                if (\n                    change_start >= actual_change_start\n                    and change_end <= actual_change_end\n                ):\n                    line_hits += 1\n                    continue\n\n    return len(expected_files) - len(file_hits), len(expected_diffs) - line_hits\n\n\ndef create_file_spans_from_patch(repo_dir: str, patch: str) -> list[FileWithSpans]:\n    repository = FileRepository(repo_dir)\n    files_with_spans = []\n    for file_path, span_ids in get_file_spans_from_patch(repository, patch).items():\n        file_with_spans = FileWithSpans(\n            file_path=file_path,\n            span_ids=span_ids,\n        )\n        files_with_spans.append(file_with_spans)\n\n    return files_with_spans",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::4",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 168,
          "span_ids": [
            "get_file_spans_from_patch"
          ],
          "start_line": 129,
          "end_line": 148,
          "community": null
        },
        "content": "def get_file_spans_from_patch(\n    repository: FileRepository, patch: str\n) -> dict[str, list[str]]:\n    expected_diff_lines = get_diff_lines(patch)\n    expected_files_with_spans = {}\n\n    for diff_line in expected_diff_lines:\n        file = repository.get_file(diff_line[0])\n\n        if file is None or file.module is None:\n            continue\n\n        if file.file_path not in expected_files_with_spans:\n            expected_files_with_spans[file.file_path] = []\n\n        spans = file.module.find_spans_by_line_numbers(diff_line[1], diff_line[2])\n        for span in spans:\n            if span.span_id not in expected_files_with_spans[file.file_path]:\n                expected_files_with_spans[file.file_path].append(span.span_id)\n    return expected_files_with_spans",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::5",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 162,
          "span_ids": [
            "file_spans_to_dict",
            "get_files_from_patch"
          ],
          "start_line": 151,
          "end_line": 168,
          "community": null
        },
        "content": "def get_files_from_patch(patch: str) -> list[str]:\n    diff_lines = get_diff_lines(patch)\n    return [diff_line[0] for diff_line in diff_lines]\n\n\ndef file_spans_to_dict(files_with_spans: list[FileWithSpans]) -> dict[str, list[str]]:\n    span_dict = {}\n    if not files_with_spans:\n        return span_dict\n\n    for file_with_spans in files_with_spans:\n        if file_with_spans.file_path not in span_dict:\n            span_dict[file_with_spans.file_path] = []\n\n        for span_id in file_with_spans.span_ids:\n            if span_id not in span_dict[file_with_spans.file_path]:\n                span_dict[file_with_spans.file_path].append(span_id)\n    return span_dict",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::6",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 215,
          "span_ids": [
            "get_missing_spans",
            "get_missing_files"
          ],
          "start_line": 171,
          "end_line": 198,
          "community": null
        },
        "content": "def get_missing_files(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> list[str]:\n    misses = list(expected_files_with_spans.keys())\n    for actual_file in actual_files_with_spans:\n        if actual_file in misses:\n            misses.remove(actual_file)\n    return misses\n\n\ndef get_missing_spans(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> dict[str, list[str]]:\n    misses = {}\n    for expected_file, span_ids in expected_files_with_spans.items():\n        if expected_file not in actual_files_with_spans:\n            misses[expected_file] = span_ids\n            continue\n\n        for span_id in span_ids:\n            if span_id not in actual_files_with_spans[expected_file]:\n                if expected_file not in misses:\n                    misses[expected_file] = []\n                misses[expected_file].append(span_id)\n\n    return misses",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::7",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 376,
          "span_ids": [
            "calculate_estimated_context_window"
          ],
          "start_line": 201,
          "end_line": 255,
          "community": null
        },
        "content": "def calculate_estimated_context_window(instance, results):\n    patch_diffs = get_diff_lines(instance[\"patch\"])\n    expected_changes = []\n\n    for patch_diff in patch_diffs:\n        change_file, change_start, change_end = patch_diff\n        expected_changes.append(\n            {\n                \"file_path\": change_file,\n                \"start_line\": change_start,\n                \"end_line\": change_end,\n                \"closest_match_context_window\": None,\n                \"closest_match_lines\": None,\n                \"position\": None,\n                \"distance\": None,\n                \"context_window\": None,\n            }\n        )\n\n    sum_tokens = 0\n\n    for i, result in enumerate(results):\n        sum_tokens += result.tokens\n        for change in expected_changes:\n            if result.file_path == change[\"file_path\"]:\n                if (\n                    result.start_line - 1 <= change[\"start_line\"]\n                    and result.end_line + 1 >= change[\"end_line\"]\n                ):\n                    change[\"distance\"] = result.distance\n                    change[\"context_window\"] = sum_tokens\n                    change[\"position\"] = i\n\n                    if all(\n                        context[\"context_window\"] is not None\n                        for context in expected_changes\n                    ):\n                        return expected_changes, sum_tokens\n                else:\n                    closest_match_lines = change.get(\"closest_match_lines\")\n                    if (\n                        not closest_match_lines\n                        or abs(result.start_line - change[\"start_line\"])\n                        < abs(closest_match_lines[0] - change[\"start_line\"])\n                    ) or (\n                        abs(result.end_line - change[\"end_line\"])\n                        == abs(closest_match_lines[0] - change[\"end_line\"])\n                    ):\n                        change[\"closest_match_lines\"] = (\n                            result.start_line,\n                            result.end_line,\n                        )\n                        change[\"closest_match_context_window\"] = sum_tokens\n\n    return expected_changes, sum_tokens",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "benchmark/utils.py::8",
        "metadata": {
          "file_path": "moatless\\benchmark\\utils.py",
          "file_name": "utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 156,
          "span_ids": [
            "get_total_cost",
            "trace_metadata"
          ],
          "start_line": 258,
          "end_line": 281,
          "community": null
        },
        "content": "def get_total_cost(trace_id):\n    try:\n        import langfuse\n    except ImportError:\n        logger.info(\"Langfuse not installed, can't get total cost\")\n        return 0\n\n    langfuse = langfuse.Langfuse()\n    trace = langfuse.get_trace(trace_id)\n\n    return trace.total_cost\n\n\ndef trace_metadata(instance_id: str, session_id: str, trace_name: str):\n    date_time_str = time.strftime(\"%Y%m%d-%H%M%S\")\n    trace_id = f\"coder_{instance_id}_{date_time_str}\"\n    return {\n        \"session_id\": session_id,\n        \"name\": trace_name,\n        \"trace\": trace_name,\n        \"trace_id\": trace_id,\n        \"tags\": [instance_id],\n    }",
        "summary": null,
        "ctxt_list": [],
        "id": "benchmark/utils.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/__init__.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\__init__.py",
          "file_name": "__init__.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 127,
          "span_ids": [
            "imports",
            "get_parser_by_path",
            "supports_codeblocks"
          ],
          "start_line": 1,
          "end_line": 19,
          "community": null
        },
        "content": "from moatless.codeblocks.codeblocks import CodeBlock, CodeBlockType\nfrom moatless.codeblocks.parser.create import create_parser\nfrom moatless.codeblocks.parser.java import JavaParser\nfrom moatless.codeblocks.parser.parser import CodeParser\nfrom moatless.codeblocks.parser.python import PythonParser\n\n\ndef supports_codeblocks(path: str):\n    return path.endswith(\".py\")\n\n\ndef get_parser_by_path(file_path: str) -> CodeParser | None:\n    if file_path.endswith(\".py\"):\n        return PythonParser()\n    elif file_path.endswith(\".java\"):\n        return JavaParser()\n    else:\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/__init__.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 139,
          "span_ids": [
            "imports",
            "SpanMarker",
            "CodeBlockTypeGroup"
          ],
          "start_line": 1,
          "end_line": 29,
          "community": null
        },
        "content": "import re\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, Field, model_validator, field_validator\nfrom typing_extensions import deprecated\n\nfrom moatless.codeblocks.parser.comment import get_comment_symbol\nfrom moatless.utils.colors import Colors\n\nBlockPath = list[str]\n\n\nclass SpanMarker(Enum):\n    TAG = 1\n    COMMENT = 2\n\n\nclass CodeBlockTypeGroup(str, Enum):\n    STRUCTURE = \"Structures\"\n    IMPLEMENTATION = \"Implementation\"\n    IMPORT = \"Imports\"\n\n    BLOCK_DELIMITER = \"BlockDelimiter\"\n    SPACE = \"Space\"\n\n    COMMENT = \"Comment\"\n\n    ERROR = \"Error\"",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::2",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 416,
          "span_ids": [
            "CodeBlockType.__init__",
            "CodeBlockType"
          ],
          "start_line": 32,
          "end_line": 73,
          "community": null
        },
        "content": "class CodeBlockType(Enum):\n    MODULE = (\n        \"Module\",\n        CodeBlockTypeGroup.STRUCTURE,\n    )  # TODO: Module shouldn't be a STRUCTURE\n    CLASS = (\"Class\", CodeBlockTypeGroup.STRUCTURE)\n    FUNCTION = (\"Function\", CodeBlockTypeGroup.STRUCTURE)\n\n    # TODO: Remove and add sub types to functions and classes\n    CONSTRUCTOR = (\"Constructor\", CodeBlockTypeGroup.STRUCTURE)\n    TEST_SUITE = (\"TestSuite\", CodeBlockTypeGroup.STRUCTURE)\n    TEST_CASE = (\"TestCase\", CodeBlockTypeGroup.STRUCTURE)\n\n    IMPORT = (\"Import\", CodeBlockTypeGroup.IMPORT)\n\n    EXPORT = (\"Export\", CodeBlockTypeGroup.IMPLEMENTATION)\n    COMPOUND = (\"Compound\", CodeBlockTypeGroup.IMPLEMENTATION)\n    # Dependent clauses are clauses that are dependent on another compound statement and can't be shown on their own\n    DEPENDENT_CLAUSE = (\"DependentClause\", CodeBlockTypeGroup.IMPLEMENTATION)\n    ASSIGNMENT = (\"Assignment\", CodeBlockTypeGroup.IMPLEMENTATION)\n    CALL = (\"Call\", CodeBlockTypeGroup.IMPLEMENTATION)\n    STATEMENT = (\"Statement\", CodeBlockTypeGroup.IMPLEMENTATION)\n\n    CODE = (\"Code\", CodeBlockTypeGroup.IMPLEMENTATION)\n\n    # TODO: Incorporate in code block?\n    BLOCK_DELIMITER = (\"BlockDelimiter\", CodeBlockTypeGroup.BLOCK_DELIMITER)\n\n    # TODO: Remove as it's just to fill upp spaces at the end of the file?\n    SPACE = (\"Space\", CodeBlockTypeGroup.SPACE)\n\n    COMMENT = (\"Comment\", CodeBlockTypeGroup.COMMENT)\n    COMMENTED_OUT_CODE = (\n        \"Placeholder\",\n        CodeBlockTypeGroup.COMMENT,\n    )  # TODO: Replace to PlaceholderComment\n\n    ERROR = (\"Error\", CodeBlockTypeGroup.ERROR)\n\n    def __init__(self, value: str, group: CodeBlockTypeGroup):\n        self._value_ = value\n        self.group = group",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::3",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 224,
          "span_ids": [
            "CodeBlockType.from_string"
          ],
          "start_line": 75,
          "end_line": 99,
          "community": null
        },
        "content": "class CodeBlockType(Enum):\n\n    @classmethod\n    def from_string(cls, tag: str) -> Optional[\"CodeBlockType\"]:\n        if not tag.startswith(\"definition\"):\n            return None\n\n        tag_to_block_type = {\n            \"definition.assignment\": cls.ASSIGNMENT,\n            \"definition.block_delimiter\": cls.BLOCK_DELIMITER,\n            \"definition.call\": cls.CALL,\n            \"definition.class\": cls.CLASS,\n            \"definition.code\": cls.CODE,\n            \"definition.comment\": cls.COMMENT,\n            \"definition.compound\": cls.COMPOUND,\n            \"definition.constructor\": cls.CONSTRUCTOR,\n            \"definition.dependent_clause\": cls.DEPENDENT_CLAUSE,\n            \"definition.error\": cls.ERROR,\n            \"definition.export\": cls.EXPORT,\n            \"definition.function\": cls.FUNCTION,\n            \"definition.import\": cls.IMPORT,\n            \"definition.module\": cls.MODULE,\n            \"definition.statement\": cls.STATEMENT,\n            \"definition.test_suite\": cls.TEST_SUITE,\n            \"definition.test_case\": cls.TEST_CASE,\n        }\n        return tag_to_block_type.get(tag)",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::4",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 303,
          "span_ids": [
            "PathTree.merge",
            "PathTree",
            "impl:3",
            "PathTree.child_tree",
            "PathTree.from_block_paths",
            "PathTree.extend_tree"
          ],
          "start_line": 102,
          "end_line": 147,
          "community": null
        },
        "content": "NON_CODE_BLOCKS = [\n    CodeBlockType.BLOCK_DELIMITER,\n    CodeBlockType.COMMENT,\n    CodeBlockType.COMMENTED_OUT_CODE,\n    CodeBlockType.EXPORT,\n    CodeBlockType.IMPORT,\n    CodeBlockType.ERROR,\n    CodeBlockType.SPACE,\n]\n\nINDEXED_BLOCKS = [\n    CodeBlockType.FUNCTION,\n    CodeBlockType.CLASS,\n    CodeBlockType.TEST_SUITE,\n    CodeBlockType.TEST_CASE,\n]\n\n\n@deprecated(\"Use BlockSpans to define code block visibility instead\")\nclass PathTree(BaseModel):\n    show: bool = Field(default=False, description=\"Show the block and all sub blocks.\")\n    tree: dict[str, \"PathTree\"] = Field(default_factory=dict)\n\n    @staticmethod\n    def from_block_paths(block_paths: list[BlockPath]) -> \"PathTree\":\n        tree = PathTree()\n        for block_path in block_paths:\n            tree.add_to_tree(block_path)\n\n        return tree\n\n    def child_tree(self, key: str) -> Optional[\"PathTree\"]:\n        return self.tree.get(key, None)\n\n    def merge(self, other: \"PathTree\"):\n        if other.show:\n            self.show = True\n\n        for key, value in other.tree.items():\n            if key not in self.tree:\n                self.tree[key] = PathTree()\n            self.tree[key].merge(value)\n\n    def extend_tree(self, paths: list[list[str]]):\n        for path in paths:\n            self.add_to_tree(path)",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::5",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 147,
          "span_ids": [
            "PathTree.add_to_tree"
          ],
          "start_line": 149,
          "end_line": 168,
          "community": null
        },
        "content": "@deprecated(\"Use BlockSpans to define code block visibility instead\")\nclass PathTree(BaseModel):\n\n    def add_to_tree(self, path: list[str]):\n        if path is None:\n            return\n\n        if len(path) == 0:\n            self.show = True\n            return\n\n        if len(path) == 1:\n            if path[0] not in self.tree:\n                self.tree[path[0]] = PathTree(show=True)\n            else:\n                self.tree[path[0]].show = True\n\n            return\n\n        if path[0] not in self.tree:\n            self.tree[path[0]] = PathTree(show=False)\n\n        self.tree[path[0]].add_to_tree(path[1:])",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::6",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 138,
          "span_ids": [
            "RelationshipType",
            "ReferenceScope"
          ],
          "start_line": 171,
          "end_line": 190,
          "community": null
        },
        "content": "class ReferenceScope(str, Enum):\n    EXTERNAL = \"external\"\n    DEPENDENCY = \"dependency\"  # External dependency\n    FILE = \"file\"  # File in repository\n    PROJECT = \"project\"\n    CLASS = \"class\"\n    LOCAL = \"local\"\n    GLOBAL = \"global\"\n\n\nclass RelationshipType(str, Enum):\n    UTILIZES = \"utilizes\"\n    USES = \"uses\"\n    DEFINED_BY = \"defined_by\"\n    IS_A = \"is_a\"\n    PROVIDES = \"provides\"\n    IMPORTS = \"imports\"\n    CALLS = \"calls\"\n    DEPENDENCY = \"dependency\"\n    TYPE = \"type\"",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::7",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 357,
          "span_ids": [
            "Relationship.full_path",
            "Relationship.__hash__",
            "Relationship.validate_path",
            "Relationship.__str__",
            "Relationship.__eq__",
            "Relationship"
          ],
          "start_line": 193,
          "end_line": 238,
          "community": null
        },
        "content": "class Relationship(BaseModel):\n    scope: ReferenceScope = Field(description=\"The scope of the reference.\")\n    identifier: Optional[str] = Field(default=None, description=\"ID\")\n    type: RelationshipType = Field(\n        default=RelationshipType.USES, description=\"The type of the reference.\"\n    )\n    external_path: list[str] = Field(\n        default=[], description=\"The path to the referenced parent code block.\"\n    )\n    resolved_path: list[str] = Field(\n        default=[], description=\"The path to the file with the referenced code block.\"\n    )\n    path: list[str] = Field(\n        default=[], description=\"The path to the referenced code block.\"\n    )\n\n    @classmethod\n    @model_validator(mode=\"before\")\n    def validate_path(cls, values):\n        external_path = values.get(\"external_path\")\n        path = values.get(\"path\")\n        if not external_path and not path:\n            raise ValueError(\"Cannot create Reference without external_path or path.\")\n        return values\n\n    def __hash__(self):\n        return hash((self.scope, tuple(self.path)))\n\n    def __eq__(self, other):\n        return (self.scope, self.path) == (other.scope, other.path)\n\n    def full_path(self):\n        return self.external_path + self.path\n\n    def __str__(self):\n        start_node = self.identifier if self.identifier else \"\"\n\n        end_node = \"\"\n        if self.external_path:\n            end_node = \"/\".join(self.external_path)\n        if self.path:\n            if self.external_path:\n                end_node += \"/\"\n            end_node += \".\".join(self.path)\n\n        return f\"({start_node})-[:{self.type.name} {{scope: {self.scope.value}}}]->({end_node})\"",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::8",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 384,
          "span_ids": [
            "BlockSpan.block_type",
            "BlockSpan:12",
            "BlockSpan.__str__",
            "ValidationError",
            "BlockSpan.get_first_child_block_path",
            "SpanType",
            "BlockSpan",
            "Parameter"
          ],
          "start_line": 241,
          "end_line": 300,
          "community": null
        },
        "content": "class Parameter(BaseModel):\n    identifier: str = Field(description=\"The identifier of the parameter.\")\n    type: Optional[str] = Field(description=\"The type of the parameter.\")\n\n\nclass SpanType(str, Enum):\n    INITATION = \"init\"\n    DOCUMENTATION = \"docs\"\n    IMPLEMENTATION = \"impl\"\n\n\nclass BlockSpan(BaseModel):\n    span_id: str = Field()\n    span_type: SpanType = Field(description=\"Type of span.\")\n    start_line: int = Field(description=\"Start line of the span.\")\n    end_line: int = Field(description=\"End line of the span.\")\n\n    initiating_block: \"CodeBlock\" = Field(\n        default=None,\n        description=\"The block that initiated the span.\",\n    )\n\n    @property\n    def block_type(self):\n        return self.initiating_block.type\n\n    # TODO: Remove\n    visible: bool = Field(default=True, description=\"If the span should be visible.\")\n\n    index: int = 0\n\n    parent_block_path: BlockPath = Field(\n        default=None,\n        description=\"Path to the parent block of the span.\",\n    )\n\n    is_partial: bool = Field(\n        default=False,\n        description=\"If the span is covering a partial part of the parent block.\",\n    )\n\n    block_paths: list[BlockPath] = Field(\n        default=[],\n        description=\"Block paths that should be shown when the span is shown.\",\n    )\n\n    tokens: int = Field(default=0, description=\"Number of tokens in the span.\")\n\n    def __str__(self):\n        return f\"{self.span_id} ({self.span_type.value}, {self.tokens} tokens)\"\n\n    def get_first_child_block_path(self):\n        for block_path in self.block_paths:\n            if len(block_path) == len(self.parent_block_path):\n                continue\n            return block_path\n\n\nclass ValidationError(BaseModel):\n    error: str",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::9",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 810,
          "span_ids": [
            "CodeBlock.__init__",
            "CodeBlock.insert_child",
            "CodeBlock",
            "CodeBlock.append_child",
            "CodeBlock.insert_children",
            "CodeBlock.last",
            "CodeBlock.replace_children",
            "CodeBlock.append_children",
            "CodeBlock.remove_child",
            "CodeBlock.validate_type",
            "CodeBlock.replace_child"
          ],
          "start_line": 303,
          "end_line": 402,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n    content: str\n    type: CodeBlockType\n    identifier: Optional[str] = None\n    parameters: list[Parameter] = []  # TODO: Move to Function sub class\n    relationships: list[Relationship] = []\n    span_ids: set[str] = set()\n    belongs_to_span: BlockSpan | None = None\n    content_lines: list[str] = []\n    start_line: int = 0\n    end_line: int = 0\n    properties: dict = {}\n    pre_code: str = \"\"\n    pre_lines: int = 0\n    indentation: str = \"\"\n    tokens: int = 0\n    children: list[\"CodeBlock\"] = []\n    validation_errors: list[ValidationError] = []\n    parent: Optional[\"CodeBlock\"] = None\n    previous: Optional[\"CodeBlock\"] = None\n    next: Optional[\"CodeBlock\"] = None\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    @classmethod\n    @field_validator(\"type\", mode=\"before\")\n    def validate_type(cls, v):\n        if v is None:\n            raise ValueError(\"Cannot create CodeBlock without type.\")\n        return v\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        for child in self.children:\n            child.parent = self\n\n        if self.pre_code and not re.match(r\"^[ \\n\\\\]*$\", self.pre_code):\n            raise ValueError(\n                f\"Failed to parse code block with type {self.type} and content `{self.content}`. \"\n                f\"Expected pre_code to only contain spaces and line breaks. Got `{self.pre_code}`\"\n            )\n\n        if self.pre_code and not self.indentation and not self.pre_lines:\n            pre_code_lines = self.pre_code.split(\"\\n\")\n            self.pre_lines = len(pre_code_lines) - 1\n            if self.pre_lines > 0:\n                self.indentation = pre_code_lines[-1]\n            else:\n                self.indentation = self.pre_code\n\n        self.content_lines = self.content.split(\"\\n\")\n        # if self.indentation and self.pre_lines:\n        #    self.content_lines[1:] = [line[len(self.indentation):] for line in self.content_lines[1:]]\n\n    def last(self):\n        if self.next:\n            return self.next.last()\n        return self\n\n    def insert_child(self, index: int, child: \"CodeBlock\"):\n        if index == 0 and self.children[0].pre_lines == 0:\n            self.children[0].pre_lines = 1\n\n        self.children.insert(index, child)\n        child.parent = self\n\n    def insert_children(self, index: int, children: list[\"CodeBlock\"]):\n        for child in children:\n            self.insert_child(index, child)\n            index += 1\n\n    def append_child(self, child: \"CodeBlock\"):\n        self.children.append(child)\n        self.span_ids.update(child.span_ids)\n        child.parent = self\n\n    def append_children(self, children: list[\"CodeBlock\"]):\n        for child in children:\n            self.append_child(child)\n\n    def replace_children(\n        self, start_index: int, end_index: int, children: list[\"CodeBlock\"]\n    ):\n        self.children = (\n            self.children[:start_index] + children + self.children[end_index:]\n        )\n        for child in children:\n            child.parent = self\n\n    def replace_child(self, index: int, child: \"CodeBlock\"):\n        # TODO: Do a proper update of everything when replacing child blocks\n        child.pre_code = self.children[index].pre_code\n        child.pre_lines = self.children[index].pre_lines\n        self.sync_indentation(self.children[index], child)\n\n        self.children[index] = child\n        child.parent = self\n\n    def remove_child(self, index: int):\n        del self.children[index]",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::10",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 174,
          "span_ids": [
            "CodeBlock.sync_indentation"
          ],
          "start_line": 404,
          "end_line": 423,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def sync_indentation(self, original_block: \"CodeBlock\", updated_block: \"CodeBlock\"):\n        original_indentation_length = len(original_block.indentation) + len(\n            self.indentation\n        )\n        updated_indentation_length = len(updated_block.indentation) + len(\n            updated_block.parent.indentation\n        )\n\n        # To handle separate code blocks provdided out of context\n        if (\n            original_indentation_length == updated_indentation_length\n            and len(updated_block.indentation) == 0\n        ):\n            updated_block.indentation = \" \" * original_indentation_length\n\n        elif original_indentation_length > updated_indentation_length:\n            additional_indentation = \" \" * (\n                original_indentation_length - updated_indentation_length\n            )\n            updated_block.add_indentation(additional_indentation)",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::10"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::11",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 367,
          "span_ids": [
            "CodeBlock.has_visible_children",
            "CodeBlock.show_related_spans",
            "CodeBlock.__str__",
            "CodeBlock.get_all_child_blocks",
            "CodeBlock.replace_by_path",
            "CodeBlock.get_children",
            "CodeBlock.to_string",
            "CodeBlock.is_visible",
            "CodeBlock.sum_tokens"
          ],
          "start_line": 425,
          "end_line": 482,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def replace_by_path(self, path: list[str], new_block: \"CodeBlock\"):\n        if not path:\n            return\n\n        for i, child in enumerate(self.children):\n            if child.identifier == path[0]:\n                if len(path) == 1:\n                    self.replace_child(i, new_block)\n                    return\n                else:\n                    child.replace_by_path(path[1:], new_block)\n\n    def __str__(self):\n        return self.to_string()\n\n    def to_string(self):\n        return self._to_string()\n\n    def sum_tokens(self):\n        tokens = self.tokens\n        tokens += sum([child.sum_tokens() for child in self.children])\n        return tokens\n\n    def get_all_child_blocks(self) -> list[\"CodeBlock\"]:\n        blocks = []\n        for child in self.children:\n            blocks.append(child)\n            blocks.extend(child.get_all_child_blocks())\n        return blocks\n\n    def get_children(\n        self, exclude_blocks: list[CodeBlockType] = None\n    ) -> list[\"CodeBlock\"]:\n        if exclude_blocks is None:\n            exclude_blocks = []\n        return [child for child in self.children if child.type not in exclude_blocks]\n\n    def show_related_spans(\n        self,\n        span_id: Optional[str] = None,  # TODO: Set max tokens to show\n    ):\n        related_spans = self.find_related_spans(span_id)\n        for span in related_spans:\n            span.visible = True\n\n    def has_visible_children(self):\n        for child in self.children:\n            if child.is_visible:\n                return True\n\n            if child.has_visible_children():\n                return True\n\n        return False\n\n    @property\n    def is_visible(self):\n        return self.belongs_to_span and self.belongs_to_span.visible",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::11"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::12",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 131,
          "span_ids": [
            "CodeBlock._to_string"
          ],
          "start_line": 484,
          "end_line": 502,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def _to_string(self) -> str:\n        contents = \"\"\n\n        if self.pre_lines:\n            contents += \"\\n\" * (self.pre_lines - 1)\n            for i, line in enumerate(self.content_lines):\n                if i == 0 and line:\n                    contents += \"\\n\" + self.indentation + line\n                elif line:\n                    contents += \"\\n\" + line\n                else:\n                    contents += \"\\n\"\n        else:\n            contents += self.pre_code + self.content\n\n        for _i, child in enumerate(self.children):\n            contents += child._to_string()\n\n        return contents",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::12"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::13",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 248,
          "span_ids": [
            "CodeBlock._build_path_tree"
          ],
          "start_line": 504,
          "end_line": 542,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def _build_path_tree(\n        self, block_paths: list[str], include_references: bool = False\n    ):\n        path_tree = PathTree()\n\n        for block_path in block_paths:\n            if block_path:\n                path = block_path.split(\".\")\n                if include_references:\n                    block = self.find_by_path(path)\n                    if block:\n                        if self.type == CodeBlockType.CLASS:\n                            references = [\n                                self._fix_reference_path(reference)\n                                for reference in self.get_all_relationships(\n                                    exclude_types=[\n                                        CodeBlockType.FUNCTION,\n                                        CodeBlockType.TEST_CASE,\n                                    ]\n                                )\n                                if reference\n                                and reference.scope != ReferenceScope.EXTERNAL\n                            ]  # FIXME skip _fix_reference_path?\n                        else:\n                            references = [\n                                self._fix_reference_path(reference)\n                                for reference in self.get_all_relationships()\n                                if reference\n                                and reference.scope != ReferenceScope.EXTERNAL\n                            ]  # FIXME skip _fix_reference_path?\n\n                        for ref in references:\n                            path_tree.add_to_tree(ref.path)\n\n                path_tree.add_to_tree(path)\n            elif block_path == \"\":\n                path_tree.show = True\n\n        return path_tree",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::13"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::14",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 822,
          "span_ids": [
            "CodeBlock.to_tree"
          ],
          "start_line": 544,
          "end_line": 653,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def to_tree(\n        self,\n        indent: int = 0,\n        current_span: BlockSpan | None = None,\n        highlight_spans: set[str] | None = None,\n        only_identifiers: bool = False,\n        show_full_path: bool = True,\n        show_tokens: bool = False,\n        show_spans: bool = False,\n        debug: bool = False,\n        exclude_not_highlighted: bool = False,\n        include_line_numbers: bool = False,\n        include_types: list[CodeBlockType] | None = None,\n        include_parameters: bool = False,\n        include_block_delimiters: bool = False,\n        include_references: bool = False,\n        include_merge_history: bool = False,\n    ):\n        if not include_merge_history and self.type == CodeBlockType.BLOCK_DELIMITER:\n            return \"\"\n\n        indent_str = \" \" * indent\n\n        highlighted = False\n\n        child_tree = \"\"\n        for _i, child in enumerate(self.children):\n            if child.belongs_to_span and (\n                not current_span\n                or current_span.span_id != child.belongs_to_span.span_id\n            ):\n                current_span = child.belongs_to_span\n\n                highlighted = highlight_spans is None or (\n                    current_span is not None and current_span.span_id in highlight_spans\n                )\n\n                if show_spans:\n                    color = Colors.WHITE if highlighted else Colors.GRAY\n                    child_tree += f\"{indent_str} {indent} {color}Span: {current_span}{Colors.RESET}\\n\"\n\n            if (\n                exclude_not_highlighted\n                and not highlighted\n                and not child.has_any_span(highlight_spans)\n            ):\n                continue\n\n            child_tree += child.to_tree(\n                indent=indent + 1,\n                current_span=current_span,\n                highlight_spans=highlight_spans,\n                exclude_not_highlighted=exclude_not_highlighted,\n                only_identifiers=only_identifiers,\n                show_full_path=show_full_path,\n                show_tokens=show_tokens,\n                debug=debug,\n                show_spans=show_spans,\n                include_line_numbers=include_line_numbers,\n                include_types=include_types,\n                include_parameters=include_parameters,\n                include_block_delimiters=include_block_delimiters,\n                include_references=include_references,\n                include_merge_history=include_merge_history,\n            )\n\n        is_visible = not highlight_spans or self.belongs_to_any_span(highlight_spans)\n        extra = \"\"\n        if show_tokens:\n            extra += f\" ({self.tokens} tokens)\"\n\n        if include_references and self.relationships:\n            extra += \" references: \" + \", \".join(\n                [str(ref) for ref in self.relationships]\n            )\n\n        content = (\n            Colors.YELLOW\n            if is_visible\n            else Colors.GRAY\n            + (self.content.strip().replace(\"\\n\", \"\\\\n\") or \"\")\n            + Colors.RESET\n        )\n\n        if self.identifier:\n            if only_identifiers:\n                content = \"\"\n            content += Colors.GREEN if is_visible else Colors.GRAY\n            if include_parameters and self.parameters:\n                content += f\"{self.identifier}({', '.join([param.identifier for param in self.parameters])})\"\n            elif show_full_path:\n                content += f\" ({self.path_string()})\"\n            else:\n                content += f\" ({self.identifier})\"\n\n            content += Colors.RESET\n\n        if include_line_numbers:\n            extra += f\" {self.start_line}-{self.end_line}\"\n\n        if debug and self.properties:\n            extra += f\" properties: {self.properties}\"\n\n        if include_merge_history and self.merge_history:\n            extra += \" merge_history: \" + \", \".join(\n                [str(action) for action in self.merge_history]\n            )\n\n        type_color = Colors.BLUE if is_visible else Colors.GRAY\n        return f\"{indent_str} {indent} {type_color}{self.type.value}{Colors.RESET} `{content}`{extra}{Colors.RESET}\\n{child_tree}\"",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::14"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::15",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 329,
          "span_ids": [
            "CodeBlock._to_prompt_string"
          ],
          "start_line": 655,
          "end_line": 697,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def _to_prompt_string(\n        self,\n        show_span_id: bool = False,\n        span_marker: SpanMarker = SpanMarker.COMMENT,\n        show_line_numbers: bool = False,\n    ) -> str:\n        contents = \"\"\n\n        if show_span_id:\n            contents += \"\\n\\n\"\n            if span_marker == SpanMarker.COMMENT:\n                span_comment = self.create_comment(\n                    f\"span_id: {self.belongs_to_span.span_id}\"\n                )\n                contents += f\"{self.indentation}{span_comment}\"\n            elif span_marker == SpanMarker.TAG:\n                contents += f\"\\n<span id='{self.belongs_to_span.span_id}'>\"\n\n            if not self.pre_lines:\n                contents += \"\\n\"\n\n        def print_line(line_number):\n            if not show_line_numbers:\n                return \"\"\n            return str(line_number).ljust(6)\n\n        # Just to write out the first line number when there are no pre_lines on first block\n        if self.parent.type == CodeBlockType.MODULE and self.parent.children[0] == self:\n            contents += print_line(self.start_line)\n\n        if self.pre_lines:\n            for i in range(self.pre_lines):\n                contents += \"\\n\"\n                contents += print_line(self.start_line - self.pre_lines + i + 1)\n\n        contents += self.indentation + self.content_lines[0]\n\n        for i, line in enumerate(self.content_lines[1:]):\n            contents += \"\\n\"\n            contents += print_line(self.start_line + i + 1)\n            contents += line\n\n        return contents",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::15"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::16",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 636,
          "span_ids": [
            "CodeBlock.to_prompt"
          ],
          "start_line": 699,
          "end_line": 788,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def to_prompt(\n        self,\n        span_ids: set[str] | None = None,\n        start_line: Optional[int] = None,\n        end_line: Optional[int] = None,\n        show_outcommented_code: bool = True,\n        outcomment_code_comment: str = \"...\",\n        show_span_id: bool = False,\n        current_span_id: Optional[str] = None,\n        show_line_numbers: bool = False,\n        exclude_block_types: list[CodeBlockType] | None = None,\n        include_block_types: list[CodeBlockType] | None = None,\n    ):\n        contents = \"\"\n\n        has_outcommented_code = False\n        for _i, child in enumerate(self.children):\n            show_child = True\n\n            if exclude_block_types and child.type in exclude_block_types:\n                show_child = False\n\n            if show_child and span_ids:\n                show_child = child.has_any_span(span_ids)\n\n            if show_child and include_block_types:\n                show_child = child.has_blocks_with_types(include_block_types)\n\n            if show_child and start_line and end_line:\n                show_child = child.has_lines(\n                    start_line, end_line\n                ) or child.is_within_lines(start_line, end_line)\n\n            if show_child:\n                if has_outcommented_code:\n                    contents += child.create_commented_out_block(\n                        outcomment_code_comment\n                    ).to_string()\n\n                has_outcommented_code = False\n\n                show_new_span_id = (\n                    show_span_id\n                    and child.belongs_to_span\n                    and (\n                        not current_span_id\n                        or current_span_id != child.belongs_to_span.span_id\n                    )\n                )\n                if child.belongs_to_span:\n                    current_span_id = child.belongs_to_span.span_id\n\n                contents += child._to_prompt_string(\n                    show_span_id=show_new_span_id, show_line_numbers=show_line_numbers\n                )\n                contents += child.to_prompt(\n                    span_ids=span_ids,\n                    start_line=start_line,\n                    end_line=end_line,\n                    show_outcommented_code=show_outcommented_code,\n                    outcomment_code_comment=outcomment_code_comment,\n                    show_span_id=show_span_id,\n                    current_span_id=current_span_id,\n                    show_line_numbers=show_line_numbers,\n                    exclude_block_types=exclude_block_types,\n                    include_block_types=include_block_types,\n                )\n            elif show_outcommented_code and child.type not in [\n                CodeBlockType.COMMENT,\n                CodeBlockType.COMMENTED_OUT_CODE,\n            ]:\n                has_outcommented_code = True\n\n        if (\n            outcomment_code_comment\n            and has_outcommented_code\n            and child.type\n            not in [\n                CodeBlockType.COMMENT,\n                CodeBlockType.COMMENTED_OUT_CODE,\n                CodeBlockType.SPACE,\n            ]\n        ):\n            contents += \"\\n.    \" if show_line_numbers else \"\\n\"\n            contents += child.create_commented_out_block(\n                outcomment_code_comment\n            ).to_string()\n            contents += \"\\n\"\n\n        return contents",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::16"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::17",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 282,
          "span_ids": [
            "CodeBlock.find_block_by_type",
            "CodeBlock.__eq__",
            "CodeBlock.structure_block",
            "CodeBlock.find_type_group_in_parents",
            "CodeBlock.find_type_in_parents"
          ],
          "start_line": 790,
          "end_line": 840,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def __eq__(self, other):\n        if not isinstance(other, CodeBlock):\n            return False\n\n        return self.full_path() == other.full_path()\n\n    def find_block_by_type(self, block_type: CodeBlockType) -> Optional[\"CodeBlock\"]:\n        if self.type == block_type:\n            return self\n\n        for child in self.children:\n            block = child.find_block_by_type(block_type)\n            if block:\n                return block\n\n        return None\n\n    def find_type_in_parents(self, block_type: CodeBlockType) -> Optional[\"CodeBlock\"]:\n        if not self.parent:\n            return None\n\n        if self.parent.type == block_type:\n            return self.parent\n\n        if self.parent:\n            return self.parent.find_type_in_parents(block_type)\n\n        return None\n\n    def structure_block(self):\n        if self.type.group == CodeBlockTypeGroup.STRUCTURE:\n            return self\n\n        if self.parent:\n            return self.parent.structure_block()\n\n        return None\n\n    def find_type_group_in_parents(\n        self, block_type_group: CodeBlockTypeGroup\n    ) -> Optional[\"CodeBlock\"]:\n        if not self.parent:\n            return None\n\n        if self.parent.type.group == block_type_group:\n            return self.parent\n\n        if self.parent:\n            return self.parent.find_type_group_in_parents(block_type_group)\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::17"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::18",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 209,
          "span_ids": [
            "CodeBlock.find_spans_by_line_numbers"
          ],
          "start_line": 842,
          "end_line": 874,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def find_spans_by_line_numbers(\n        self, start_line: int, end_line: int = None\n    ) -> list[BlockSpan]:\n        spans = []\n        for child in self.children:\n            if end_line is None:\n                end_line = start_line\n\n            if child.end_line < start_line:\n                continue\n\n            if child.start_line > end_line:\n                return spans\n\n            if (\n                child.belongs_to_span\n                and child.belongs_to_span.span_id not in spans\n                and (\n                    not child.children\n                    or child.start_line >= start_line\n                    and child.end_line <= end_line\n                    or child.start_line == start_line\n                    or child.end_line == end_line\n                )\n            ):\n                spans.append(child.belongs_to_span)\n\n            child_spans = child.find_spans_by_line_numbers(start_line, end_line)\n            for span in child_spans:\n                if span not in spans:\n                    spans.append(span)\n\n        return spans",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::18"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::19",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 245,
          "span_ids": [
            "CodeBlock.root",
            "CodeBlock.dict",
            "CodeBlock.module",
            "CodeBlock.full_path",
            "CodeBlock.path_string",
            "CodeBlock.get_blocks"
          ],
          "start_line": 876,
          "end_line": 916,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def dict(self, **kwargs):\n        # TODO: Add **kwargs to dict call\n        return super().dict(exclude={\"parent\", \"merge_history\"})\n\n    def path_string(self):\n        return \".\".join(self.full_path())\n\n    def full_path(self):\n        path = []\n        if self.parent:\n            path.extend(self.parent.full_path())\n\n        if self.identifier:\n            path.append(self.identifier)\n\n        return path\n\n    @property\n    def module(self) -> \"Module\":  # noqa: F821\n        if self.parent:\n            return self.parent.module\n        return self\n\n    @deprecated(\"Use codeblock.module\")\n    def root(self) -> \"Module\":  # noqa: F821\n        return self.module\n\n    def get_blocks(\n        self, has_identifier: bool, include_types: list[CodeBlockType] | None = None\n    ) -> list[\"CodeBlock\"]:\n        blocks = [self]\n\n        for child in self.children:\n            if has_identifier and not child.identifier:\n                continue\n\n            if include_types and child.type not in include_types:\n                continue\n\n            blocks.extend(child.get_indexable_blocks())\n        return blocks",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::19"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::20",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 194,
          "span_ids": [
            "CodeBlock.find_reference"
          ],
          "start_line": 918,
          "end_line": 943,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def find_reference(self, ref_path: [str]) -> Relationship | None:\n        for child in self.children:\n            if child.type == CodeBlockType.IMPORT:\n                for reference in child.relationships:\n                    if (\n                        reference.path[len(reference.path) - len(ref_path) :]\n                        == ref_path\n                    ):\n                        return reference\n\n            child_path = child.full_path()\n\n            if child_path[len(child_path) - len(ref_path) :] == ref_path:\n                if self.type == CodeBlockType.CLASS:\n                    return Relationship(scope=ReferenceScope.CLASS, path=child_path)\n                if self.type == CodeBlockType.MODULE:\n                    return Relationship(scope=ReferenceScope.GLOBAL, path=child_path)\n\n                return Relationship(scope=ReferenceScope.LOCAL, path=child_path)\n\n        if self.parent:\n            reference = self.parent.find_reference(ref_path)\n            if reference:\n                return reference\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::20"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::21",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 681,
          "span_ids": [
            "CodeBlock.find_errors",
            "CodeBlock.find_validation_errors",
            "CodeBlock.add_indentation",
            "CodeBlock.find_blocks_by_span_id",
            "CodeBlock.get_all_relationships",
            "CodeBlock.create_comment_block",
            "CodeBlock.create_comment",
            "CodeBlock.is_complete",
            "CodeBlock.find_by_path",
            "CodeBlock.create_commented_out_block"
          ],
          "start_line": 945,
          "end_line": 1049,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def get_all_relationships(\n        self, exclude_types: list[CodeBlockType] = None\n    ) -> list[Relationship]:\n        if exclude_types is None:\n            exclude_types = []\n        references = []\n        references.extend(self.relationships)\n        for childblock in self.children:\n            if not exclude_types or childblock.type not in exclude_types:\n                references.extend(\n                    childblock.get_all_relationships(exclude_types=exclude_types)\n                )\n\n        return references\n\n    def is_complete(self):\n        if self.type == CodeBlockType.COMMENTED_OUT_CODE:\n            return False\n        return all(child.is_complete() for child in self.children)\n\n    def find_errors(self) -> list[\"CodeBlock\"]:\n        errors = []\n\n        if self.children:\n            for child in self.children:\n                errors.extend(child.find_errors())\n\n        if self.type == CodeBlockType.ERROR:\n            errors.append(self)\n\n        return errors\n\n    def find_validation_errors(self) -> list[ValidationError]:\n        errors = []\n        errors.extend(self.validation_errors)\n\n        for child in self.children:\n            errors.extend(child.find_validation_errors())\n\n        return errors\n\n    def create_commented_out_block(self, comment_out_str: str = \"...\"):\n        return CodeBlock(\n            type=CodeBlockType.COMMENTED_OUT_CODE,\n            indentation=self.indentation,\n            parent=self,\n            pre_lines=1,\n            content=self.create_comment(comment_out_str),\n        )\n\n    def create_comment_block(self, comment: str = \"...\", pre_lines: int = 1):\n        return CodeBlock(\n            type=CodeBlockType.COMMENT,\n            indentation=self.indentation,\n            parent=self,\n            pre_lines=pre_lines,\n            content=self.create_comment(comment),\n        )\n\n    def create_comment(self, comment: str) -> str:\n        symbol = get_comment_symbol(\"python\")  # FIXME: Derive language from Module\n        return f\"{symbol} {comment}\"\n\n    def add_indentation(self, indentation: str):\n        if self.pre_lines:\n            self.indentation += indentation\n\n        # TODO: Find a more graceful way to solve multi line blocks\n        if \"\\n\" in self.content:\n            lines = self.content.split(\"\\n\")\n            content = lines[0]\n            for line in lines[1:]:\n                if line.startswith(\" \"):\n                    content += \"\\n\" + indentation + line\n            self.content = content\n\n        for child in self.children:\n            child.add_indentation(indentation)\n\n    def find_by_path(self, path: list[str]) -> Optional[\"CodeBlock\"]:\n        if path is None:\n            return None\n\n        if not path:\n            return self\n\n        for child in self.children:\n            if child.identifier == path[0]:\n                if len(path) == 1:\n                    return child\n                else:\n                    return child.find_by_path(path[1:])\n\n        return None\n\n    def find_blocks_by_span_id(self, span_id: str) -> list[\"CodeBlock\"]:\n        blocks = []\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            blocks.append(self)\n\n        for child in self.children:\n            # TODO: Optimize to just check relevant children (by mapping spans?\n            blocks.extend(child.find_blocks_by_span_id(span_id))\n\n        return blocks",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::21"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::22",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 150,
          "span_ids": [
            "CodeBlock.find_last_before_span"
          ],
          "start_line": 1051,
          "end_line": 1068,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def find_last_before_span(\n        self, span_id: str, last_before_span: Optional[\"CodeBlock\"] = None\n    ) -> Optional[\"CodeBlock\"]:\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            return last_before_span\n\n        for child in self.children:\n            if child.belongs_to_span and child.belongs_to_span.span_id == span_id:\n                return last_before_span\n\n            if child.belongs_to_span and child.belongs_to_span.span_id != span_id:\n                last_before_span = child\n\n            result = child.find_last_before_span(span_id, last_before_span)\n            if result:\n                return result\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::22"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::23",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 718,
          "span_ids": [
            "CodeBlock.has_any_block",
            "CodeBlock.find_blocks_with_types",
            "CodeBlock.find_by_identifier",
            "CodeBlock.has_blocks_with_types",
            "CodeBlock.find_first_by_span_id",
            "CodeBlock.find_incomplete_blocks_with_types",
            "CodeBlock.find_incomplete_blocks_with_type",
            "CodeBlock.find_blocks_with_type",
            "CodeBlock.find_first_by_start_line",
            "CodeBlock.find_last_by_span_id",
            "CodeBlock.find_blocks_with_identifier"
          ],
          "start_line": 1070,
          "end_line": 1174,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def find_first_by_span_id(self, span_id: str) -> Optional[\"CodeBlock\"]:\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            return self\n\n        for child in self.children:\n            found = child.find_first_by_span_id(span_id)\n            if found:\n                return found\n\n        return None\n\n    def find_last_by_span_id(self, span_id: str) -> Optional[\"CodeBlock\"]:\n        for child in reversed(self.children):\n            if child.belongs_to_span and child.belongs_to_span.span_id == span_id:\n                return child\n\n            found = child.find_last_by_span_id(span_id)\n            if found:\n                return found\n\n        return None\n\n    def has_any_block(self, blocks: list[\"CodeBlock\"]) -> bool:\n        for block in blocks:\n            if block.full_path()[: len(self.full_path())] == self.full_path():\n                return True\n        return False\n\n    def find_by_identifier(\n        self,\n        identifier: str,\n        type: CodeBlockType | None = None,\n        recursive: bool = False,\n    ):\n        for child in self.children:\n            if child.identifier == identifier and (not type or child.type == type):\n                return child\n\n            if recursive:\n                found = child.find_by_identifier(identifier, type, recursive)\n                if found:\n                    return found\n        return None\n\n    def find_blocks_with_identifier(self, identifier: str) -> list[\"CodeBlock\"]:\n        blocks = []\n        for child_block in self.children:\n            if child_block.identifier == identifier:\n                blocks.append(child_block)\n            blocks.extend(child_block.find_blocks_with_identifier(identifier))\n        return blocks\n\n    def find_incomplete_blocks_with_type(self, block_type: CodeBlockType):\n        return self.find_incomplete_blocks_with_types([block_type])\n\n    def find_incomplete_blocks_with_types(self, block_types: [CodeBlockType]):\n        matching_blocks = []\n        for child_block in self.children:\n            if child_block.type in block_types and not child_block.is_complete():\n                matching_blocks.append(child_block)\n\n            if child_block.children:\n                matching_blocks.extend(\n                    child_block.find_incomplete_blocks_with_types(block_types)\n                )\n\n        return matching_blocks\n\n    def find_blocks_with_types(\n        self, block_types: list[CodeBlockType]\n    ) -> list[\"CodeBlock\"]:\n        matching_blocks = []\n        if self.type in block_types:\n            matching_blocks.append(self)\n        for child_block in self.children:\n            matching_blocks.extend(\n                child_block.find_blocks_with_types(block_types=block_types)\n            )\n        return matching_blocks\n\n    def has_blocks_with_types(self, block_types: list[CodeBlockType]) -> bool:\n        if self.type in block_types:\n            return True\n        for child_block in self.children:\n            if child_block.has_blocks_with_types(block_types):\n                return True\n        return False\n\n    def find_blocks_with_type(self, block_type: CodeBlockType) -> list[\"CodeBlock\"]:\n        return self.find_blocks_with_types([block_type])\n\n    def find_first_by_start_line(self, start_line: int) -> Optional[\"CodeBlock\"]:\n        for child in self.children:\n            if child.start_line >= start_line:\n                return child\n\n            if child.end_line >= start_line:\n                if not child.children:\n                    return child\n\n                found = child.find_first_by_start_line(start_line)\n                if found:\n                    return found\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::23"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::24",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 125,
          "span_ids": [
            "CodeBlock.find_last_by_end_line"
          ],
          "start_line": 1176,
          "end_line": 1194,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def find_last_by_end_line(\n        self, end_line: int, tokens: Optional[int] = None\n    ) -> Optional[\"CodeBlock\"]:\n        last_child = None\n        for child in self.children:\n            if child.start_line > end_line or (tokens and child.tokens > tokens):\n                return last_child\n\n            if tokens:\n                tokens -= child.tokens\n\n            last_child = child\n\n            if child.end_line > end_line:\n                found = child.find_last_by_end_line(end_line, tokens=tokens)\n                if found:\n                    return found\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::24"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::25",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 150,
          "span_ids": [
            "CodeBlock.find_indexed_blocks",
            "CodeBlock.find_closest_indexed_parent",
            "CodeBlock.get_indexed_blocks"
          ],
          "start_line": 1196,
          "end_line": 1221,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def find_closest_indexed_parent(self) -> Optional[\"CodeBlock\"]:\n        if self.is_indexed:\n            return self\n\n        if self.parent:\n            return self.parent.find_closest_indexed_parent()\n\n        return None\n\n    def find_indexed_blocks(self):\n        indexed_blocks = []\n        for child in self.children:\n            if child.is_indexed:\n                indexed_blocks.append(child)\n            indexed_blocks.extend(child.find_indexed_blocks())\n        return indexed_blocks\n\n    def get_indexed_blocks(self) -> list[\"CodeBlock\"]:\n        blocks = []\n        for child in self.children:\n            if child.is_indexed:\n                blocks.append(child)\n\n            blocks.extend(child.get_indexed_blocks())\n\n        return blocks",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::25"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::26",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 194,
          "span_ids": [
            "CodeBlock.line_witin_token_context",
            "CodeBlock.tokens_from_line"
          ],
          "start_line": 1223,
          "end_line": 1250,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def line_witin_token_context(self, line_number: int, tokens: int) -> bool:\n        if tokens <= 0:\n            return False\n\n        if self.end_line < line_number:\n            if not self.next:\n                return False\n            if self.next.start_line > line_number:\n                return True\n            else:\n                return self.next.line_witin_token_context(\n                    line_number, tokens - self.tokens\n                )\n        else:\n            if not self.previous:\n                return False\n            elif self.previous.end_line < line_number:\n                return True\n            else:\n                return self.previous.line_witin_token_context(\n                    line_number, tokens - self.tokens\n                )\n\n    def tokens_from_line(self, line_number: int) -> Optional[int]:\n        if not self.previous or self.previous.end_line < line_number:\n            return self.tokens\n\n        return self.tokens + self.previous.tokens_from_line(line_number)",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::26"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::27",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 150,
          "span_ids": [
            "CodeBlock.last_block_until_line"
          ],
          "start_line": 1252,
          "end_line": 1274,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def last_block_until_line(self, line_number: int, tokens: int) -> \"CodeBlock\":\n        if self.end_line < line_number:\n            if (\n                not self.next\n                or self.next.start_line > line_number\n                or self.next.tokens > tokens\n            ):\n                return self\n            else:\n                return self.next.last_block_until_line(\n                    line_number, tokens - self.tokens\n                )\n        else:\n            if (\n                not self.previous\n                or self.previous.end_line < line_number\n                or self.next.tokens > tokens\n            ):\n                return self\n            else:\n                return self.previous.last_block_until_line(\n                    line_number, tokens - self.tokens\n                )",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::27"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/codeblocks.py::28",
        "metadata": {
          "file_path": "moatless\\codeblocks\\codeblocks.py",
          "file_name": "codeblocks.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 360,
          "span_ids": [
            "CodeBlock.has_lines",
            "CodeBlock.has_any_span",
            "CodeBlock.has_span",
            "CodeBlock.is_within_lines",
            "CodeBlock.has_content",
            "CodeBlock.belongs_to_any_span",
            "CodeBlock.get_all_span_ids"
          ],
          "start_line": 1276,
          "end_line": 1319,
          "community": null
        },
        "content": "class CodeBlock(BaseModel):\n\n    def get_all_span_ids(self, include_self: bool = True) -> set[str]:\n        span_ids = set()\n\n        if include_self and self.belongs_to_span:\n            span_ids.add(self.belongs_to_span.span_id)\n\n        for child in self.children:\n            span_ids.update(child.get_all_span_ids())\n\n        return span_ids\n\n    def has_span(self, span_id: str):\n        return self.has_any_span({span_id})\n\n    def has_any_span(self, span_ids: set[str]):\n        all_span_ids = self.get_all_span_ids(include_self=False)\n        return any([span_id in all_span_ids for span_id in span_ids])\n\n    def belongs_to_any_span(self, span_ids: set[str]):\n        return self.belongs_to_span and self.belongs_to_span.span_id in span_ids\n\n    def has_lines(self, start_line: int, end_line: int):\n        # Returns True if any part of the block is within the provided line range\n        return not (self.end_line < start_line or self.start_line > end_line)\n\n    def is_within_lines(self, start_line: int, end_line: int):\n        return self.start_line >= start_line and self.end_line <= end_line\n\n    def has_content(self, query: str, span_id: Optional[str] = None):\n        if (\n            self.content\n            and query in self.content\n            and (\n                not span_id\n                or (self.belongs_to_span and self.belongs_to_span.span_id == span_id)\n            )\n        ):\n            return True\n\n        if span_id and not self.has_span(span_id):\n            return False\n\n        return any(child.has_content(query, span_id) for child in self.children)",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/codeblocks.py::28"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/module.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\module.py",
          "file_name": "module.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 286,
          "span_ids": [
            "Module.sum_tokens",
            "Module.__init__",
            "imports",
            "Module.find_span_by_id",
            "Module"
          ],
          "start_line": 1,
          "end_line": 43,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nfrom networkx import DiGraph\nfrom pydantic import (\n    ConfigDict,\n)\n\nfrom moatless.codeblocks import CodeBlock, CodeBlockType\nfrom moatless.codeblocks.codeblocks import BlockSpan, SpanType\n\nlogger = logging.getLogger(__name__)\n\n\nclass Module(CodeBlock):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    file_path: Optional[str] = None\n    content: str = None\n    spans_by_id: dict[str, BlockSpan] = {}\n    language: Optional[str] = None\n    parent: CodeBlock | None = None\n\n    _graph: DiGraph = None  # TODO: Move to central CodeGraph\n\n    def __init__(self, **data):\n        data.setdefault(\"type\", CodeBlockType.MODULE)\n        super().__init__(**data)\n\n    def find_span_by_id(self, span_id: str) -> BlockSpan | None:\n        return self.spans_by_id.get(span_id)\n\n    def sum_tokens(self, span_ids: set[str] | None = None):\n        tokens = self.tokens\n        if span_ids:\n            for span_id in span_ids:\n                span = self.spans_by_id.get(span_id)\n                if span:\n                    tokens += span.tokens\n            return tokens\n\n        tokens += sum([child.sum_tokens() for child in self.children])\n        return tokens",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/module.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/module.py::2",
        "metadata": {
          "file_path": "moatless\\codeblocks\\module.py",
          "file_name": "module.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 400,
          "span_ids": [
            "Module.show_spans"
          ],
          "start_line": 45,
          "end_line": 103,
          "community": null
        },
        "content": "class Module(CodeBlock):\n\n    def show_spans(\n        self,\n        span_ids: list[str] | None = None,\n        show_related: bool = False,\n        max_tokens: int = 2000,\n    ) -> bool:\n        for span in self.spans_by_id.values():\n            span.visible = False\n\n        checked_span_ids = set()\n        span_ids_to_check = []\n\n        tokens = 0\n        for span_id in span_ids:\n            span = self.spans_by_id.get(span_id)\n            if not span:\n                return False\n\n            tokens += span.tokens\n            checked_span_ids.add(span_id)\n            span_ids_to_check.append(span_id)\n            span.visible = True\n\n        if not show_related:\n            return True\n\n        # Add imports from module\n        for span in self.spans.values():\n            if (\n                span.span_type == SpanType.INITATION\n                and span.span_id not in checked_span_ids\n            ):\n                span_ids_to_check.append(span.span_id)\n\n        while span_ids_to_check:\n            span_id = span_ids_to_check.pop(0)\n            related_spans = self.find_related_spans(span_id)\n\n            logger.info(f\"Related spans: {len(related_spans)} for {span_id}\")\n\n            # TODO: Go through priotiized related spans to make sure that the most relevant are added first\n            # TODO: Verify span token size\n            for span in related_spans:\n                if span.tokens + tokens > max_tokens:\n                    logger.info(\n                        f\"Max tokens reached: {span.tokens} + {tokens} > {max_tokens}\"\n                    )\n                    return True\n\n                span.visible = True\n                tokens += span.tokens\n\n                if span.span_id not in checked_span_ids:\n                    checked_span_ids.add(span.span_id)\n                    span_ids_to_check.append(span.span_id)\n\n        logger.info(f\"Max tokens reached {tokens} < {max_tokens}\")\n\n        return True",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/module.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "codeblocks/module.py::3",
        "metadata": {
          "file_path": "moatless\\codeblocks\\module.py",
          "file_name": "module.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 328,
          "span_ids": [
            "Module.find_related_span_ids"
          ],
          "start_line": 105,
          "end_line": 142,
          "community": null
        },
        "content": "class Module(CodeBlock):\n\n    def find_related_span_ids(self, span_id: Optional[str] = None) -> set[str]:\n        related_span_ids = set()\n\n        blocks = self.find_blocks_by_span_id(span_id)\n        for block in blocks:\n            # Find successors (outgoing relationships)\n            successors = list(self._graph.successors(block.path_string()))\n            for succ in successors:\n                node_data = self._graph.nodes[succ]\n                if \"block\" in node_data:\n                    span = node_data[\"block\"].belongs_to_span\n                    related_span_ids.add(span.span_id)\n\n            # Find predecessors (incoming relationships)\n            predecessors = list(self._graph.predecessors(block.path_string()))\n            for pred in predecessors:\n                node_data = self._graph.nodes[pred]\n                if \"block\" in node_data:\n                    span = node_data[\"block\"].belongs_to_span\n                    related_span_ids.add(span.span_id)\n\n            # Always add parent class initation span\n            if block.parent and block.parent.type == CodeBlockType.CLASS:\n                related_span_ids.add(block.belongs_to_span.span_id)\n                for class_child in block.parent.children:\n                    if class_child.belongs_to_span.span_type == SpanType.INITATION:\n                        related_span_ids.add(class_child.belongs_to_span.span_id)\n\n        # Always add module initation span\n        for span in self.spans_by_id.values():\n            if (\n                span.block_type == CodeBlockType.MODULE\n                and span.span_type == SpanType.INITATION\n            ):\n                related_span_ids.add(span.span_id)\n\n        return related_span_ids",
        "summary": null,
        "ctxt_list": [],
        "id": "codeblocks/module.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/comment.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\comment.py",
          "file_name": "comment.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 533,
          "span_ids": [
            "get_comment_symbol",
            "impl"
          ],
          "start_line": 1,
          "end_line": 79,
          "community": null
        },
        "content": "comment_symbols = {\n    \"ada\": \"--\",\n    \"agda\": \"--\",\n    \"apex\": \"//\",\n    \"bash\": \"#\",\n    \"beancount\": \";\",\n    \"cap\u2019n proto\": \"#\",\n    \"c\": \"//\",\n    \"c++\": \"//\",\n    \"c#\": \"//\",\n    \"clojure\": \";\",\n    \"cmake\": \"#\",\n    \"common lisp\": \";\",\n    \"css\": \"/* \",  # TDOO ... */\n    \"cuda\": \"//\",\n    \"dart\": \"//\",\n    \"d\": \"//\",\n    \"dockerfile\": \"#\",\n    \"dot\": \"//\",\n    \"elixir\": \"#\",\n    \"elm\": \"--\",\n    \"emacs lisp\": \";\",\n    \"erb / ejs\": \"<%# ... %>\",\n    \"erlang\": \"%\",\n    \"fish\": \"#\",\n    \"fortran\": \"!\",\n    \"gitattributes\": \"#\",\n    \"gitignore\": \"#\",\n    \"gleam\": \"//\",\n    \"go\": \"//\",\n    \"graphql\": \"#\",\n    \"haskell\": \"--\",\n    \"html\": \"<!--\",  # TODO:  ... -->\n    \"java\": \"//\",\n    \"javascript\": \"//\",\n    \"json5\": \"//\",\n    \"julia\": \"#\",\n    \"kotlin\": \"//\",\n    \"latex\": \"%\",\n    \"lua\": \"--\",\n    \"make\": \"#\",\n    \"motorola 68000 assembly\": \";\",\n    \"nix\": \"#\",\n    \"objective-c\": \"//\",\n    \"ocaml\": \"(*\",  # TODO ... *)\n    \"pascal\": \"{\",  # TODO ... }\n    \"perl\": \"#\",\n    \"php\": \"//\",\n    \"powershell\": \"#\",\n    \"protocol buffers\": \"//\",\n    \"python\": \"#\",\n    \"racket\": \";\",\n    \"rego\": \"#\",\n    \"restructuredtext\": \"..\",\n    \"r\": \"#\",\n    \"ruby\": \"#\",\n    \"rust\": \"//\",\n    \"scala\": \"//\",\n    \"scheme\": \";\",\n    \"scss\": \"//\",\n    \"s-expressions\": \";\",\n    \"sql\": \"--\",\n    \"swift\": \"//\",\n    \"toml\": \"#\",\n    \"typescript\": \"//\",\n    \"tsx\": \"//\",\n    \"verilog\": \"//\",\n    \"vhdl\": \"--\",\n    \"vue\": \"<!-- \",  # TODO ... -->\n    \"yaml\": \"#\",\n    \"zig\": \"//\",\n}\n\n\ndef get_comment_symbol(language):\n    if language:\n        return comment_symbols.get(language.lower(), None)\n    return \"#\"",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/comment.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/create.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\create.py",
          "file_name": "create.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 176,
          "span_ids": [
            "imports",
            "is_supported",
            "create_parser_by_ext",
            "create_parser"
          ],
          "start_line": 1,
          "end_line": 26,
          "community": null
        },
        "content": "from moatless.codeblocks.parser.parser import CodeParser\nfrom moatless.codeblocks.parser.python import PythonParser\nfrom moatless.codeblocks.parser.java import JavaParser\n\n\ndef is_supported(language: str) -> bool:\n    return language and language in [\"python\", \"java\"]\n\n\ndef create_parser_by_ext(ext: str, **kwargs) -> CodeParser | None:\n    if ext == \".py\":\n        return PythonParser(**kwargs)\n    elif ext == \".java\":\n        return JavaParser(**kwargs)\n\n    raise NotImplementedError(f\"Extension {ext} is not supported.\")\n\n\ndef create_parser(language: str, **kwargs) -> CodeParser | None:\n    if language == \"python\":\n        return PythonParser(**kwargs)\n    elif language == \"java\":\n        return JavaParser(**kwargs)\n\n    raise NotImplementedError(f\"Language {language} is not supported.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/create.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/java.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\java.py",
          "file_name": "java.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 82,
          "span_ids": [
            "imports",
            "JavaParser",
            "JavaParser.__init__"
          ],
          "start_line": 1,
          "end_line": 13,
          "community": null
        },
        "content": "import tree_sitter_java as java\nfrom tree_sitter import Language\n\nfrom moatless.codeblocks.parser.parser import CodeParser\n\n\nclass JavaParser(CodeParser):\n    def __init__(self, **kwargs):\n        super().__init__(Language(java.language()), **kwargs)\n        self.queries = []\n        self.queries.extend(self._build_queries(\"java.scm\"))\n        self.gpt_queries = []",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/java.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 420,
          "span_ids": [
            "_find_type",
            "find_nested_type",
            "find_type",
            "NodeMatch",
            "imports"
          ],
          "start_line": 1,
          "end_line": 68,
          "community": null
        },
        "content": "import logging\nimport re\nfrom collections.abc import Callable\nfrom dataclasses import dataclass, field\nfrom importlib import resources\nfrom typing import Optional\n\nimport networkx as nx\nfrom llama_index.core import get_tokenizer\nfrom tree_sitter import Language, Node, Parser\n\nfrom moatless.codeblocks.codeblocks import (\n    BlockSpan,\n    CodeBlock,\n    CodeBlockType,\n    CodeBlockTypeGroup,\n    Parameter,\n    ReferenceScope,\n    Relationship,\n    RelationshipType,\n    SpanType,\n)\nfrom moatless.codeblocks.module import Module\nfrom moatless.codeblocks.parser.comment import get_comment_symbol\n\ncommented_out_keywords = [\"rest of the code\", \"existing code\", \"other code\"]\nchild_block_types = [\"ERROR\", \"block\"]\nmodule_types = [\"program\", \"module\"]\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass NodeMatch:\n    block_type: CodeBlockType = None\n    identifier_node: Node = None\n    first_child: Node = None\n    last_child: Node = None\n    check_child: Node = None\n    parameters: list[tuple[Node, Node | None]] = field(default_factory=list)\n    relationships: list[tuple[Node, str]] = field(default_factory=list)\n    query: str = None\n\n\ndef _find_type(node: Node, type: str):\n    for i, child in enumerate(node.children):\n        if child.type == type:\n            return i, child\n    return None, None\n\n\ndef find_type(node: Node, types: list[str]):\n    for child in node.children:\n        if child.type in types:\n            return child\n    return None\n\n\ndef find_nested_type(node: Node, type: str, levels: int = -1):\n    if levels == 0:\n        return None\n    if node.type == type:\n        return node\n    for child in node.children:\n        found_node = find_nested_type(child, type, levels - 1)\n        if found_node:\n            return found_node\n    return None",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::2",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 363,
          "span_ids": [
            "CodeParser.language",
            "CodeParser",
            "CodeParser._extract_node_type",
            "CodeParser.__init__"
          ],
          "start_line": 71,
          "end_line": 120,
          "community": null
        },
        "content": "class CodeParser:\n    def __init__(\n        self,\n        language: Language,\n        encoding: str = \"utf8\",\n        max_tokens_in_span: int = 500,\n        min_tokens_for_docs_span: int = 100,\n        index_callback: Callable[[CodeBlock], None] | None = None,\n        tokenizer: Callable[[str], list] | None = None,\n        apply_gpt_tweaks: bool = False,\n        debug: bool = False,\n    ):\n        try:\n            self.tree_parser = Parser()\n            self.tree_parser.language = language\n            self.tree_language = language\n        except Exception as e:\n            logger.warning(f\"Could not get parser for language {language}.\")\n            raise e\n        self.apply_gpt_tweaks = apply_gpt_tweaks\n        self.index_callback = index_callback\n        self.debug = debug\n        self.encoding = encoding\n        self.gpt_queries = []\n        self.queries = []\n\n        # TODO: How to handle these in a thread safe way?\n        self.spans_by_id = {}\n        self.comments_with_no_span = []\n        self._span_counter = {}\n        self._previous_block = None\n\n        # TODO: Move this to CodeGraph\n        self._graph = None\n\n        self.tokenizer = tokenizer or get_tokenizer()\n        self._max_tokens_in_span = max_tokens_in_span\n        self._min_tokens_for_docs_span = min_tokens_for_docs_span\n\n    @property\n    def language(self):\n        pass\n\n    def _extract_node_type(self, query: str):\n        pattern = r\"\\(\\s*(\\w+)\"\n        match = re.search(pattern, query)\n        if match:\n            return match.group(1)\n        else:\n            return None",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::3",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 154,
          "span_ids": [
            "CodeParser._build_queries"
          ],
          "start_line": 122,
          "end_line": 143,
          "community": null
        },
        "content": "class CodeParser:\n\n    def _build_queries(self, query_file: str):\n        with (\n            resources.files(\"moatless.codeblocks.parser.queries\")\n            .joinpath(query_file)\n            .open() as file\n        ):\n            query_list = file.read().strip().split(\"\\n\\n\")\n            parsed_queries = []\n            for i, query in enumerate(query_list):\n                try:\n                    node_type = self._extract_node_type(query)\n                    parsed_queries.append(\n                        (\n                            f\"{query_file}:{i+1}\",\n                            node_type,\n                            self.tree_language.query(query),\n                        )\n                    )\n                except Exception as e:\n                    logging.error(f\"Could not parse query {query}:{i+1}\")\n                    raise e\n            return parsed_queries",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::4",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 308,
          "span_ids": [
            "CodeParser.parse_code"
          ],
          "start_line": 145,
          "end_line": 183,
          "community": null
        },
        "content": "class CodeParser:\n\n    def parse_code(\n        self,\n        content_bytes: bytes,\n        node: Node,\n        start_byte: int = 0,\n        level: int = 0,\n        file_path: Optional[str] = None,\n        parent_block: CodeBlock | None = None,\n        current_span: BlockSpan | None = None,\n    ) -> tuple[CodeBlock, Node, BlockSpan]:\n        if node.type == \"ERROR\" or any(\n            child.type == \"ERROR\" for child in node.children\n        ):\n            node_match = NodeMatch(block_type=CodeBlockType.ERROR)\n            self.debug_log(f\"Found error node {node.type}\")\n        else:\n            node_match = self.find_in_tree(node)\n\n        pre_code = content_bytes[start_byte : node.start_byte].decode(self.encoding)\n        end_line = node.end_point[0]\n\n        if node_match.first_child:\n            end_byte = self.get_previous(node_match.first_child, node)\n        else:\n            end_byte = node.end_byte\n\n        code = content_bytes[node.start_byte : end_byte].decode(self.encoding)\n\n        if node_match.identifier_node:\n            identifier = content_bytes[\n                node_match.identifier_node.start_byte : node_match.identifier_node.end_byte\n            ].decode(self.encoding)\n        else:\n            identifier = None\n\n        relationships = self.create_references(\n            code, content_bytes, identifier, node_match\n        )\n        parameters = self.create_parameters(content_bytes, node_match, relationships)\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::5",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 812,
          "span_ids": [
            "CodeParser.parse_code"
          ],
          "start_line": 185,
          "end_line": 291,
          "community": null
        },
        "content": "class CodeParser:\n\n    def parse_code(\n        self,\n        content_bytes: bytes,\n        node: Node,\n        start_byte: int = 0,\n        level: int = 0,\n        file_path: Optional[str] = None,\n        parent_block: CodeBlock | None = None,\n        current_span: BlockSpan | None = None,\n    ) -> tuple[CodeBlock, Node, BlockSpan]:\n        # ... other code\n\n        if parent_block:\n            code_block = CodeBlock(\n                type=node_match.block_type,\n                identifier=identifier,\n                parent=parent_block,\n                previous=self._previous_block,\n                parameters=parameters,\n                relationships=relationships,\n                span_ids=set(),\n                start_line=node.start_point[0] + 1,\n                end_line=end_line + 1,\n                pre_code=pre_code,\n                content=code,\n                language=self.language,\n                tokens=self._count_tokens(code),\n                children=[],\n                properties={\n                    \"query\": node_match.query,\n                    \"tree_sitter_type\": node.type,\n                },\n            )\n\n            self._previous_block.next = code_block\n            self._previous_block = code_block\n\n            self.pre_process(code_block, node_match)\n\n            if code_block.identifier:\n                identifier = code_block.identifier\n            else:\n                if code_block.content:\n                    identifier = code_block.content.split(\"\\n\")[0].strip()[0:25]\n                    identifier = re.sub(r\"\\W+\", \"_\", identifier)\n                else:\n                    identifier = code_block.type.value.lower()\n\n            # Set a unique identifier on each code block\n            # TODO: Just count occurrences of the identifier\n            existing_identifiers = [\n                b.identifier for b in parent_block.children if b.type == code_block.type\n            ]\n            if identifier in existing_identifiers:\n                code_block.identifier = (\n                    f\"{code_block.identifier}_{len(existing_identifiers)}\"\n                )\n            else:\n                code_block.identifier = identifier\n\n            if (\n                code_block.type == CodeBlockType.COMMENT\n                and current_span\n                and current_span.span_type != SpanType.DOCUMENTATION\n                and len(current_span.block_paths) > 1\n            ):\n                # TODO: Find a more robust way to connect comments to the right span\n                self.comments_with_no_span.append(code_block)\n            else:\n                new_span = self._create_new_span(\n                    current_span=current_span, block=code_block\n                )\n                if new_span:\n                    current_span = new_span\n                    self.spans_by_id[current_span.span_id] = current_span\n                    code_block.span_ids.add(current_span.span_id)\n                else:\n                    current_span.end_line = code_block.end_line\n\n                for comment_block in self.comments_with_no_span:\n                    comment_block.belongs_to_span = current_span\n                    current_span.block_paths.append(comment_block.full_path())\n                    current_span.tokens += comment_block.tokens\n\n                current_span.block_paths.append(code_block.full_path())\n                current_span.tokens += code_block.tokens\n\n                code_block.belongs_to_span = current_span\n                code_block.span_ids.add(current_span.span_id)\n\n                self.comments_with_no_span = []\n\n            self._graph.add_node(code_block.path_string(), block=code_block)\n\n            for relationship in relationships:\n                self._graph.add_edge(\n                    code_block.path_string(), \".\".join(relationship.path)\n                )\n\n        else:\n            current_span = None\n            code_block = Module(\n                type=CodeBlockType.MODULE,\n                identifier=None,\n                file_path=file_path,\n                content=\"\",\n                spans_by_id={},\n                start_line=node.start_point[0] + 1,\n                end_line=end_line + 1,\n                language=self.language,\n                children=[],\n                properties={\n                    \"query\": node_match.query,\n                    \"tree_sitter_type\": node.type,\n                },\n            )\n            self._previous_block = code_block\n\n        next_node = node_match.first_child\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::6",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 754,
          "span_ids": [
            "CodeParser.parse_code"
          ],
          "start_line": 293,
          "end_line": 385,
          "community": null
        },
        "content": "class CodeParser:\n\n    def parse_code(\n        self,\n        content_bytes: bytes,\n        node: Node,\n        start_byte: int = 0,\n        level: int = 0,\n        file_path: Optional[str] = None,\n        parent_block: CodeBlock | None = None,\n        current_span: BlockSpan | None = None,\n    ) -> tuple[CodeBlock, Node, BlockSpan]:\n        # ... other code\n\n        self.debug_log(\n            f\"\"\"Created code block\n    content: {code_block.content[:50]} \n    block_type: {code_block.type} \n    node_type: {node.type}\n    next_node: {next_node.type if next_node else \"none\"}\n    first_child: {node_match.first_child}\n    last_child: {node_match.last_child}\n    start_byte: {start_byte}\n    node.start_byte: {node.start_byte}\n    node.end_byte: {node.end_byte}\"\"\"\n        )\n\n        index = 0\n\n        while next_node:\n            if (\n                next_node.children and next_node.type == \"block\"\n            ):  # TODO: This should be handled in get_block_definition\n                next_node = next_node.children[0]\n\n            self.debug_log(\n                f\"next  [{level}]: -> {next_node.type} - {next_node.start_byte}\"\n            )\n\n            child_block, child_last_node, child_span = self.parse_code(\n                content_bytes,\n                next_node,\n                start_byte=end_byte,\n                level=level + 1,\n                parent_block=code_block,\n                current_span=current_span,\n            )\n\n            if not current_span or child_span.span_id != current_span.span_id:\n                current_span = child_span\n\n            code_block.append_child(child_block)\n\n            index += 1\n\n            if child_last_node:\n                self.debug_log(f\"next  [{level}]: child_last_node -> {child_last_node}\")\n                next_node = child_last_node\n\n            end_byte = next_node.end_byte\n\n            self.debug_log(\n                f\"\"\"next  [{level}]\n    last_child -> {node_match.last_child}\n    next_node -> {next_node}\n    next_node.next_sibling -> {next_node.next_sibling}\n    end_byte -> {end_byte}\n\"\"\"\n            )\n            if next_node == node_match.last_child:\n                break\n            elif next_node.next_sibling:\n                next_node = next_node.next_sibling\n            else:\n                next_parent_node = self.get_parent_next(\n                    next_node, node_match.check_child or node\n                )\n                next_node = None if next_parent_node == next_node else next_parent_node\n\n        self.debug_log(f\"end   [{level}]: {code_block.content}\")\n\n        for comment_block in self.comments_with_no_span:\n            comment_block.belongs_to_span = current_span\n            comment_block.span_ids.add(current_span.span_id)\n            current_span.block_paths.append(comment_block.full_path())\n            current_span.tokens += comment_block.tokens\n\n        self.comments_with_no_span = []\n\n        self.post_process(code_block)\n\n        self.add_to_index(code_block)\n\n        # TODO: Find a way to remove the Space end block\n        if level == 0 and not node.parent and node.end_byte > end_byte:\n            space_block = CodeBlock(\n                type=CodeBlockType.SPACE,\n                identifier=None,\n                pre_code=content_bytes[end_byte : node.end_byte].decode(self.encoding),\n                parent=code_block,\n                start_line=end_line + 1,\n                end_line=node.end_point[0] + 1,\n                content=\"\",\n            )\n            code_block.append_child(space_block)\n\n        return code_block, next_node, current_span",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::7",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 235,
          "span_ids": [
            "CodeParser.find_in_tree",
            "CodeParser.is_commented_out_code"
          ],
          "start_line": 387,
          "end_line": 412,
          "community": null
        },
        "content": "class CodeParser:\n\n    def is_commented_out_code(self, node: Node):\n        comment = node.text.decode(\"utf8\").strip()\n        return comment.startswith(f\"{get_comment_symbol(self.language)} ...\") or any(\n            keyword in comment.lower() for keyword in commented_out_keywords\n        )\n\n    def find_in_tree(self, node: Node) -> NodeMatch | None:\n        if self.apply_gpt_tweaks:\n            match = self.find_match_with_gpt_tweaks(node)\n            if match:\n                self.debug_log(\n                    f\"find_in_tree() GPT match: {match.block_type} on {node}\"\n                )\n                return match\n\n        match = self.find_match(node)\n        if match:\n            self.debug_log(\n                f\"find_in_tree() Found match on node type {node.type} with block type {match.block_type}\"\n            )\n            return match\n        else:\n            self.debug_log(\n                f\"find_in_tree() Found no match on node type {node.type} set block type {CodeBlockType.CODE}\"\n            )\n            return NodeMatch(block_type=CodeBlockType.CODE)",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::8",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 133,
          "span_ids": [
            "CodeParser.find_match_with_gpt_tweaks"
          ],
          "start_line": 414,
          "end_line": 427,
          "community": null
        },
        "content": "class CodeParser:\n\n    def find_match_with_gpt_tweaks(self, node: Node) -> NodeMatch | None:\n        for label, node_type, query in self.gpt_queries:\n            if node_type and node.type != node_type and node_type != \"_\":\n                continue\n            match = self._find_match(node, query, label, capture_from_parent=True)\n            if match:\n                self.debug_log(\n                    f\"find_match_with_gpt_tweaks() Found match on node {node.type} with query {label}\"\n                )\n                if not match.query:\n                    match.query = label\n                return match\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::9",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 130,
          "span_ids": [
            "CodeParser.find_match"
          ],
          "start_line": 429,
          "end_line": 443,
          "community": null
        },
        "content": "class CodeParser:\n\n    def find_match(self, node: Node) -> NodeMatch | None:\n        self.debug_log(f\"find_match() node type {node.type}\")\n        for label, node_type, query in self.queries:\n            if node_type and node.type != node_type and node_type != \"_\":\n                continue\n            match = self._find_match(node, query, label)\n            if match:\n                self.debug_log(\n                    f\"find_match() Found match on node {node.type} with query {label}\"\n                )\n                if not match.query:\n                    match.query = label\n                return match\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::10",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 591,
          "span_ids": [
            "CodeParser._find_match"
          ],
          "start_line": 445,
          "end_line": 525,
          "community": null
        },
        "content": "class CodeParser:\n\n    def _find_match(\n        self, node: Node, query, label: str, capture_from_parent: bool = False\n    ) -> NodeMatch | None:\n        if capture_from_parent:\n            captures = query.captures(node.parent)\n        else:\n            captures = query.captures(node)\n\n        node_match = NodeMatch()\n\n        if not captures:\n            return None\n\n        root_node = None\n\n        for found_node, tag in captures:\n            self.debug_log(f\"[{label}] Found tag {tag} on node {found_node}\")\n\n            if tag == \"root\" and not root_node and node == found_node:\n                self.debug_log(f\"[{label}] Root node {found_node}\")\n                root_node = found_node\n\n            if not root_node:\n                continue\n\n            if tag == \"no_children\" and found_node.children:\n                return None\n\n            if tag == \"check_child\":\n                self.debug_log(f\"[{label}] Check child {found_node}\")\n                node_match = self.find_match(found_node)\n                if node_match:\n                    node_match.check_child = found_node\n                return node_match\n\n            if tag == \"parse_child\":\n                self.debug_log(f\"[{label}] Parse child {found_node}\")\n\n                child_match = self.find_match(found_node)\n                if child_match:\n                    if child_match.relationships:\n                        self.debug_log(\n                            f\"[{label}] Found {len(child_match.relationships)} references on child {found_node}\"\n                        )\n                        node_match.relationships = child_match.relationships\n                    if child_match.parameters:\n                        self.debug_log(\n                            f\"[{label}] Found {len(child_match.parameters)} parameters on child {found_node}\"\n                        )\n                        node_match.parameters.extend(child_match.parameters)\n                    if child_match.first_child:\n                        node_match.first_child = child_match.first_child\n\n            if tag == \"identifier\" and not node_match.identifier_node:\n                node_match.identifier_node = found_node\n\n            if tag == \"child.first\" and not node_match.first_child:\n                node_match.first_child = found_node\n\n            if tag == \"child.last\" and not node_match.last_child:\n                node_match.last_child = found_node\n\n            if tag == \"parameter.identifier\":\n                node_match.parameters.append((found_node, None))\n\n            if tag == \"parameter.type\" and node_match.parameters:\n                node_match.parameters[-1] = (node_match.parameters[-1][0], found_node)\n\n            if root_node and tag.startswith(\"reference\"):\n                node_match.relationships.append((found_node, tag))\n\n            if not node_match.block_type:\n                node_match.block_type = CodeBlockType.from_string(tag)\n\n        if node_match.block_type:\n            self.debug_log(\n                f\"[{label}] Return match with type {node_match.block_type} for node {node}\"\n            )\n            return node_match\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::10"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::11",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 594,
          "span_ids": [
            "CodeParser.create_references"
          ],
          "start_line": 527,
          "end_line": 611,
          "community": null
        },
        "content": "class CodeParser:\n\n    def create_references(self, code, content_bytes, identifier, node_match):\n        references = []\n        if node_match.block_type == CodeBlockType.IMPORT and node_match.relationships:\n            module_nodes = [\n                ref for ref in node_match.relationships if ref[1] == \"reference.module\"\n            ]\n            if module_nodes:\n                module_reference_id = self.get_content(\n                    module_nodes[0][0], content_bytes\n                )\n                if len(node_match.relationships) > 1:\n                    for ref_node in node_match.relationships:\n                        if ref_node == module_nodes[0]:\n                            continue\n                        elif ref_node[1] == \"reference.alias\":\n                            reference_id = self.get_content(ref_node[0], content_bytes)\n                            references.append(\n                                Relationship(\n                                    scope=ReferenceScope.EXTERNAL,\n                                    type=RelationshipType.IMPORTS,\n                                    identifier=reference_id,\n                                    path=[],\n                                    external_path=[module_reference_id],\n                                )\n                            )\n                        else:\n                            reference_id = self.get_content(ref_node[0], content_bytes)\n                            references.append(\n                                Relationship(\n                                    scope=ReferenceScope.EXTERNAL,\n                                    type=RelationshipType.IMPORTS,\n                                    identifier=reference_id,\n                                    path=[reference_id],\n                                    external_path=[module_reference_id],\n                                )\n                            )\n                else:\n                    references.append(\n                        Relationship(\n                            scope=ReferenceScope.EXTERNAL,\n                            type=RelationshipType.IMPORTS,\n                            identifier=module_reference_id,\n                            external_path=[module_reference_id],\n                        )\n                    )\n        else:\n            for reference in node_match.relationships:\n                reference_id = self.get_content(reference[0], content_bytes)\n\n                reference_id_path = reference_id.split(\".\")\n\n                if not reference_id_path:\n                    logger.warning(\n                        f\"Empty reference_id_path ({reference_id_path}) for code `{code}` in reference node {reference} with value {reference_id}\"\n                    )\n                    continue\n\n                if reference[1] == \"reference.utilizes\":\n                    if node_match.block_type in [\n                        CodeBlockType.FUNCTION,\n                        CodeBlockType.CLASS,\n                    ]:\n                        relationship_type = RelationshipType.DEFINED_BY\n                    else:\n                        relationship_type = RelationshipType.UTILIZES\n                elif reference[1] == \"reference.provides\":\n                    relationship_type = RelationshipType.PROVIDES\n                elif reference[1] == \"reference.calls\":\n                    relationship_type = RelationshipType.CALLS\n                elif reference[1] == \"reference.type\":\n                    relationship_type = RelationshipType.IS_A\n                elif reference[1] == \"reference.imports\":\n                    relationship_type = RelationshipType.IMPORTS\n                else:\n                    relationship_type = RelationshipType.USES\n\n                references.append(\n                    Relationship(\n                        scope=ReferenceScope.LOCAL,\n                        type=relationship_type,\n                        identifier=identifier,\n                        path=reference_id_path,\n                    )\n                )\n        return references",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::11"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::12",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 141,
          "span_ids": [
            "CodeParser.create_parameters"
          ],
          "start_line": 613,
          "end_line": 632,
          "community": null
        },
        "content": "class CodeParser:\n\n    def create_parameters(self, content_bytes, node_match, references):\n        parameters = []\n        for parameter in node_match.parameters:\n            parameter_type = (\n                self.get_content(parameter[1], content_bytes) if parameter[1] else None\n            )\n            parameter_id = self.get_content(parameter[0], content_bytes)\n\n            parameters.append(Parameter(identifier=parameter_id, type=parameter_type))\n\n            if parameter_type:\n                parameter_type = parameter_type.replace('\"', \"\")\n\n                type_split = parameter_type.split(\".\")\n\n                reference = Relationship(\n                    scope=ReferenceScope.LOCAL, identifier=parameter_id, path=type_split\n                )\n                references.append(reference)\n        return parameters",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::12"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::13",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 275,
          "span_ids": [
            "CodeParser.pre_process",
            "CodeParser.get_parent_next",
            "CodeParser.get_previous",
            "CodeParser.has_error",
            "CodeParser.post_process",
            "CodeParser.add_to_index"
          ],
          "start_line": 634,
          "end_line": 671,
          "community": null
        },
        "content": "class CodeParser:\n\n    def add_to_index(self, codeblock: CodeBlock):\n        if self.index_callback:\n            self.index_callback(codeblock)\n\n    def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n        pass\n\n    def post_process(self, codeblock: CodeBlock):\n        pass\n\n    def get_previous(self, node: Node, origin_node: Node):\n        if node == origin_node:\n            return node.start_byte\n        if node.prev_sibling:\n            return node.prev_sibling.end_byte\n        elif node.parent:\n            return self.get_previous(node.parent, origin_node)\n        else:\n            return node.start_byte\n\n    def get_parent_next(self, node: Node, orig_node: Node):\n        self.debug_log(f\"get_parent_next: {node.type} - {orig_node.type}\")\n        if node != orig_node:\n            if node.next_sibling:\n                self.debug_log(\n                    f\"get_parent_next: node.next_sibling -> {node.next_sibling}\"\n                )\n                return node.next_sibling\n            else:\n                return self.get_parent_next(node.parent, orig_node)\n        return None\n\n    def has_error(self, node: Node):\n        if node.type == \"ERROR\":\n            return True\n        if node.children:\n            return any(self.has_error(child) for child in node.children)\n        return False",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::13"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::14",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 229,
          "span_ids": [
            "CodeParser.parse",
            "CodeParser.get_content"
          ],
          "start_line": 673,
          "end_line": 699,
          "community": null
        },
        "content": "class CodeParser:\n\n    def parse(self, content, file_path: Optional[str] = None) -> Module:\n        if isinstance(content, str):\n            content_in_bytes = bytes(content, self.encoding)\n        elif isinstance(content, bytes):\n            content_in_bytes = content\n        else:\n            raise ValueError(\"Content must be either a string or bytes\")\n\n        # TODO: make thread safe?\n        self.spans_by_id = {}\n        self._span_counter = {}\n\n        # TODO: Should me moved to a central CodeGraph\n        self._graph = nx.DiGraph()\n\n        tree = self.tree_parser.parse(content_in_bytes)\n        module, _, _ = self.parse_code(\n            content_in_bytes, tree.walk().node, file_path=file_path\n        )\n        module.spans_by_id = self.spans_by_id\n        module.file_path = file_path\n        module.language = self.language\n        module._graph = self._graph\n        return module\n\n    def get_content(self, node: Node, content_bytes: bytes) -> str:\n        return content_bytes[node.start_byte : node.end_byte].decode(self.encoding)",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::14"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::15",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 740,
          "span_ids": [
            "CodeParser._create_new_span"
          ],
          "start_line": 701,
          "end_line": 784,
          "community": null
        },
        "content": "class CodeParser:\n\n    def _create_new_span(\n        self, current_span: BlockSpan | None, block: CodeBlock\n    ) -> BlockSpan | None:\n        # Set documentation phase on comments in the start of structure blocks if more than min_tokens_for_docs_span\n        # TODO: This is isn't valid in other languages, try to set block type to docstring?\n        block_types_with_document_span = [\n            CodeBlockType.MODULE\n        ]  # TODO: Make this configurable\n        if block.type == CodeBlockType.COMMENT and (\n            not current_span\n            or current_span.block_type in block_types_with_document_span\n            and (\n                current_span.span_type != SpanType.IMPLEMENTATION\n                or current_span.index == 0\n            )\n        ):\n            span_type = SpanType.DOCUMENTATION\n            span_id = self._create_span_id(block, label=\"docstring\")\n\n        # Set initation phase when block is a class or constructor, and until first function:\n        elif block.type in [CodeBlockType.CLASS, CodeBlockType.CONSTRUCTOR] or (\n            current_span\n            and current_span.block_type\n            in [CodeBlockType.CLASS, CodeBlockType.CONSTRUCTOR]\n            and current_span.initiating_block.parent != block.parent\n            and current_span.span_type != SpanType.IMPLEMENTATION\n            and block.type not in [CodeBlockType.FUNCTION]\n        ):\n            span_type = SpanType.INITATION\n            span_id = self._create_span_id(block)\n\n        # Set initation phase on imports in module blocks\n        elif block.type == CodeBlockType.IMPORT and (\n            not current_span or current_span.block_type == CodeBlockType.MODULE\n        ):\n            span_type = SpanType.INITATION\n            span_id = self._create_span_id(block, label=\"imports\")\n\n        else:\n            span_type = SpanType.IMPLEMENTATION\n            span_id = self._create_span_id(block)\n\n        # if no curent_span exists, expected to be on Module level\n        if not current_span:\n            if block.type.group == CodeBlockTypeGroup.STRUCTURE:\n                return BlockSpan(\n                    span_id=span_id,\n                    span_type=span_type,\n                    start_line=block.start_line,\n                    end_line=block.start_line,\n                    initiating_block=block,\n                    parent_block_path=block.full_path(),\n                )\n            else:\n                return BlockSpan(\n                    span_id=span_id,\n                    span_type=span_type,\n                    start_line=block.start_line,\n                    end_line=block.start_line,\n                    initiating_block=block.parent,\n                    parent_block_path=block.parent.full_path(),\n                )\n\n        # create a new span on new structures in classes or modules but not functions\n        # * if the parent block doesn't have a span\n        if (\n            block.type.group in [CodeBlockTypeGroup.STRUCTURE]\n            and block.parent.type in [CodeBlockType.MODULE, CodeBlockType.CLASS]\n            and current_span.parent_block_path == block.parent.full_path()\n        ):\n            if len(current_span.parent_block_path) < len(block.full_path()):\n                # If there is a current span from the parent block it should be set to is_partial\n                current_span.is_partial = True\n\n            return BlockSpan(\n                span_id=span_id,\n                span_type=span_type,\n                start_line=block.start_line,\n                end_line=block.start_line,\n                initiating_block=block,\n                parent_block_path=block.full_path(),\n            )\n\n        # if current span is from a child block\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::15"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::16",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 395,
          "span_ids": [
            "CodeParser._create_new_span"
          ],
          "start_line": 785,
          "end_line": 830,
          "community": null
        },
        "content": "class CodeParser:\n\n    def _create_new_span(\n        self, current_span: BlockSpan | None, block: CodeBlock\n    ) -> BlockSpan | None:\n        # ... other code\n        if len(current_span.parent_block_path) > len(block.parent.full_path()):\n            if block.type.group == CodeBlockTypeGroup.STRUCTURE:\n                parent_block_path = block.full_path()\n            else:\n                parent_block_path = block.parent.full_path()\n\n            return BlockSpan(\n                span_id=span_id,\n                span_type=span_type,\n                start_line=block.start_line,\n                end_line=block.start_line,\n                initiating_block=block,\n                parent_block_path=parent_block_path,\n            )\n\n        # Create new span if span type has changed\n        # if span_type != current_span.span_type:\n        #    return BlockSpan(\n        #        span_id=span_id,\n        #        span_type=span_type,\n        #        start_line=block.start_line,\n        #        end_line=block.start_line,\n        #        initiating_block=current_span.initiating_block,\n        #        parent_block_path=current_span.parent_block_path,\n        #    )\n\n        # Create new span if the current is too large and the parent block is a structure block\n        split_on_block_type = [CodeBlockType.MODULE]  # Only split on Module level\n        if (\n            current_span.tokens + block.sum_tokens() > self._max_tokens_in_span\n            and block.parent.type in split_on_block_type\n        ):\n            current_span.is_partial = True\n\n            return BlockSpan(\n                span_id=span_id,\n                span_type=span_type,\n                start_line=block.start_line,\n                end_line=block.start_line,\n                initiating_block=current_span.initiating_block,\n                parent_block_path=current_span.parent_block_path,\n                is_partial=True,\n                index=current_span.index + 1,\n            )\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::16"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/parser.py::17",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\parser.py",
          "file_name": "parser.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 232,
          "span_ids": [
            "CodeParser.debug_log",
            "CodeParser._count_tokens",
            "CodeParser._create_span_id"
          ],
          "start_line": 832,
          "end_line": 864,
          "community": null
        },
        "content": "class CodeParser:\n\n    def _create_span_id(self, block: CodeBlock, label: Optional[str] = None):\n        if block.type.group == CodeBlockTypeGroup.STRUCTURE:\n            structure_block = block\n        else:\n            structure_block = block.find_type_group_in_parents(\n                CodeBlockTypeGroup.STRUCTURE\n            )\n\n        span_id = structure_block.path_string()\n        if label and span_id:\n            span_id += f\":{label}\"\n        elif label and not span_id:\n            span_id = label\n        elif not span_id:\n            span_id = \"impl\"\n\n        if span_id in self._span_counter:\n            self._span_counter[span_id] += 1\n            span_id += f\":{self._span_counter[span_id]}\"\n        else:\n            self._span_counter[span_id] = 1\n\n        return span_id\n\n    def _count_tokens(self, content: str):\n        if not self.tokenizer:\n            return 0\n        return len(self.tokenizer(content))\n\n    def debug_log(self, message: str):\n        if self.debug:\n            logger.debug(message)",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/parser.py::17"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/python.py::1",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\python.py",
          "file_name": "python.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 379,
          "span_ids": [
            "PythonParser.language",
            "PythonParser.__init__",
            "imports",
            "PythonParser.pre_process",
            "PythonParser"
          ],
          "start_line": 1,
          "end_line": 61,
          "community": null
        },
        "content": "import logging\n\nimport tree_sitter_python as tspython\nfrom tree_sitter import Language\n\nfrom moatless.codeblocks.codeblocks import (\n    CodeBlock,\n    CodeBlockType,\n    ReferenceScope,\n    RelationshipType,\n    ValidationError,\n)\nfrom moatless.codeblocks.parser.parser import (\n    CodeParser,\n    NodeMatch,\n    commented_out_keywords,\n)\n\nchild_block_types = [\"ERROR\", \"block\"]\n\nblock_delimiters = [\":\"]\n\nlogger = logging.getLogger(__name__)\n\n\nclass PythonParser(CodeParser):\n    def __init__(self, **kwargs):\n        language = Language(tspython.language())\n\n        super().__init__(language, **kwargs)\n\n        self.queries = []\n        self.queries.extend(self._build_queries(\"python.scm\"))\n\n        if self.apply_gpt_tweaks:\n            self.gpt_queries.extend(self._build_queries(\"python_gpt.scm\"))\n\n    @property\n    def language(self):\n        return \"python\"\n\n    def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n        if (\n            codeblock.type == CodeBlockType.FUNCTION\n            and codeblock.identifier == \"__init__\"\n        ):\n            codeblock.type = CodeBlockType.CONSTRUCTOR\n\n        # Handle line breaks after assignment without \\\n        if (\n            codeblock.type == CodeBlockType.ASSIGNMENT\n            and codeblock.content_lines[0].strip().endswith(\"=\")\n            and node_match.check_child\n            and node_match.first_child\n            and node_match.check_child.start_point[0]\n            < node_match.first_child.start_point[0]\n        ):\n            logger.warning(\n                f\"Parsed block with type ASSIGNMENT with line break but no ending \\\\: {codeblock.content_lines[0]}\"\n            )\n            codeblock.content_lines[0] = codeblock.content_lines[0] + \" \\\\\"",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/python.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "parser/python.py::2",
        "metadata": {
          "file_path": "moatless\\codeblocks\\parser\\python.py",
          "file_name": "python.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 582,
          "span_ids": [
            "PythonParser.post_process",
            "PythonParser.is_outcommented_code"
          ],
          "start_line": 63,
          "end_line": 136,
          "community": null
        },
        "content": "class PythonParser(CodeParser):\n\n    def post_process(self, codeblock: CodeBlock):\n        if codeblock.type == CodeBlockType.COMMENT and self.is_outcommented_code(\n            codeblock.content\n        ):\n            codeblock.type = CodeBlockType.COMMENTED_OUT_CODE\n\n        if codeblock.type == CodeBlockType.ASSIGNMENT:\n            for reference in codeblock.relationships:\n                reference.type = RelationshipType.TYPE\n\n        new_references = []\n        for reference in codeblock.relationships:\n            # Set parent class path as reference path on self\n            if reference.path and reference.path[0] == \"self\":\n                class_block = codeblock.find_type_in_parents(CodeBlockType.CLASS)\n                if class_block:\n                    reference.scope = ReferenceScope.CLASS\n                    if len(reference.path) > 1:\n                        reference.path = class_block.full_path() + reference.path[1:2]\n                        reference.identifier = codeblock.identifier\n\n            # Set parent classes super class path as reference path on super()\n            # TODO: make a solution where this can be derived even further (by checking import)\n            if reference.path and reference.path[0] == \"super()\":\n                class_block = codeblock.find_type_in_parents(CodeBlockType.CLASS)\n                if class_block:\n                    is_a_rel = [\n                        rel\n                        for rel in class_block.relationships\n                        if rel.type == RelationshipType.IS_A\n                    ]\n                    if is_a_rel:\n                        super_class = codeblock.module.find_by_path(is_a_rel[0].path)\n\n                        if super_class:\n                            reference.path = (\n                                super_class.full_path() + reference.path[1:2]\n                            )\n                            reference.identifier = super_class.identifier\n\n        codeblock.relationships.extend(new_references)\n\n        if (\n            codeblock.type in [CodeBlockType.CLASS, CodeBlockType.FUNCTION]\n            and len(codeblock.children) == 1\n            and codeblock.children[0].type == CodeBlockType.COMMENTED_OUT_CODE\n        ):\n            codeblock.type = CodeBlockType.COMMENTED_OUT_CODE\n\n        function_names = set()\n        class_names = set()\n        for child in codeblock.children:\n            if child.type == CodeBlockType.FUNCTION:\n                if child.identifier in function_names:\n                    child.validation_errors.append(\n                        ValidationError(\n                            error=f\"Duplicate function name: {child.identifier}\"\n                        )\n                    )\n                function_names.add(child.identifier)\n            if child.type == CodeBlockType.CLASS:\n                if child.identifier in class_names:\n                    child.validation_errors.append(\n                        ValidationError(\n                            error=f\"Duplicate class name: {child.identifier}\"\n                        )\n                    )\n                class_names.add(child.identifier)\n\n    def is_outcommented_code(self, comment):\n        return comment.startswith(\"# ...\") or any(\n            keyword in comment.lower() for keyword in commented_out_keywords\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "parser/python.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/__init__.py::1",
        "metadata": {
          "file_path": "moatless\\edit\\__init__.py",
          "file_name": "__init__.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 34,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 4,
          "community": null
        },
        "content": "from moatless.edit.clarify import ClarifyCodeChange\nfrom moatless.edit.edit import EditCode\nfrom moatless.edit.plan import PlanToCode",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/__init__.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::1",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 223,
          "span_ids": [
            "imports",
            "LineNumberClarification"
          ],
          "start_line": 1,
          "end_line": 30,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field, PrivateAttr\n\nfrom moatless.codeblocks import CodeBlockType\nfrom moatless.codeblocks.codeblocks import BlockSpan, CodeBlockTypeGroup\nfrom moatless.edit.prompt import CLARIFY_CHANGE_SYSTEM_PROMPT\nfrom moatless.repository import CodeFile\nfrom moatless.state import ActionResponse, AgenticState\nfrom moatless.types import (\n    ActionRequest,\n    FileWithSpans,\n    Message,\n)\nfrom moatless.utils.tokenizer import count_tokens\n\nlogger = logging.getLogger(\"ClarifyCodeChange\")\n\n\nclass LineNumberClarification(ActionRequest):\n    scratch_pad: str = Field(..., description=\"Thoughts on which lines to select\")\n    start_line: int = Field(\n        ..., description=\"The start line of the code to be updated.\"\n    )\n\n    end_line: int = Field(..., description=\"The end line of the code to be updated.\")\n    reject: Optional[bool] = Field(\n        None, description=\"Whether the request should be rejected.\"\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::2",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 187,
          "span_ids": [
            "ClarifyCodeChange"
          ],
          "start_line": 33,
          "end_line": 48,
          "community": null
        },
        "content": "class ClarifyCodeChange(AgenticState):\n    instructions: str = Field(..., description=\"The instructions for the code change.\")\n    file_path: str = Field(..., description=\"The path to the file to be updated.\")\n    span_id: str = Field(..., description=\"The ID of the span to be updated.\")\n\n    start_line: Optional[int] = Field(None, description=\"The start line of the code to be updated.\")\n    end_line: Optional[int] = Field(None, description=\"The end line of the code to be updated.\")\n\n    max_tokens_in_edit_prompt: int = Field(\n        500,\n        description=\"The maximum number of tokens in a span to show the edit prompt.\",\n    )\n\n    _file: CodeFile | None = PrivateAttr(None)\n    _span: BlockSpan | None = PrivateAttr(None)\n    _file_context_str: Optional[str] = PrivateAttr(None)",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::3",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 260,
          "span_ids": [
            "ClarifyCodeChange.init"
          ],
          "start_line": 50,
          "end_line": 78,
          "community": null
        },
        "content": "class ClarifyCodeChange(AgenticState):\n\n    def init(self):\n        self._file = self.file_repo.get_file(self.file_path)\n        self._span = self._file.module.find_span_by_id(self.span_id)\n\n        file_context = self.create_file_context(\n            [FileWithSpans(file_path=self.file_path, span_ids=[self.span.span_id])]\n        )\n\n        # Include all function/class signatures if the block is a class\n        if self.span.initiating_block.type == CodeBlockType.CLASS:\n            for child in self.span.initiating_block.children:\n                if (\n                    child.type.group == CodeBlockTypeGroup.STRUCTURE\n                    and child.belongs_to_span\n                    and child.belongs_to_span.span_id != self._span.span_id\n                ):\n                    file_context.add_span_to_context(\n                        file_path=self.file_path,\n                        span_id=child.belongs_to_span.span_id,\n                        tokens=1,\n                    )  # TODO: Change so 0 can be set and mean \"only signature\"\n\n        self._file_context_str = file_context.create_prompt(\n            show_line_numbers=True,\n            show_span_ids=False,\n            exclude_comments=False,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"... other code\",\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::4",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 251,
          "span_ids": [
            "ClarifyCodeChange._execute_action"
          ],
          "start_line": 80,
          "end_line": 113,
          "community": null
        },
        "content": "class ClarifyCodeChange(AgenticState):\n\n    def _execute_action(self, request: LineNumberClarification) -> ActionResponse:\n        logger.info(\n            f\"{self}: Got line number clarification: {request.start_line} - {request.end_line}\"\n        )\n\n        if request.reject:\n            return ActionResponse.transition(\n                trigger=\"reject\", output={\"message\": request.scratch_pad}\n            )\n\n        retry_message = self._verify_line_numbers(request)\n        if retry_message:\n            return ActionResponse.retry(retry_message)\n\n        if request.end_line - request.start_line < 4:\n            start_line, end_line = self.get_line_span(\n                request.start_line, request.end_line, self.max_tokens_in_edit_prompt\n            )\n        else:\n            start_line, end_line = request.start_line, request.end_line\n\n        if request.scratch_pad:\n            self.instructions += \"\\n\\n\" + request.scratch_pad\n\n        return ActionResponse.transition(\n            trigger=\"edit_code\",\n            output={\n                \"instructions\": self.instructions,\n                \"file_path\": self.file_path,\n                \"span_id\": self.span_id,\n                \"start_line\": start_line,\n                \"end_line\": end_line,\n            },\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::5",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 128,
          "span_ids": [
            "ClarifyCodeChange.span",
            "ClarifyCodeChange.file",
            "ClarifyCodeChange.required_fields",
            "ClarifyCodeChange.action_type"
          ],
          "start_line": 115,
          "end_line": 130,
          "community": null
        },
        "content": "class ClarifyCodeChange(AgenticState):\n\n    @classmethod\n    def required_fields(cls) -> set[str]:\n        return {\"instructions\", \"file_path\", \"span_id\"}\n\n    def action_type(self) -> type[BaseModel] | None:\n        return LineNumberClarification\n\n    @property\n    def file(self) -> CodeFile:\n        assert self._file is not None, \"File has not been set\"\n        return self._file\n\n    @property\n    def span(self) -> BlockSpan:\n        assert self._span is not None, \"Span has not been set\"\n        return self._span",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::6",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 688,
          "span_ids": [
            "ClarifyCodeChange.messages",
            "ClarifyCodeChange._verify_line_numbers",
            "ClarifyCodeChange.system_prompt"
          ],
          "start_line": 132,
          "end_line": 198,
          "community": null
        },
        "content": "class ClarifyCodeChange(AgenticState):\n\n    def _verify_line_numbers(\n        self, line_numbers: LineNumberClarification\n    ) -> Optional[str]:\n        logger.info(\n            f\"{self}: Verifying line numbers: {line_numbers.start_line} - {line_numbers.end_line}. \"\n            f\"To span with line numbers: {self.span.start_line} - {self.span.end_line}\"\n        )\n\n        if (\n            line_numbers.start_line <= self.span.start_line\n            and line_numbers.end_line >= self.span.end_line\n        ):\n            return f\"The provided line numbers {line_numbers.start_line} - {line_numbers.end_line} covers the whole code span. You must specify line numbers of only lines you want to change.\"\n\n        span_block = self.span.initiating_block\n\n        # The LLM sometimes refer to only the lines of the class/function signature when it's intention is to edit lines\n        if span_block.type.group == CodeBlockTypeGroup.STRUCTURE:\n            last_block_content_line = span_block.children[0].start_line - 1\n\n            logger.info(\n                f\"{self}: Checking if the line numbers only covers a class/function signature to \"\n                f\"{self.span.initiating_block.path_string()} ({span_block.start_line} - {last_block_content_line})\"\n            )\n            if (\n                line_numbers.start_line == span_block.start_line\n                and last_block_content_line >= line_numbers.end_line\n                and self.span.initiating_block.sum_tokens()\n                > self.max_tokens_in_edit_prompt\n            ):\n                clarify_msg = f\"The line numbers {line_numbers.start_line} - {line_numbers.end_line} only covers to the signature of the {self.span.initiating_block.type.value}.\"\n                logger.info(f\"{self}: {clarify_msg}. Ask for clarification.\")\n                # TODO: Ask if this was intentional instead instructing the LLM\n                return f\"{clarify_msg}. You need to specify the exact part of the code that needs to be updated to fulfill the change.\"\n\n        code_lines = self.file.content.split(\"\\n\")\n        lines_to_replace = code_lines[\n            line_numbers.start_line - 1 : line_numbers.end_line\n        ]\n\n        edit_block_code = \"\\n\".join(lines_to_replace)\n\n        tokens = count_tokens(edit_block_code)\n        if tokens > self.max_tokens_in_edit_prompt:\n            clarify_msg = f\"Lines {line_numbers.start_line} - {line_numbers.end_line} has {tokens} tokens, which is higher than the maximum allowed {self.max_tokens_in_edit_prompt} tokens in completion\"\n            logger.info(f\"{self} {clarify_msg}. Ask for clarification.\")\n            return f\"{clarify_msg}. You need to specify the exact part of the code that needs to be updated to fulfill the change. If this is not possible you should reject the request.\"\n\n        return None\n\n    def system_prompt(self) -> str:\n        return CLARIFY_CHANGE_SYSTEM_PROMPT\n\n    def messages(self) -> list[Message]:\n        if not self._file_context_str:\n            self.init()\n\n        messages = [\n            Message(\n                role=\"user\",\n                content=f\"<instructions>\\n{self.instructions}\\n</instructions>\\n<code>\\n{self._file_context_str}\\n</code>\",\n            )\n        ]\n\n        messages.extend(self.retry_messages())\n\n        return messages",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::7",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 602,
          "span_ids": [
            "ClarifyCodeChange.get_line_span"
          ],
          "start_line": 200,
          "end_line": 266,
          "community": null
        },
        "content": "class ClarifyCodeChange(AgenticState):\n\n    def get_line_span(\n        self,\n        start_line: int,\n        end_line: int,\n        max_tokens: int,\n    ) -> tuple[Optional[int], Optional[int]]:\n        \"\"\"\n        Find the span that covers the lines from start_line to end_line\n        \"\"\"\n\n        logger.info(\n            f\"Get span to change in {self.file_path} from {start_line} to {end_line}\"\n        )\n\n        start_block = self.file.module.find_first_by_start_line(start_line)\n        assert (\n            start_block is not None\n        ), f\"No block found in {self.file_path} that starts at line {start_line}\"\n\n        if start_block.type.group == CodeBlockTypeGroup.STRUCTURE and (\n            not end_line or start_block.end_line > end_line\n        ):\n            struture_block = start_block\n        else:\n            struture_block = start_block.find_type_group_in_parents(\n                CodeBlockTypeGroup.STRUCTURE\n            )\n\n        assert (\n            struture_block is not None\n        ), f\"No structure bock found for {start_block.path_string()}\"\n\n        if struture_block.sum_tokens() < max_tokens:\n            logger.info(\n                f\"Return block [{struture_block.path_string()}] ({struture_block.start_line} - {struture_block.end_line}) with {struture_block.sum_tokens()} tokens that covers the provided line span ({start_line} - {end_line})\"\n            )\n            return struture_block.start_line, struture_block.end_line\n\n        if not end_line:\n            end_line = start_line\n\n        original_lines = self.file.content.split(\"\\n\")\n        if struture_block.end_line - end_line < 5:\n            logger.info(\n                f\"Set parent block [{struture_block.path_string()}] end line {struture_block.end_line} as it's {struture_block.end_line - end_line} lines from the end of the file\"\n            )\n            end_line = struture_block.end_line\n        else:\n            end_line = _get_post_end_line_index(\n                end_line, struture_block.end_line, original_lines\n            )\n            logger.info(f\"Set end line to {end_line} from the end of the parent block\")\n\n        if start_line - struture_block.start_line < 5:\n            logger.info(\n                f\"Set parent block [{struture_block.path_string()}] start line {struture_block.start_line} as it's {start_line - struture_block.start_line} lines from the start of the file\"\n            )\n            start_line = struture_block.start_line\n        else:\n            start_line = _get_pre_start_line(\n                start_line, struture_block.start_line, original_lines\n            )\n            logger.info(\n                f\"Set start line to {start_line} from the start of the parent block\"\n            )\n\n        return start_line, end_line",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::8",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 278,
          "span_ids": [
            "_get_pre_start_line"
          ],
          "start_line": 269,
          "end_line": 299,
          "community": null
        },
        "content": "def _get_pre_start_line(\n    start_line: int, min_start_line: int, content_lines: list[str], max_lines: int = 4\n) -> int:\n    if start_line > len(content_lines):\n        raise ValueError(\n            f\"start_line {start_line} is out of range ({len(content_lines)}).\"\n        )\n\n    if start_line - min_start_line < max_lines:\n        return min_start_line\n\n    start_line_index = start_line - 1\n    start_search_index = max(0, start_line_index - 1)\n    end_search_index = max(min_start_line, start_line_index - max_lines)\n\n    non_empty_indices = []\n\n    for idx in range(start_search_index, end_search_index - 1, -1):\n        if content_lines[idx].strip() != \"\":\n            non_empty_indices.append(idx)\n\n    # Check if any non-empty line was found within the search range\n    if non_empty_indices:\n        return non_empty_indices[-1] + 1\n\n    # If no non-empty lines were found, check the start_line itself\n    if content_lines[start_line_index].strip() != \"\":\n        return start_line_index + 1\n\n    # If the start_line is also empty, raise an exception\n    raise ValueError(\"No non-empty line found within 3 lines above the start_line.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/clarify.py::9",
        "metadata": {
          "file_path": "moatless\\edit\\clarify.py",
          "file_name": "clarify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 275,
          "span_ids": [
            "_get_post_end_line_index"
          ],
          "start_line": 302,
          "end_line": 331,
          "community": null
        },
        "content": "def _get_post_end_line_index(\n    end_line: int, max_end_line: int, content_lines: list[str], max_lines: int = 4\n) -> int:\n    if end_line < 1 or end_line > len(content_lines):\n        raise IndexError(\"end_line is out of range.\")\n\n    if max_end_line - end_line < max_lines:\n        return max_end_line\n\n    end_line_index = end_line - 1\n    start_search_index = min(len(content_lines) - 1, end_line_index + 1)\n    end_search_index = min(max_end_line - 1, end_line_index + max_lines)\n\n    non_empty_indices = []\n\n    for idx in range(start_search_index, end_search_index + 1):\n        if content_lines[idx].strip() != \"\":\n            non_empty_indices.append(idx)\n\n    # Check if any non-empty line was found within the search range\n    if non_empty_indices:\n        return non_empty_indices[-1] + 1\n\n    # If no non-empty lines were found, check the end_line itself\n    if content_lines[end_line_index].strip() != \"\":\n        return end_line_index + 1\n\n    # If the end_line is also empty, raise an exception\n    raise ValueError(\"No non-empty line found within 3 lines after the end_line.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/clarify.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/edit.py::1",
        "metadata": {
          "file_path": "moatless\\edit\\edit.py",
          "file_name": "edit.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 663,
          "span_ids": [
            "imports",
            "CodeChange",
            "impl:9"
          ],
          "start_line": 1,
          "end_line": 85,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field, PrivateAttr\n\nfrom moatless.state import AgenticState, Finished\nfrom moatless.types import (\n    ActionRequest,\n    ActionResponse,\n    AssistantMessage,\n    Content,\n    Message,\n    UserMessage,\n    VerificationError,\n)\n\nlogger = logging.getLogger(__name__)\n\nROLE_PROMPT = \"You are autonomous AI assisistant with superior programming skills.\"\n\nMAIN_OBJECTIVE_PROMPT = \"The main objective is to solve a bigger task specified by the user, this is wrapped in a <main_objective> tag.\"\n\nSEARCH_REPLACE_PROMPT = \"\"\"Your task is to solve a smaller task within the main objective. This task is wrapped in a <task> tag.\n\nThe surrounding code context is wrapped in a <file_context> tag.\n\nThe code to that should be modified is wrapped in a <search> tag, like this:\n<search>\n{{CODE}}\n</search>\n\nYour task is to update the code inside the <search> tags based on the current task.\n\nWhen updating the code, please adhere to the following important rules:\n- Fully implement the requested change, but do not make any other changes that were not directly asked for\n- Do not add any comments describing your changes \n- Indentation and formatting should be the same in the replace code as in the search code\n- Ensure the modified code is complete - do not leave any TODOs, placeholder, or missing pieces\n- Keep any existing placeholder comments in the <search> block (e.g. # ... other code) - do not remove or implement them\n\nAfter updating the code, please format your response like this:\n\n<replace>\nput the updated code here\n</replace>\n\nONLY return the code that was inside the original <search> tags, but with the requested modifications made. \nDo not include any of the surrounding code.\n\nIf all code in the search tag should be removed you can return an empty <replace> tag like this:\n<replace>\n</replace>\n\nIf you can't do any changes and want to reject the instructions return the rejection reason wrapped in a <reject> tag, like this:\n<reject>\n{{REASON}}\n</reject>\n\nHere is an example of what the user's request might look like:\n\n<search>\nfrom flask import Flask \n</search>\n\nAnd here is how you should format your response:\n\n<replace>\nimport math\nfrom flask import Flask\n</replace>\n\nRemember, only put the updated version of the code from inside the <search> tags in your response, wrapped in <replace>\ntags. DO NOT include any other surrounding code than the code in the <search> tag! DO NOT leave out any code that was inside the <search> tag!\n\"\"\"\n\n\nCHAIN_OF_THOUGHT_PROMPT = \"Please provide your thoughts on the code change, if any, in the tag <scratch_pad>, and then the code change itself.\"\n\n\nclass CodeChange(ActionRequest):\n    scratch_pad: Optional[str] = Field(\n        default=None, description=\"The thoughts on the code change.\"\n    )\n    replace: str = Field(..., description=\"The code to replace the existing code with.\")\n    rejected: bool = Field(..., description=\"Whether the code change was rejected.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/edit.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/edit.py::2",
        "metadata": {
          "file_path": "moatless\\edit\\edit.py",
          "file_name": "edit.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 342,
          "span_ids": [
            "EditCode",
            "EditCode.init"
          ],
          "start_line": 88,
          "end_line": 116,
          "community": null
        },
        "content": "class EditCode(AgenticState):\n    instructions: str = Field(..., description=\"The instructions for the code change.\")\n    file_path: str = Field(..., description=\"The path to the file to be updated.\")\n    span_id: Optional[str] = Field(None, description=\"The ID of the span to be updated.\")\n    start_line: int = Field(..., description=\"The start line of the code to be updated.\")\n    end_line: int = Field(..., description=\"The end line of the code to be updated.\")\n\n    show_initial_message: bool = Field(True, description=\"Whether to show the initial message.\")\n    show_file_context: bool = Field(True, description=\"Whether to show the file context.\")\n    verify: bool = Field(True, description=\"Whether to verify the code change.\")\n    chain_of_thought: bool = Field(False, description=\"Whether to use chain of thought reasoning.\")\n\n    max_prompt_file_tokens: int = Field(\n        4000,\n        description=\"The maximum number of tokens in the file context to show in the prompt.\",\n    )\n\n    _code_to_replace: Optional[str] = PrivateAttr(default=None)\n    _retry: int = PrivateAttr(default=0)\n    _messages: list[Message] = PrivateAttr(default_factory=list)\n\n    def init(self):\n        file = self.file_context.get_file(self.file_path)\n        if not file:\n            raise ValueError(f\"File not found: {self.file_path}\")\n\n        code_lines = file.file.content.split(\"\\n\")\n        lines_to_replace = code_lines[self.start_line - 1 : self.end_line]\n        self._code_to_replace = \"\\n\".join(lines_to_replace)",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/edit.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/edit.py::3",
        "metadata": {
          "file_path": "moatless\\edit\\edit.py",
          "file_name": "edit.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 341,
          "span_ids": [
            "EditCode._execute_action"
          ],
          "start_line": 118,
          "end_line": 161,
          "community": null
        },
        "content": "class EditCode(AgenticState):\n\n    def _execute_action(self, content: Content) -> ActionResponse:\n        self._messages.append(AssistantMessage(content=content.content))\n\n        scratch_pad = None\n\n        if \"<scratch_pad>\" in content.content:\n            scratch_pad = content.content.split(\"<scratch_pad>\")[1].split(\n                \"</scratch_pad>\"\n            )[0]\n\n        if \"<reject>\" in content.content:\n            rejection_message = content.content.split(\"<reject>\")[1].split(\"</reject>\")[\n                0\n            ]\n            return ActionResponse.transition(\n                \"reject\",\n                output={\"message\": rejection_message},\n            )\n\n        msg_split = content.content.split(\"<replace>\")\n        if len(msg_split) == 1:\n            if not self._add_prepared_response:\n                logger.warning(\n                    f\"No <replace> tag found in response without prepped tag: {msg_split[0]}\"\n                )\n                return ActionResponse.retry(\n                    \"You did not provide any code in the replace tag. If you want to reject the instructions, use the reject function.\"\n                )\n\n            replacement_code = msg_split[0]\n        else:\n            if msg_split[0] and not scratch_pad:\n                scratch_pad = msg_split[0]\n\n            if \"</replace>\" in msg_split[1]:\n                replacement_code = msg_split[1].split(\"</replace>\")[0]\n            else:\n                replacement_code = msg_split[1]\n\n        file = self.file_context.get_file(self.file_path)\n\n        update_result = file.update_content_by_line_numbers(\n            self.start_line - 1, self.end_line, replacement_code\n        )\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/edit.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/edit.py::4",
        "metadata": {
          "file_path": "moatless\\edit\\edit.py",
          "file_name": "edit.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 757,
          "span_ids": [
            "EditCode._execute_action"
          ],
          "start_line": 163,
          "end_line": 263,
          "community": null
        },
        "content": "class EditCode(AgenticState):\n\n    def _execute_action(self, content: Content) -> ActionResponse:\n        # ... other code\n\n        if update_result.diff and update_result.updated:\n            logger.info(\n                f\"Updated file {self.file_path} with diff:\\n{update_result.diff}\"\n            )\n\n            message = f\"Applied the change to {self.file_path}.\"\n\n            if scratch_pad:\n                message += f\"\\n\\n<scratch_pad>\\n{scratch_pad}</scratch_pad>\"\n\n            original_verification_errors = []\n            if self.verify:\n                logger.info(f\"Verifying original code in {self.file_path}.\")\n                original_verification_errors = self.workspace.verify(file.file)\n\n            self.file_repo.save_file(file_path=file.file_path)\n\n            verification_errors = []\n            if self.verify:\n                logger.info(f\"Verifying updated code in {self.file_path}.\")\n                verification_errors_in_update = self.workspace.verify(file.file)\n\n                if len(verification_errors_in_update) > len(\n                    original_verification_errors\n                ):\n                    logger.info(\n                        f\"Found {len(verification_errors_in_update)} verification errors in updated code. Which differs from the original {len(original_verification_errors)}.\"\n                    )\n\n                    for error in verification_errors_in_update:\n                        logger.info(\n                            f\"Verification error: {error.code}, {error.message}\"\n                        )\n                else:\n                    logger.info(\n                        f\"Found {len(verification_errors_in_update)} verification errors in updated code.\"\n                    )\n\n                original_error_set = set(\n                    (msg.code, msg.message) for msg in original_verification_errors\n                )\n\n                updated_error_set = set(\n                    (msg.code, msg.message) for msg in verification_errors_in_update\n                )\n                added_messages_set = updated_error_set - original_error_set\n\n                verification_errors = [\n                    VerificationError(\n                        code=msg.code,\n                        file_path=file.file_path,\n                        message=msg.message,\n                        line=msg.line,\n                    )\n                    for msg in verification_errors_in_update\n                    if (msg.code, msg.message) in added_messages_set\n                ]\n\n                for error in verification_errors:\n                    logger.info(\n                        f\"New verification error: {error.code}, {error.message}\"\n                    )\n\n            return ActionResponse.transition(\n                \"finish\",\n                output={\n                    \"message\": message,\n                    \"diff\": update_result.diff,\n                    \"verification_errors\": verification_errors,\n                },\n            )\n\n        if self._retry > 2:\n            logger.warning(f\"Failed after {self._retry} retries. Will reject change.\")\n            message = \"\"\n            if scratch_pad:\n                message += f\"<scratch_pad>\\n{scratch_pad}</scratch_pad>\\n\\n\"\n            message = \"Failed to apply changes. Please try again.\"\n            return ActionResponse.transition(\"reject\", output={\"message\": message})\n\n        if update_result.diff:\n            logger.warning(f\"Diff was not applied:\\n{update_result.diff}\")\n            response_message = (\n                f\"The following diff was not applied:\\n {update_result.diff}. \\n\"\n                f\"Errors:\\n{update_result.error}\\n\"\n                f\"Make sure that you return the unchanged code in the replace tag exactly as it is. \"\n                f\"If you want to reject the instructions, use the reject function.\"\n            )\n\n            self._retry += 1\n\n        else:\n            logger.info(f\"No changes found in {self.file_path}.\")\n            response_message = (\n                \"The code in the replace tag is the same as in the search. Use the reject function if you \"\n                \"can't do any changes and want to reject the instructions.\"\n            )\n\n            self._retry += 1\n\n        return ActionResponse.retry(response_message)",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/edit.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/edit.py::5",
        "metadata": {
          "file_path": "moatless\\edit\\edit.py",
          "file_name": "edit.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 153,
          "span_ids": [
            "EditCode.finish",
            "EditCode.system_prompt",
            "EditCode.required_fields"
          ],
          "start_line": 265,
          "end_line": 286,
          "community": null
        },
        "content": "class EditCode(AgenticState):\n\n    @classmethod\n    def required_fields(cls) -> set[str]:\n        return {\"instructions\", \"file_path\", \"span_id\", \"start_line\", \"end_line\"}\n\n    def finish(self, message: str):\n        self.transition_to(Finished(message=message))\n\n    def system_prompt(self) -> str:\n        system_prompt = ROLE_PROMPT\n\n        if self.show_initial_message:\n            system_prompt += \"\\n\\n\"\n            system_prompt += MAIN_OBJECTIVE_PROMPT\n\n        system_prompt += \"\\n\\n\"\n        system_prompt += SEARCH_REPLACE_PROMPT\n\n        if self.chain_of_thought:\n            system_prompt += \"\\n\\n\"\n            system_prompt += CHAIN_OF_THOUGHT_PROMPT\n\n        return system_prompt",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/edit.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/edit.py::6",
        "metadata": {
          "file_path": "moatless\\edit\\edit.py",
          "file_name": "edit.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 383,
          "span_ids": [
            "EditCode._add_prepared_response",
            "EditCode.action_type",
            "EditCode.messages",
            "EditCode.stop_words"
          ],
          "start_line": 288,
          "end_line": 339,
          "community": null
        },
        "content": "class EditCode(AgenticState):\n\n    def messages(self) -> list[Message]:\n        if not self._code_to_replace:\n            self.init()\n\n        content = \"\"\n        if self.show_initial_message:\n            content = f\"<main_objective>\\n{self.initial_message}\\n</main_objective>\\n\\n\"\n\n        content += f\"<instructions>\\n{self.instructions}\\n</instructions>\\n\"\n\n        if self.show_file_context:\n            file_context_str = self.file_context.create_prompt(\n                show_line_numbers=False,\n                show_span_ids=False,\n                exclude_comments=False,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"... other code\",\n            )\n        else:\n            file_context = self.create_file_context()\n            file_context.add_span_to_context(self.file_path, self.span_id)\n            file_context.expand_context_with_init_spans()\n            file_context.expand_context_with_related_spans(self.max_prompt_file_tokens)\n            file_context_str = file_context.create_prompt(\n                show_line_numbers=False,\n                show_span_ids=False,\n                exclude_comments=False,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"... other code\",\n            )\n        content += f\"<file_context>\\n{file_context_str}\\n</file_context>\\n\"\n\n        content += f\"<search>\\n{self._code_to_replace}\\n</search>\"\n\n        messages = [UserMessage(content=content)]\n\n        messages.extend(self.retry_messages())\n\n        if self._add_prepared_response:\n            messages.append(AssistantMessage(content=\"<replace>\"))\n\n        return messages\n\n    @property\n    def _add_prepared_response(self):\n        return \"claude\" in self.model and not self.chain_of_thought\n\n    def action_type(self) -> type[BaseModel] | None:\n        return None\n\n    def stop_words(self):\n        return [\"</replace>\"]",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/edit.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::1",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 143,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 23,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nfrom pydantic import ConfigDict, Field, PrivateAttr\n\nfrom moatless.codeblocks import CodeBlockType\nfrom moatless.edit.clarify import _get_post_end_line_index, _get_pre_start_line\nfrom moatless.edit.prompt import (\n    CODER_FINAL_SYSTEM_PROMPT,\n    CODER_SYSTEM_PROMPT,\n    SELECT_SPAN_SYSTEM_PROMPT,\n)\nfrom moatless.state import AgenticState\nfrom moatless.types import (\n    ActionRequest,\n    ActionResponse,\n    AssistantMessage,\n    Message,\n    UserMessage,\n)\nfrom moatless.verify.lint import VerificationError\n\nlogger = logging.getLogger(\"PlanToCode\")",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::2",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 211,
          "span_ids": [
            "ApplyChange"
          ],
          "start_line": 26,
          "end_line": 57,
          "community": null
        },
        "content": "class ApplyChange(ActionRequest):\n    \"\"\"\n    Request to apply a change to the code.\n    \"\"\"\n\n    scratch_pad: str = Field(..., description=\"Your thoughts on the code change.\")\n\n    action: str = Field(\n        ...,\n        description=\"The action to take, possible values are 'modify', 'review', 'finish', 'reject'\",\n    )\n\n    instructions: Optional[str] = Field(\n        None, description=\"Instructions to do the code change.\"\n    )\n    file_path: Optional[str] = Field(\n        None, description=\"The file path of the code to be updated.\"\n    )\n    span_id: Optional[str] = Field(\n        None, description=\"The span id of the code to be updated.\"\n    )\n\n    reject: Optional[str] = Field(\n        None, description=\"Reject the request and explain why.\"\n    )\n    finish: Optional[str] = Field(\n        None, description=\"Finish the request and explain why\"\n    )\n\n    model_config = ConfigDict(\n        extra=\"allow\",\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::3",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 404,
          "span_ids": [
            "PlanToCode.init",
            "PlanToCode"
          ],
          "start_line": 60,
          "end_line": 121,
          "community": null
        },
        "content": "class PlanToCode(AgenticState):\n    message: Optional[str] = Field(\n        None,\n        description=\"Message to the coder\",\n    )\n\n    # TODO: Move to a new state handling changes\n    diff: Optional[str] = Field(\n        None,\n        description=\"The diff of a previous code change.\",\n    )\n\n    # TODO: Move to a new state handling lint problems\n    verification_errors: list[VerificationError] | None = Field(\n        None,\n        description=\"The lint errors of the previous code change.\",\n    )\n\n    max_prompt_file_tokens: int = Field(\n        4000,\n        description=\"The maximum number of tokens in the file context to show in the prompt.\",\n    )\n\n    max_tokens_in_edit_prompt: int = Field(\n        500,\n        description=\"The maximum number of tokens in a span to show the edit prompt.\",\n    )\n\n    expand_context_with_related_spans: bool = Field(\n        True,\n        description=\"Whether to expand the context with related spans.\",\n    )\n\n    allow_hallucinated_spans: bool = Field(\n        False,\n        description=\"Whether to allow spans that exists but aren't found in the file context.\",\n    )\n\n    finish_on_review: bool = Field(\n        False, description=\"Whether to finish the task if a review is requested.\"\n    )\n\n    include_message_history: bool = Field(\n        True,\n        description=\"Whether to include the message history in the prompt.\",\n    )\n\n    _expanded_context: bool = PrivateAttr(False)\n\n    def init(self):\n        if not self._expanded_context:\n            self.file_context.expand_context_with_init_spans()\n\n            if (\n                self.expand_context_with_related_spans\n                and len(self.get_previous_states(self)) == 0\n            ):\n                self.file_context.expand_context_with_related_spans(\n                    max_tokens=self.max_prompt_file_tokens\n                )\n                self.file_context.expand_small_classes(max_tokens=1000)\n            self._expanded_context = True",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::4",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 219,
          "span_ids": [
            "PlanToCode._execute_action",
            "PlanToCode.action_type"
          ],
          "start_line": 123,
          "end_line": 152,
          "community": null
        },
        "content": "class PlanToCode(AgenticState):\n\n    def _execute_action(self, action: ApplyChange) -> ActionResponse:\n        if action.action == \"review\":\n            if self.diff and self.finish_on_review:\n                logger.info(\"Review suggested after diff, will finish\")\n                return ActionResponse.transition(\n                    trigger=\"finish\", output={\"message\": \"Finish on suggested review.\"}\n                )\n            else:\n                return ActionResponse.retry(\n                    \"Review isn't possible. If the change is done you can finish or reject the task.\"\n                )\n\n        if action.action == \"finish\":\n            return ActionResponse.transition(\n                trigger=\"finish\", output={\"message\": action.finish}\n            )\n        elif action.reject:\n            return ActionResponse.transition(\n                trigger=\"reject\", output={\"message\": action.reject}\n            )\n\n        elif action.file_path and action.span_id:\n            return self._request_for_change(action)\n\n        return ActionResponse.retry(\n            \"You must either provide an apply_change action or finish.\"\n        )\n\n    def action_type(self) -> type[ApplyChange]:\n        return ApplyChange",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::5",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 542,
          "span_ids": [
            "PlanToCode._request_for_change"
          ],
          "start_line": 154,
          "end_line": 213,
          "community": null
        },
        "content": "class PlanToCode(AgenticState):\n\n    def _request_for_change(self, rfc: ApplyChange) -> ActionResponse:\n        logger.info(\n            f\"request_for_change(file_path={rfc.file_path}, span_id={rfc.span_id})\"\n        )\n\n        if not rfc.instructions:\n            return ActionResponse.retry(\n                f\"Please provide instructions for the code change.\"\n            )\n\n        context_file = self.file_context.get_file(rfc.file_path)\n        if not context_file:\n            logger.warning(\n                f\"request_for_change: File {rfc.file_path} is not found in the file context.\"\n            )\n\n            files_str = \"\"\n            for file in self.file_context.files:\n                files_str += f\" * {file.file_path}\\n\"\n\n            return ActionResponse.retry(\n                f\"File {rfc.file_path} is not found in the file context. \"\n                f\"You can only request changes to files that are in file context:\\n{files_str}\"\n            )\n\n        block_span = context_file.get_block_span(rfc.span_id)\n        if not block_span and context_file.file.supports_codeblocks:\n            spans = self.file_context.get_spans(rfc.file_path)\n            span_ids = [span.span_id for span in spans]\n\n            span_not_in_context = context_file.file.module.find_span_by_id(rfc.span_id)\n            if span_not_in_context and self.allow_hallucinated_spans:\n                logger.info(\n                    f\"{self}: Span {rfc.span_id} is not found in the context. Will add it.\"\n                )\n                block_span = span_not_in_context\n                self.file_context.add_span_to_context(\n                    file_path=rfc.file_path, span_id=block_span.span_id\n                )\n\n            # Check if the LLM is referring to a parent span shown in the prompt\n            if (\n                span_not_in_context\n                and span_not_in_context.initiating_block.has_any_span(set(span_ids))\n            ):\n                logger.info(\n                    f\"{self}: Use span {rfc.span_id} as it's a parent span of a span in the context.\"\n                )\n                block_span = span_not_in_context\n\n            if not block_span:\n                span_str = \", \".join(span_ids)\n                logger.warning(\n                    f\"{self}: Span not found: {rfc.span_id}. Available spans: {span_str}\"\n                )\n                return ActionResponse.retry(\n                    f\"Span not found: {rfc.span_id}. Available spans: {span_str}\"\n                )\n\n        # If span is for a class block, consider the whole class\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::6",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 477,
          "span_ids": [
            "PlanToCode._request_for_change"
          ],
          "start_line": 214,
          "end_line": 268,
          "community": null
        },
        "content": "class PlanToCode(AgenticState):\n\n    def _request_for_change(self, rfc: ApplyChange) -> ActionResponse:\n        # ... other code\n        if block_span:\n            start_line = block_span.start_line\n            if block_span.initiating_block.type == CodeBlockType.CLASS:\n                tokens = block_span.initiating_block.sum_tokens()\n                end_line = block_span.initiating_block.end_line\n                logger.info(\n                    f\"{self}: Span {rfc.span_id} is a class block. Consider the whole class ({block_span.initiating_block.start_line} - {end_line}) with {tokens} tokens.\"\n                )\n            else:\n                tokens = block_span.tokens\n                end_line = block_span.end_line\n\n        else:\n            span = context_file.get_span(rfc.span_id)\n            if not span:\n                spans = self.file_context.get_spans(rfc.file_path)\n                span_ids = [span.span_id for span in spans]\n                span_str = \", \".join(span_ids)\n                return ActionResponse.retry(\n                    f\"Span not found: {rfc.span_id}. Available spans: {span_str}\"\n                )\n\n            content_lines = context_file.file.content.split(\"\\n\")\n            start_line = _get_pre_start_line(span.start_line, 1, content_lines)\n            end_line = _get_post_end_line_index(\n                span.end_line, len(content_lines), content_lines\n            )\n\n            # TODO: Support token count in files without codeblock support\n            tokens = 0\n\n        if tokens > self.max_tokens_in_edit_prompt:\n            logger.info(\n                f\"{self}: Span has {tokens} tokens, which is higher than the maximum allowed \"\n                f\"{self.max_tokens_in_edit_prompt} tokens. Ask for clarification.\"\n            )\n            return ActionResponse.transition(\n                trigger=\"edit_code\",\n                output={\n                    \"instructions\": rfc.instructions,\n                    \"file_path\": rfc.file_path,\n                    \"span_id\": rfc.span_id,\n                },\n            )\n\n        return ActionResponse.transition(\n            trigger=\"edit_code\",\n            output={\n                \"instructions\": rfc.instructions,\n                \"file_path\": rfc.file_path,\n                \"span_id\": rfc.span_id,\n                \"start_line\": start_line,\n                \"end_line\": end_line,\n            },\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::7",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 188,
          "span_ids": [
            "PlanToCode.system_prompt",
            "PlanToCode.to_message"
          ],
          "start_line": 270,
          "end_line": 292,
          "community": null
        },
        "content": "class PlanToCode(AgenticState):\n\n    def system_prompt(self) -> str:\n        return (\n            CODER_SYSTEM_PROMPT + SELECT_SPAN_SYSTEM_PROMPT + CODER_FINAL_SYSTEM_PROMPT\n        )\n\n    def to_message(self) -> str:\n        response_msg = \"\"\n\n        if self.message:\n            response_msg += self.message\n\n        if self.diff:\n            response_msg += f\"\\n\\n<diff>\\n{self.diff}\\n</diff>\"\n\n        if self.verification_errors:\n            lint_str = \"\"\n            for lint_message in self.verification_errors:\n                lint_str += f\" * {lint_message.code}: {lint_message.message} (line {lint_message.line})\\n\"\n\n            if lint_str:\n                response_msg += f\"\\n\\nThe following lint errors was introduced after this change:\\n<lint_errors>\\n{lint_str}\\n</lint_errors>\"\n\n        return response_msg",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan.py::8",
        "metadata": {
          "file_path": "moatless\\edit\\plan.py",
          "file_name": "plan.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 248,
          "span_ids": [
            "PlanToCode.messages"
          ],
          "start_line": 294,
          "end_line": 335,
          "community": null
        },
        "content": "class PlanToCode(AgenticState):\n\n    def messages(self) -> list[Message]:\n        self.init()\n\n        messages: list[Message] = []\n\n        if self.initial_message:\n            content = f\"<issue>\\n{self.initial_message}\\n</issue>\\n\"\n        else:\n            content = \"\"\n\n        previous_states = self.get_previous_states(self)\n\n        for previous_state in previous_states:\n            new_message = previous_state.to_message()\n            if new_message and not content:\n                content = new_message\n            elif new_message:\n                content += f\"\\n\\n{new_message}\"\n\n            messages.append(UserMessage(content=content))\n            messages.append(\n                AssistantMessage(\n                    action=previous_state.last_action.request,\n                )\n            )\n            content = \"\"\n\n        content += self.to_message()\n        file_context_str = self.file_context.create_prompt(\n            show_span_ids=True,\n            exclude_comments=True,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"... rest of the code\",\n        )\n\n        content += f\"\\n\\n<file_context>\\n{file_context_str}\\n</file_context>\"\n\n        messages.append(UserMessage(content=content))\n        messages.extend(self.retry_messages())\n\n        return messages",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan_lines.py::1",
        "metadata": {
          "file_path": "moatless\\edit\\plan_lines.py",
          "file_name": "plan_lines.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 153,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 24,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nfrom pydantic import ConfigDict, Field\n\nfrom moatless.codeblocks.codeblocks import CodeBlockTypeGroup\nfrom moatless.edit.clarify import _get_post_end_line_index, _get_pre_start_line\nfrom moatless.edit.prompt import (\n    CODER_FINAL_SYSTEM_PROMPT,\n    CODER_SYSTEM_PROMPT,\n    SELECT_LINES_SYSTEM_PROMPT,\n)\nfrom moatless.state import AgenticState\nfrom moatless.types import (\n    ActionRequest,\n    ActionResponse,\n    AssistantMessage,\n    Message,\n    UserMessage,\n)\nfrom moatless.utils.tokenizer import count_tokens\nfrom moatless.verify.lint import VerificationError\n\nlogger = logging.getLogger(\"PlanToCode\")",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan_lines.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan_lines.py::2",
        "metadata": {
          "file_path": "moatless\\edit\\plan_lines.py",
          "file_name": "plan_lines.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 200,
          "span_ids": [
            "ApplyChange"
          ],
          "start_line": 27,
          "end_line": 56,
          "community": null
        },
        "content": "class ApplyChange(ActionRequest):\n    \"\"\"\n    Request to apply a change to the code.\n    \"\"\"\n\n    thoughts: str = Field(..., description=\"Your thoughts on the code change.\")\n\n    instructions: Optional[str] = Field(\n        None, description=\"Instructions to do the code change.\"\n    )\n    file_path: Optional[str] = Field(\n        None, description=\"The file path of the code to be updated.\"\n    )\n    start_line: Optional[int] = Field(\n        None, description=\"The start line of the code to be updated.\"\n    )\n    end_line: Optional[int] = Field(\n        None, description=\"The end line of the code to be updated.\"\n    )\n\n    reject: Optional[str] = Field(\n        ..., description=\"Reject the request and explain why.\"\n    )\n    finish: Optional[str] = Field(\n        None, description=\"Finish the request and explain why\"\n    )\n\n    model_config = ConfigDict(\n        extra=\"allow\",\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan_lines.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan_lines.py::3",
        "metadata": {
          "file_path": "moatless\\edit\\plan_lines.py",
          "file_name": "plan_lines.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 433,
          "span_ids": [
            "PlanToCodeWithLines",
            "PlanToCodeWithLines.action_type",
            "PlanToCodeWithLines._execute_action",
            "PlanToCodeWithLines.init"
          ],
          "start_line": 59,
          "end_line": 128,
          "community": null
        },
        "content": "class PlanToCodeWithLines(AgenticState):\n    message: Optional[str] = Field(\n        None,\n        description=\"Message to the coder\",\n    )\n\n    # TODO: Move to a new state handling changes\n    diff: Optional[str] = Field(\n        None,\n        description=\"The diff of a previous code change.\",\n    )\n\n    # TODO: Move to a new state handling lint problems\n    verification_errors: list[VerificationError] | None = Field(\n        None,\n        description=\"The verification errors from the previous code change.\",\n    )\n\n    max_tokens_in_edit_prompt: int = Field(\n        500,\n        description=\"The maximum number of tokens in a span to show the edit prompt.\",\n    )\n\n    expand_context_with_related_spans: bool = Field(\n        True,\n        description=\"Whether to expand the context with related spans.\",\n    )\n\n    include_message_history: bool = Field(\n        True,\n        description=\"Whether to include the message history in the prompt.\",\n    )\n\n    def init(self):\n        # TODO: Make addition to context customizable??\n\n        for error in self.verification_errors:\n            self.file_context.add_file(\n                file_path=error.file_path\n            )  # TODO: BY line number!\n\n        self.file_context.expand_context_with_init_spans()\n\n        if (\n            self.expand_context_with_related_spans\n            and len(self.get_previous_states(self)) == 0\n        ):\n            self.file_context.expand_context_with_related_spans(max_tokens=4000)\n\n    def _execute_action(self, action: ApplyChange) -> ActionResponse:\n        if action.finish:\n            self.file_context.save()\n\n            return ActionResponse.transition(\n                trigger=\"finish\", output={\"message\": action.finish}\n            )\n        elif action.reject:\n            return ActionResponse.transition(\n                trigger=\"reject\", output={\"message\": action.reject}\n            )\n\n        elif action.file_path:\n            return self._request_for_change(action)\n\n        return ActionResponse.retry(\n            \"You must either provide an apply_change action or finish.\"\n        )\n\n    def action_type(self) -> type[ApplyChange]:\n        return ApplyChange",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan_lines.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan_lines.py::4",
        "metadata": {
          "file_path": "moatless\\edit\\plan_lines.py",
          "file_name": "plan_lines.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 853,
          "span_ids": [
            "PlanToCodeWithLines._request_for_change"
          ],
          "start_line": 130,
          "end_line": 220,
          "community": null
        },
        "content": "class PlanToCodeWithLines(AgenticState):\n\n    def _request_for_change(self, rfc: ApplyChange) -> ActionResponse:\n        logger.info(f\"request_for_change(file_path={rfc.file_path}\")\n\n        context_file = self.file_context.get_file(rfc.file_path)\n        if not context_file:\n            logger.warning(\n                f\"request_for_change: File {rfc.file_path} is not found in the file context.\"\n            )\n\n            files_str = \"\"\n            for file in self.file_context.files:\n                files_str += f\" * {file.file_path}\\n\"\n\n            return ActionResponse.retry(\n                f\"File {rfc.file_path} is not found in the file context. \"\n                f\"You can only request changes to files that are in file context:\\n{files_str}\"\n            )\n\n        if (\n            not rfc.start_line\n            and context_file.module.sum_tokens() > self.max_tokens_in_edit_prompt\n        ):\n            return ActionResponse.retry(\n                f\"The file {rfc.file_path} is to big to edit in one go, please provide start and end line numbers to specify the part of the code that needs to be updated.\"\n            )\n\n        block = context_file.module.find_first_by_start_line(rfc.start_line)\n\n        if block.type.group == CodeBlockTypeGroup.STRUCTURE:\n            structure_block = block\n        else:\n            structure_block = block.find_type_group_in_parents(\n                CodeBlockTypeGroup.STRUCTURE\n            )\n\n        if structure_block.sum_tokens() < self.max_tokens_in_edit_prompt:\n            return ActionResponse.transition(\n                trigger=\"edit_code\",\n                output={\n                    \"instructions\": rfc.instructions,\n                    \"file_path\": rfc.file_path,\n                    \"start_line\": structure_block.start_line,\n                    \"end_line\": structure_block.end_line,\n                },\n            )\n\n        last_structure_block_signature_line = structure_block.children[0].start_line - 1\n        logger.info(\n            f\"{self}: Checking if the line numbers only covers a class/function signature to \"\n            f\"{structure_block.path_string()} ({structure_block.start_line} - {last_structure_block_signature_line})\"\n        )\n        if (\n            rfc.start_line == block.start_line\n            and last_structure_block_signature_line >= rfc.end_line\n        ):\n            clarify_msg = f\"The line numbers {rfc.start_line} - {rfc.end_line} only covers to the signature of the {block.type.value}.\"\n            logger.info(f\"{self}: {clarify_msg}. Ask for clarification.\")\n            # TODO: Ask if this was intentional instead instructing the LLM\n            return ActionResponse.retry(\n                f\"{clarify_msg}. You need to specify the exact part of the code that needs to be updated to fulfill the change.\"\n            )\n\n        code_lines = context_file.file.content.split(\"\\n\")\n        lines_to_replace = code_lines[rfc.start_line - 1 : rfc.end_line]\n\n        edit_block_code = \"\\n\".join(lines_to_replace)\n\n        tokens = count_tokens(edit_block_code)\n        if tokens > self.max_tokens_in_edit_prompt:\n            clarify_msg = f\"Lines {rfc.start_line} - {rfc.end_line} has {tokens} tokens, which is higher than the maximum allowed {self.max_tokens_in_edit_prompt} tokens in completion\"\n            logger.info(f\"{self} {clarify_msg}. Ask for clarification.\")\n            return ActionResponse.retry(\n                f\"{clarify_msg}. You need to specify the exact part of the code that needs to be updated to fulfill the change. If this is not possible you should reject the request.\"\n            )\n\n        start_line = _get_pre_start_line(\n            rfc.start_line, structure_block.start_line, code_lines\n        )\n        end_line = _get_post_end_line_index(\n            rfc.end_line, structure_block.end_line, code_lines\n        )\n\n        return ActionResponse.transition(\n            trigger=\"edit_code\",\n            output={\n                \"instructions\": rfc.instructions,\n                \"file_path\": rfc.file_path,\n                \"start_line\": start_line,\n                \"end_line\": end_line,\n            },\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan_lines.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan_lines.py::5",
        "metadata": {
          "file_path": "moatless\\edit\\plan_lines.py",
          "file_name": "plan_lines.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 204,
          "span_ids": [
            "PlanToCodeWithLines.to_message",
            "PlanToCodeWithLines.system_prompt"
          ],
          "start_line": 222,
          "end_line": 245,
          "community": null
        },
        "content": "class PlanToCodeWithLines(AgenticState):\n\n    def system_prompt(self) -> str:\n        return (\n            CODER_SYSTEM_PROMPT + SELECT_LINES_SYSTEM_PROMPT + CODER_FINAL_SYSTEM_PROMPT\n        )\n\n    def to_message(self) -> str:\n        response_msg = \"\"\n\n        if self.message:\n            response_msg += self.message\n\n        if self.diff:\n            response_msg += f\"\\n\\n<diff>\\n{self.diff}\\n</diff>\"\n\n        if self.verification_errors:\n            lint_str = \"\"\n            for lint_message in self.verification_errors:\n                if lint_message.code[0] in [\"E\", \"F\"]:\n                    lint_str += f\" * {lint_message.code}: {lint_message.message} (line {lint_message.line})\\n\"\n\n            if lint_str:\n                response_msg += f\"\\n\\nThe following lint errors was introduced after this change:\\n<lint_errors>\\n{lint_str}\\n</lint_errors>\"\n\n        return response_msg",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan_lines.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/plan_lines.py::6",
        "metadata": {
          "file_path": "moatless\\edit\\plan_lines.py",
          "file_name": "plan_lines.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 228,
          "span_ids": [
            "PlanToCodeWithLines.messages"
          ],
          "start_line": 247,
          "end_line": 284,
          "community": null
        },
        "content": "class PlanToCodeWithLines(AgenticState):\n\n    def messages(self) -> list[Message]:\n        messages: list[Message] = []\n\n        content = self.initial_message or \"\"\n\n        previous_states = self.get_previous_states(self)\n\n        for previous_state in previous_states:\n            new_message = previous_state.to_message()\n            if new_message and not content:\n                content = new_message\n            elif new_message:\n                content += f\"\\n\\n{new_message}\"\n\n            messages.append(UserMessage(content=content))\n            messages.append(\n                AssistantMessage(\n                    action=previous_state.last_action.request,\n                )\n            )\n            content = \"\"\n\n        content += self.to_message()\n        file_context_str = self.file_context.create_prompt(\n            show_span_ids=False,\n            show_line_numbers=True,\n            exclude_comments=True,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"... rest of the code\",\n        )\n\n        content += f\"\\n\\n<file_context>\\n{file_context_str}\\n</file_context>\"\n\n        messages.append(UserMessage(content=content))\n        messages.extend(self.retry_messages())\n\n        return messages",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/plan_lines.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/prompt.py::1",
        "metadata": {
          "file_path": "moatless\\edit\\prompt.py",
          "file_name": "prompt.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 556,
          "span_ids": [
            "impl"
          ],
          "start_line": 1,
          "end_line": 52,
          "community": null
        },
        "content": "CODER_SYSTEM_PROMPT = \"\"\"You are an autonomous AI assistant with superior programming skills.\n\nYour task is to update the code based on a reported issue wraped in the tag <issue>. \nThe files relevant to the issue is provided in the tag <file_context>.\n\nTo get started, carefully review the issue and the file context to understand the changes that need to be made.\n\"\"\"\n\nCODER_FINAL_SYSTEM_PROMPT = \"\"\"\nAfter receiving the git diff with the updated code, confirm the changes and proceed to the next instruction if applicable.\n\nUse the finish action when the fix of the issue have been properly implemented.\n\nIMPORTANT:\n * Stick to implementing the requirements exactly as specified, without additional changes or suggestions. \n * Limit code changes to only the specific files included in the current context. Don't modify other files or create new ones.\n * DO NOT suggest changes in surrounding code not DIRECTLY connected to the task. When you solved the issue in the code you're finsihed!\n * DO NOT suggest changes in code that are not in <file_context>.\n * DO NOT suggest code reviews! \n * Tests are not in scope. Do not search for tests or suggest writing tests.\n * When you are confident that all changes are correct, you can finish the task without further verification.\n\"\"\"\n\nSELECT_SPAN_SYSTEM_PROMPT = \"\"\"\nThe code is separated into code spans; you can update one span at a time.\nBefore each code change, you first need to request permission to make the change.\nYou do this by using the `ApplyChange` function, which will verify the change and if approved it will do the change and return a git diff and the updated file context.\n\nWhen requesting permission for a change, include the following details:\n\n * The instructions of the specific change you intend to make.\n * The code span you intend to update.\n\"\"\"\n\nSELECT_LINES_SYSTEM_PROMPT = \"\"\"You can update one section of the code at a time.\n\nBefore each code change, you first need to request permission to make the change.\nYou do this by using the `ApplyChange` function, which will verify the change and if approved it will do the change and return a git diff and the updated file context.\n\nWhen requesting permission for a change, include the following details:\n\n * The instructions of the specific change you intend to make.\n * The start and end line numbers of the code you intend to update.\n\"\"\"\n\nCLARIFY_CHANGE_SYSTEM_PROMPT = \"\"\"You are autonomous AI assisistant with superior programming skills.\n\nPlease read the instruction and code carefully. Identify the specific lines in the code that need to be modified to fulfill the instruction.\n\nYou should specify the start and end line numbers using this function `specify_lines`.  You can only specify one contiguous range of lines.\n\"\"\"",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/prompt.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::1",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 211,
          "span_ids": [
            "imports",
            "IncludeSpan"
          ],
          "start_line": 1,
          "end_line": 30,
          "community": null
        },
        "content": "import logging\nfrom typing import Type, Optional, List\n\nfrom pydantic import Field, ConfigDict, PrivateAttr\n\nfrom moatless.codeblocks import CodeBlockType\nfrom moatless.edit.clarify import _get_post_end_line_index, _get_pre_start_line\nfrom moatless.edit.prompt import (\n    CODER_SYSTEM_PROMPT,\n    SELECT_SPAN_SYSTEM_PROMPT,\n    CODER_FINAL_SYSTEM_PROMPT,\n)\nfrom moatless.state import AgenticState\nfrom moatless.types import (\n    ActionRequest,\n    ActionResponse,\n    Message,\n    UserMessage,\n    AssistantMessage,\n    CodeChange,\n)\nfrom moatless.verify.lint import VerificationError\n\nlogger = logging.getLogger(\"PlanToCode\")\n\n\nclass IncludeSpan(ActionRequest):\n    file_path: Optional[str] = Field(None, description=\"Find by file path.\")\n    class_name: Optional[str] = Field(None, description=\"Find by class name.\")\n    function_name: Optional[str] = Field(None, description=\"Find by function name.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::2",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 240,
          "span_ids": [
            "ApplyChange"
          ],
          "start_line": 33,
          "end_line": 68,
          "community": null
        },
        "content": "class ApplyChange(ActionRequest):\n    \"\"\"\n    Request to apply a change to the code.\n    \"\"\"\n\n    scratch_pad: str = Field(..., description=\"Your thoughts on the code change.\")\n\n    action: str = Field(\n        ...,\n        description=\"The action to take, possible values are 'modify', 'review', 'include', 'finish', 'reject'\",\n    )\n\n    instructions: Optional[str] = Field(\n        None, description=\"Instructions to do the code change.\"\n    )\n    file_path: Optional[str] = Field(\n        None, description=\"The file path of the code to be updated.\"\n    )\n    span_id: Optional[str] = Field(\n        None, description=\"The span id of the code to be updated.\"\n    )\n\n    include_spans: Optional[List[IncludeSpan]] = Field(\n        None, description=\"Find spans to include.\"\n    )\n\n    reject: Optional[str] = Field(\n        None, description=\"Reject the request and explain why.\"\n    )\n    finish: Optional[str] = Field(\n        None, description=\"Finish the request and explain why\"\n    )\n\n    model_config = ConfigDict(\n        extra=\"allow\",\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::3",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 161,
          "span_ids": [
            "ApplyChanges"
          ],
          "start_line": 71,
          "end_line": 96,
          "community": null
        },
        "content": "class ApplyChanges(ActionRequest):\n    \"\"\"\n    Request to apply a change to the code.\n    \"\"\"\n\n    scratch_pad: str = Field(..., description=\"Your thoughts on the code change.\")\n\n    action: str = Field(\n        ...,\n        description=\"The action to take, possible values are 'modify', 'review', 'include', 'finish', 'reject'\",\n    )\n\n    changes: Optional[List[CodeChange]] = Field(\n        None, description=\"The changes to apply.\"\n    )\n\n    reject: Optional[str] = Field(\n        None, description=\"Reject the request and explain why.\"\n    )\n    finish: Optional[str] = Field(\n        None, description=\"Finish the request and explain why\"\n    )\n\n    model_config = ConfigDict(\n        extra=\"allow\",\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::4",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 373,
          "span_ids": [
            "ReviewCode",
            "ReviewCode.init"
          ],
          "start_line": 99,
          "end_line": 156,
          "community": null
        },
        "content": "class ReviewCode(AgenticState):\n    message: Optional[str] = Field(\n        None,\n        description=\"Message to the coder\",\n    )\n\n    # TODO: Move to a new state handling changes\n    diff: Optional[str] = Field(\n        None,\n        description=\"The diff of a previous code change.\",\n    )\n\n    max_prompt_file_tokens: int = Field(\n        4000,\n        description=\"The maximum number of tokens in the file context to show in the prompt.\",\n    )\n\n    max_tokens_in_edit_prompt: int = Field(\n        500,\n        description=\"The maximum number of tokens in a span to show the edit prompt.\",\n    )\n\n    allow_hallucinated_spans: bool = Field(\n        False,\n        description=\"Allow hallucinated spans to be used in the edit prompt.\",\n    )\n\n    finish_on_review: bool = Field(\n        False, description=\"Whether to finish the task if a review is requested.\"\n    )\n\n    finish_on_no_errors: bool = Field(\n        False,\n        description=\"Whether to finish the task if no verification errors are found.\",\n    )\n\n    include_message_history: bool = Field(\n        True,\n        description=\"Whether to include the message history in the prompt.\",\n    )\n\n    _verification_errors: List[VerificationError] = PrivateAttr(default_factory=list)\n\n    def init(self) -> Optional[ActionResponse]:\n        self._verification_errors = self.workspace.verify()\n\n        self.file_context.reset_verification_errors()\n\n        for verification_error in self._verification_errors:\n            logger.info(f\"Verification error: {verification_error}\")\n            self.file_context.add_verification_error(verification_error)\n\n        if self.finish_on_no_errors and not self._verification_errors:\n            return ActionResponse.transition(\n                trigger=\"finish\", output={\"message\": \"No errors to review.\"}\n            )\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::5",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 678,
          "span_ids": [
            "ReviewCode.action_type",
            "ReviewCode._execute_action"
          ],
          "start_line": 158,
          "end_line": 246,
          "community": null
        },
        "content": "class ReviewCode(AgenticState):\n\n    def _execute_action(self, action: ApplyChange) -> ActionResponse:\n        if action.action == \"review\":\n            if self.diff and self.finish_on_review:\n                logger.info(f\"Review suggested after diff, will finish\")\n                return ActionResponse.transition(\n                    trigger=\"finish\", output={\"message\": \"Finish on suggested review.\"}\n                )\n            else:\n                return ActionResponse.retry(\n                    \"Review isn't possible. If the change is done you can finish or reject the task.\"\n                )\n\n        if action.include_spans:\n            found_response = \"\"\n            not_found_response = \"\"\n            for include_span in action.include_spans:\n                logger.info(\n                    f\"include_span(file_path={include_span.file_path}, class_name={include_span.class_name}, function_name={include_span.function_name})\"\n                )\n\n                if not include_span.class_name and not include_span.function_name:\n                    return ActionResponse.retry(\n                        \"You must provide either a class name or a function name or both.\"\n                    )\n\n                search_response = self.workspace.code_index.find_by_name(\n                    class_names=[include_span.class_name],\n                    function_names=[include_span.function_name],\n                )\n                if len(search_response.hits) == 1:\n                    found_response += f\" * {search_response.hits[0].file_path}\\n\"\n                    for span in search_response.hits[0].spans:\n                        self.file_context.add_span_to_context(\n                            file_path=search_response.hits[0].file_path,\n                            span_id=span.span_id,\n                        )\n                        found_response += f\"   - {span}\\n\"\n                elif len(search_response.hits) > 1 and include_span.file_path:\n                    file_name = include_span.file_path.split(\"/\")[-1]\n                    for hit in search_response.hits:\n                        if file_name in hit.file_path:\n                            found_response += f\" * {hit.file_path}\\n\"\n                            for span in hit.spans:\n                                self.file_context.add_span_to_context(\n                                    file_path=hit.file_path,\n                                    span_id=span.span_id,\n                                )\n                                found_response += f\"   - {span}\\n\"\n                else:\n                    if include_span.file_path:\n                        not_found_response += f\"{include_span.file_path}\"\n\n                    if include_span.class_name:\n                        not_found_response += f\" class: {include_span.class_name}\"\n\n                    if include_span.function_name:\n                        not_found_response += f\" function: {include_span.function_name}\"\n\n            response = \"\"\n            if found_response:\n                response += f\"Found the following spans:\\n{found_response}\"\n\n            if not_found_response:\n                response += (\n                    f\"\\nCouldn't find the following spans:\\n{not_found_response}\"\n                )\n\n            return ActionResponse.retry(response)\n\n        if action.finish:\n            self.file_context.save()\n\n            return ActionResponse.transition(\n                trigger=\"finish\", output={\"message\": action.finish}\n            )\n        elif action.reject:\n            return ActionResponse.transition(\n                trigger=\"reject\", output={\"message\": action.reject}\n            )\n\n        elif action.file_path and action.span_id:\n            return self._request_for_change(action)\n\n        return ActionResponse.retry(\n            \"You must either provide an apply_change action or finish.\"\n        )\n\n    def action_type(self) -> Type[ApplyChange]:\n        return ApplyChange",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::6",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 806,
          "span_ids": [
            "ReviewCode._request_for_change"
          ],
          "start_line": 248,
          "end_line": 332,
          "community": null
        },
        "content": "class ReviewCode(AgenticState):\n\n    def _request_for_change(self, rfc: ApplyChange) -> ActionResponse:\n        logger.info(\n            f\"request_for_change(file_path={rfc.file_path}, span_id={rfc.span_id})\"\n        )\n\n        context_file = self.file_context.get_file(rfc.file_path)\n        if not context_file:\n            logger.warning(\n                f\"request_for_change: File {rfc.file_path} is not found in the file context.\"\n            )\n\n            files_str = \"\"\n            for file in self.file_context.files:\n                files_str += f\" * {file.file_path}\\n\"\n\n            return ActionResponse.retry(\n                f\"File {rfc.file_path} is not found in the file context. \"\n                f\"You can only request changes to files that are in file context:\\n{files_str}. You can try to add them by using the include_span action.\"\n            )\n\n        block_span = context_file.get_block_span(rfc.span_id)\n        if not block_span and context_file.file.supports_codeblocks:\n            spans = self.file_context.get_spans(rfc.file_path)\n            span_ids = [span.span_id for span in spans]\n\n            span_not_in_context = context_file.file.module.find_span_by_id(rfc.span_id)\n            if span_not_in_context and self.allow_hallucinated_spans:\n                logger.info(\n                    f\"{self}: Span {rfc.span_id} is not found in the context. Will add it.\"\n                )\n                block_span = span_not_in_context\n                self.file_context.add_span_to_context(\n                    file_path=rfc.file_path, span_id=block_span.span_id\n                )\n\n            # Check if the LLM is referring to a parent span shown in the prompt\n            if (\n                span_not_in_context\n                and span_not_in_context.initiating_block.has_any_span(set(span_ids))\n            ):\n                logger.info(\n                    f\"{self}: Use span {rfc.span_id} as it's a parent span of a span in the context.\"\n                )\n                block_span = span_not_in_context\n\n            if not block_span:\n                span_str = \", \".join(span_ids)\n                logger.warning(\n                    f\"{self}: Span not found: {rfc.span_id}. Available spans: {span_str}\"\n                )\n                return ActionResponse.retry(\n                    f\"Span not found: {rfc.span_id}. Available spans: {span_str}\"\n                )\n\n        # If span is for a class block, consider the whole class\n        if block_span:\n            start_line = block_span.start_line\n            if block_span.initiating_block.type == CodeBlockType.CLASS:\n                tokens = block_span.initiating_block.sum_tokens()\n                end_line = block_span.initiating_block.end_line\n                logger.info(\n                    f\"{self}: Span {rfc.span_id} is a class block. Consider the whole class ({block_span.initiating_block.start_line} - {end_line}) with {tokens} tokens.\"\n                )\n            else:\n                tokens = block_span.tokens\n                end_line = block_span.end_line\n\n        else:\n            span = context_file.get_span(rfc.span_id)\n            if not span:\n                spans = self.file_context.get_spans(rfc.file_path)\n                span_ids = [span.span_id for span in spans]\n                span_str = \", \".join(span_ids)\n                return ActionResponse.retry(\n                    f\"Span not found: {rfc.span_id}. Available spans: {span_str}\"\n                )\n\n            content_lines = context_file.file.content.split(\"\\n\")\n            start_line = _get_pre_start_line(span.start_line, 1, content_lines)\n            end_line = _get_post_end_line_index(\n                span.end_line, len(content_lines), content_lines\n            )\n\n            # TODO: Support token count in files without codeblock support\n            tokens = 0\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::7",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 197,
          "span_ids": [
            "ReviewCode._request_for_change"
          ],
          "start_line": 334,
          "end_line": 357,
          "community": null
        },
        "content": "class ReviewCode(AgenticState):\n\n    def _request_for_change(self, rfc: ApplyChange) -> ActionResponse:\n        # ... other code\n\n        if tokens > self.max_tokens_in_edit_prompt:\n            logger.info(\n                f\"{self}: Span has {tokens} tokens, which is higher than the maximum allowed \"\n                f\"{self.max_tokens_in_edit_prompt} tokens. Ask for clarification.\"\n            )\n            return ActionResponse.transition(\n                trigger=\"edit_code\",\n                output={\n                    \"instructions\": rfc.instructions,\n                    \"file_path\": rfc.file_path,\n                    \"span_id\": rfc.span_id,\n                },\n            )\n\n        return ActionResponse.transition(\n            trigger=\"edit_code\",\n            output={\n                \"instructions\": rfc.instructions,\n                \"file_path\": rfc.file_path,\n                \"span_id\": rfc.span_id,\n                \"start_line\": start_line,\n                \"end_line\": end_line,\n            },\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::8",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 181,
          "span_ids": [
            "ReviewCode.to_message",
            "ReviewCode.system_prompt"
          ],
          "start_line": 359,
          "end_line": 382,
          "community": null
        },
        "content": "class ReviewCode(AgenticState):\n\n    def system_prompt(self) -> str:\n        return (\n            CODER_SYSTEM_PROMPT + SELECT_SPAN_SYSTEM_PROMPT + CODER_FINAL_SYSTEM_PROMPT\n        )\n\n    def to_message(self) -> str:\n        response_msg = \"\"\n\n        if self.message:\n            response_msg += self.message\n\n        if self.diff:\n            response_msg += f\"\\n\\n<diff>\\n{self.diff}\\n</diff>\"\n\n        error_str = \"\"\n        for verification_error in self._verification_errors:\n            error_str += f\" * {verification_error.code}: {verification_error.message} (file: {verification_error.file_path}, line {verification_error.line})\\n\"\n\n        if error_str:\n            response_msg += (\n                f\"\\n\\nThe following verification errors was found:\\n\\n{error_str}\\n\"\n            )\n\n        return response_msg",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "edit/review.py::9",
        "metadata": {
          "file_path": "moatless\\edit\\review.py",
          "file_name": "review.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 251,
          "span_ids": [
            "ReviewCode.messages"
          ],
          "start_line": 384,
          "end_line": 424,
          "community": null
        },
        "content": "class ReviewCode(AgenticState):\n\n    def messages(self) -> list[Message]:\n        messages: list[Message] = []\n\n        if self.initial_message:\n            content = f\"<main_objective>\\n{self.initial_message}\\n</main_objective>\"\n        else:\n            content = \"\"\n\n        previous_states = self.get_previous_states(self)\n\n        for previous_state in previous_states:\n            new_message = previous_state.to_message()\n            if new_message and not content:\n                content = new_message\n            elif new_message:\n                content += f\"\\n\\n{new_message}\"\n\n            messages.append(UserMessage(content=content))\n            messages.append(\n                AssistantMessage(\n                    action=previous_state.last_action.request,\n                )\n            )\n            content = \"\"\n\n        content += self.to_message()\n        file_context_str = self.file_context.create_prompt(\n            show_span_ids=True,\n            show_line_numbers=True,\n            exclude_comments=False,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"... rest of the code\",\n        )\n\n        content += f\"\\n\\n<file_context>\\n{file_context_str}\\n</file_context>\"\n\n        messages.append(UserMessage(content=content))\n        messages.extend(self.retry_messages())\n\n        return messages",
        "summary": null,
        "ctxt_list": [],
        "id": "edit/review.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::1",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 223,
          "span_ids": [
            "imports",
            "CurrentPromptSpan",
            "ContextSpan",
            "RankedFileSpan"
          ],
          "start_line": 1,
          "end_line": 40,
          "community": null
        },
        "content": "import json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Optional, List, Dict, Set\n\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.v1 import PrivateAttr\n\nfrom moatless.codeblocks import CodeBlockType\nfrom moatless.codeblocks.codeblocks import (\n    BlockSpan,\n    CodeBlock,\n    CodeBlockTypeGroup,\n    SpanMarker,\n    SpanType,\n)\nfrom moatless.repository import CodeFile, FileRepository, UpdateResult\nfrom moatless.types import FileWithSpans\n\nlogger = logging.getLogger(__name__)\n\n\nclass RankedFileSpan(BaseModel):\n    file_path: str\n    span_id: str\n    rank: int = 0\n    tokens: int = 0\n\n\nclass ContextSpan(BaseModel):\n    span_id: str\n    start_line: Optional[int] = None\n    end_line: Optional[int] = None\n    tokens: Optional[int] = None\n\n\n@dataclass\nclass CurrentPromptSpan:\n    span_id: Optional[str] = None\n    tokens: int = 0",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::2",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 159,
          "span_ids": [
            "ContextFile.__init__",
            "ContextFile",
            "ContextFile.file_path",
            "ContextFile.module",
            "ContextFile.model_dump",
            "ContextFile.span_ids",
            "ContextFile.content"
          ],
          "start_line": 43,
          "end_line": 70,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n    file: CodeFile\n    spans: List[ContextSpan] = []\n    show_all_spans: bool = False\n\n    def __init__(self, **data):\n        super().__init__(**data)\n\n    def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs, exclude={\"file\"})\n        data[\"file_path\"] = self.file.file_path\n        return data\n\n    @property\n    def file_path(self):\n        return self.file.file_path\n\n    @property\n    def module(self):\n        return self.file.module\n\n    @property\n    def content(self):\n        return self.file.content\n\n    @property\n    def span_ids(self):\n        return {span.span_id for span in self.spans}",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::3",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 223,
          "span_ids": [
            "ContextFile.to_prompt"
          ],
          "start_line": 72,
          "end_line": 102,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def to_prompt(\n        self,\n        show_span_ids=False,\n        show_line_numbers=False,\n        exclude_comments=False,\n        show_outcommented_code=False,\n        outcomment_code_comment: str = \"...\",\n    ):\n        if self.file.supports_codeblocks:\n            if (\n                not self.show_all_spans\n                and self.span_ids is not None\n                and len(self.span_ids) == 0\n            ):\n                logger.warning(\n                    f\"No span ids provided for {self.file_path}, return empty\"\n                )\n                return \"\"\n\n            code = self._to_prompt(\n                code_block=self.module,\n                show_span_id=show_span_ids,\n                show_line_numbers=show_line_numbers,\n                outcomment_code_comment=outcomment_code_comment,\n                show_outcommented_code=show_outcommented_code,\n                exclude_comments=exclude_comments,\n            )\n        else:\n            code = self._to_prompt_with_line_spans(show_span_id=show_span_ids)\n\n        return f\"{self.file_path}\\n```\\n{code}\\n```\\n\"",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::4",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 132,
          "span_ids": [
            "ContextFile._within_span",
            "ContextFile._find_span"
          ],
          "start_line": 104,
          "end_line": 122,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def _find_span(self, codeblock: CodeBlock) -> Optional[ContextSpan]:\n        if not codeblock.belongs_to_span:\n            return None\n\n        for span in self.spans:\n            if codeblock.belongs_to_span.span_id == span.span_id:\n                return span\n\n        return None\n\n    def _within_span(self, line_no: int) -> Optional[ContextSpan]:\n        for span in self.spans:\n            if (\n                span.start_line\n                and span.end_line\n                and span.start_line <= line_no <= span.end_line\n            ):\n                return span\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::5",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 164,
          "span_ids": [
            "ContextFile._to_prompt_with_line_spans"
          ],
          "start_line": 124,
          "end_line": 146,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def _to_prompt_with_line_spans(self, show_span_id: bool = False) -> str:\n        content_lines = self.content.split(\"\\n\")\n\n        if not self.span_ids:\n            return self.content\n\n        prompt_content = \"\"\n        outcommented = True\n        for i, line in enumerate(content_lines):\n            line_no = i + 1\n\n            span = self._within_span(line_no)\n            if span:\n                if outcommented and show_span_id:\n                    prompt_content += f\"<span id={span.span_id}>\\n\"\n\n                prompt_content += line + \"\\n\"\n                outcommented = False\n            elif not outcommented:\n                prompt_content += \"... other code\\n\"\n                outcommented = True\n\n        return prompt_content",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::6",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 735,
          "span_ids": [
            "ContextFile._to_prompt"
          ],
          "start_line": 148,
          "end_line": 251,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def _to_prompt(\n        self,\n        code_block: CodeBlock,\n        current_span: Optional[CurrentPromptSpan] = None,\n        show_outcommented_code: bool = True,\n        outcomment_code_comment: str = \"...\",\n        show_span_id: bool = False,\n        show_line_numbers: bool = False,\n        exclude_comments: bool = False,\n    ):\n        if current_span is None:\n            current_span = CurrentPromptSpan()\n        contents = \"\"\n\n        outcommented_block = None\n        for _i, child in enumerate(code_block.children):\n            if exclude_comments and child.type.group == CodeBlockTypeGroup.COMMENT:\n                continue\n\n            show_new_span_id = False\n            show_child = False\n            child_span = self._find_span(child)\n\n            if child_span:\n                if child_span.span_id != current_span.span_id:\n                    show_child = True\n                    show_new_span_id = show_span_id\n                    current_span = CurrentPromptSpan(child_span.span_id)\n                elif not child_span.tokens:\n                    show_child = True\n                else:\n                    # Count all tokens in child block if it's not a structure (function or class) or a 'compound' (like an 'if' or 'for' clause)\n                    if (\n                        child.type.group == CodeBlockTypeGroup.IMPLEMENTATION\n                        and child.type\n                        not in [CodeBlockType.COMPOUND, CodeBlockType.DEPENDENT_CLAUSE]\n                    ):\n                        child_tokens = child.sum_tokens()\n                    else:\n                        child_tokens = child.tokens\n\n                    if current_span.tokens + child_tokens <= child_span.tokens:\n                        show_child = True\n\n                    current_span.tokens += child_tokens\n\n            elif (\n                not child.belongs_to_span or child.belongs_to_any_span not in self.spans\n            ) and child.has_any_span(self.span_ids):\n                show_child = True\n\n                if (\n                    child.belongs_to_span\n                    and current_span.span_id != child.belongs_to_span.span_id\n                ):\n                    show_new_span_id = show_span_id\n                    current_span = CurrentPromptSpan(child.belongs_to_span.span_id)\n\n            if self.show_all_spans:\n                show_child = True\n\n            if show_child:\n                if outcommented_block:\n                    contents += outcommented_block._to_prompt_string(\n                        show_line_numbers=show_line_numbers\n                    )\n\n                outcommented_block = None\n\n                contents += child._to_prompt_string(\n                    show_span_id=show_new_span_id,\n                    show_line_numbers=show_line_numbers,\n                    span_marker=SpanMarker.TAG,\n                )\n                contents += self._to_prompt(\n                    code_block=child,\n                    exclude_comments=exclude_comments,\n                    show_outcommented_code=show_outcommented_code,\n                    outcomment_code_comment=outcomment_code_comment,\n                    show_span_id=show_span_id,\n                    current_span=current_span,\n                    show_line_numbers=show_line_numbers,\n                )\n            elif show_outcommented_code and not outcommented_block:\n                outcommented_block = child.create_commented_out_block(\n                    outcomment_code_comment\n                )\n                outcommented_block.start_line = child.start_line\n\n        if (\n            outcomment_code_comment\n            and outcommented_block\n            and child.type\n            not in [\n                CodeBlockType.COMMENT,\n                CodeBlockType.COMMENTED_OUT_CODE,\n                CodeBlockType.SPACE,\n            ]\n        ):\n            contents += outcommented_block._to_prompt_string(\n                show_line_numbers=show_line_numbers\n            )\n\n        return contents",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::7",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 140,
          "span_ids": [
            "ContextFile.context_size",
            "ContextFile.add_spans"
          ],
          "start_line": 253,
          "end_line": 273,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def context_size(self):\n        if self.file.supports_codeblocks:\n            if self.span_ids is None:\n                return self.module.sum_tokens()\n            else:\n                tokens = 0\n                for span_id in self.span_ids:\n                    span = self.module.find_span_by_id(span_id)\n                    if span:\n                        tokens += span.tokens\n                return tokens\n        else:\n            return 0  # TODO: Support context size...\n\n    def add_spans(\n        self,\n        span_ids: Set[str],\n        tokens: Optional[int] = None,\n    ):\n        for span_id in span_ids:\n            self.add_span(span_id, tokens)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::8",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 136,
          "span_ids": [
            "ContextFile.add_span"
          ],
          "start_line": 275,
          "end_line": 293,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def add_span(\n        self,\n        span_id: str,\n        tokens: Optional[int] = None,\n    ):\n        existing_span = next(\n            (span for span in self.spans if span.span_id == span_id), None\n        )\n\n        if existing_span:\n            existing_span.tokens = tokens\n        else:\n            span = self.module.find_span_by_id(span_id)\n            if span:\n                self.spans.append(ContextSpan(span_id=span_id, tokens=tokens))\n            else:\n                logger.info(\n                    f\"Could not find span with id {span_id} in file {self.file_path}\"\n                )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::9",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 119,
          "span_ids": [
            "ContextFile.add_line_span"
          ],
          "start_line": 295,
          "end_line": 306,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def add_line_span(self, start_line: int, end_line: int):\n        module = self.file.module\n\n        logger.info(f\"Adding line span {start_line} - {end_line} to {self.file_path}\")\n        if module:\n            block = module.find_first_by_start_line(start_line)\n            structure_block = block.structure_block()\n            self.spans.append(\n                ContextSpan(span_id=structure_block.belongs_to_span.span_id)\n            )\n        else:\n            logger.warning(f\"Could not find module for file {self.file_path}\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::10",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 258,
          "span_ids": [
            "ContextFile.remove_span",
            "ContextFile.get_span",
            "ContextFile.get_spans",
            "ContextFile.get_block_span"
          ],
          "start_line": 308,
          "end_line": 340,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def remove_span(self, span_id: str):\n        self.spans = [span for span in self.spans if span.span_id != span_id]\n\n    def get_spans(self) -> List[BlockSpan]:\n        block_spans = []\n        for span in self.spans:\n            if not self.file.supports_codeblocks:\n                continue\n\n            block_span = self.module.find_span_by_id(span.span_id)\n            if block_span:\n                block_spans.append(block_span)\n        return block_spans\n\n    def get_block_span(self, span_id: str) -> Optional[BlockSpan]:\n        if not self.file.supports_codeblocks:\n            return None\n        for span in self.spans:\n            if span.span_id == span_id:\n                block_span = self.module.find_span_by_id(span_id)\n                if block_span:\n                    return block_span\n                else:\n                    logger.warning(\n                        f\"Could not find span with id {span_id} in file {self.file_path}\"\n                    )\n        return None\n\n    def get_span(self, span_id: str) -> Optional[ContextSpan]:\n        for span in self.spans:\n            if span.span_id == span_id:\n                return span\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::10"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::11",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 116,
          "span_ids": [
            "ContextFile.update_content_by_line_numbers"
          ],
          "start_line": 342,
          "end_line": 355,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def update_content_by_line_numbers(\n        self, start_line_index: int, end_line_index: int, replacement_content: str\n    ) -> UpdateResult:\n        update_result = self.file.update_content_by_line_numbers(\n            start_line_index, end_line_index, replacement_content\n        )\n\n        if update_result.new_span_ids:\n            logger.info(\n                f\"Adding new spans: {update_result.new_span_ids} to {self.file_path}\"\n            )\n            self.add_spans(update_result.new_span_ids)\n\n        return update_result",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::11"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::12",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 195,
          "span_ids": [
            "ContextFile.expand_context_with_init_spans"
          ],
          "start_line": 357,
          "end_line": 378,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def expand_context_with_init_spans(self):\n        init_spans = set()\n        if not self.file.supports_codeblocks:\n            return\n\n        for child in self.module.children:\n            if (\n                child.type == CodeBlockType.IMPORT\n                and child.belongs_to_span.span_type == SpanType.INITATION\n                and child.belongs_to_span.span_id not in init_spans\n            ):\n                self.add_span(child.belongs_to_span.span_id)\n\n        for span_id in self.span_ids:\n            span = self.module.find_span_by_id(span_id)\n            if span and span.initiating_block.type == CodeBlockType.CLASS:\n                for child in span.initiating_block.children:\n                    if (\n                        child.belongs_to_span.span_type == SpanType.INITATION\n                        and child.belongs_to_span.span_id not in init_spans\n                    ):\n                        self.add_span(child.belongs_to_span.span_id)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::12"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::13",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 158,
          "span_ids": [
            "ContextFile.expand_small_classes"
          ],
          "start_line": 380,
          "end_line": 397,
          "community": null
        },
        "content": "class ContextFile(BaseModel):\n\n    def expand_small_classes(self, max_tokens: int):\n        \"\"\"\n        Expand small classes with no other spans selected if the context allows it.\n\n        TODO: This a temporary solution, should be handled by asking the LLM to specify spans in the Identify step.\n        \"\"\"\n        if not self.file.supports_codeblocks:\n            return\n\n        if len(self.spans) == 1:\n            span = self.module.find_span_by_id(self.spans[0].span_id)\n            if (\n                span\n                and span.initiating_block.type == CodeBlockType.CLASS\n                and span.initiating_block.sum_tokens() < max_tokens\n            ):\n                for span_id in span.initiating_block.get_all_span_ids():\n                    self.add_span(span_id)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::13"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::14",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 347,
          "span_ids": [
            "FileContext.from_json",
            "FileContext.from_dir",
            "FileContext.__init__",
            "FileContext",
            "FileContext.from_dict"
          ],
          "start_line": 400,
          "end_line": 438,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n    _repo: FileRepository = PrivateAttr()\n    _file_context: Dict[str, ContextFile] = PrivateAttr(default_factory=dict)\n    _max_tokens: int = PrivateAttr(default=4000)\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __init__(self, repo: FileRepository, **data):\n        super().__init__(**data)\n        self._repo = repo\n        if \"_file_context\" not in self.__dict__:\n            self.__dict__[\"_file_context\"] = {}\n        if \"_max_tokens\" not in self.__dict__:\n            self.__dict__[\"_max_tokens\"] = data.get(\"max_tokens\", 4000)\n\n    @classmethod\n    def from_dir(cls, repo_dir: str, max_tokens: int = 4000):\n        repo = FileRepository(repo_dir)\n        instance = cls(max_tokens=max_tokens, repo=repo)\n        return instance\n\n    @classmethod\n    def from_json(cls, repo_dir: str, json_data: str):\n        \"\"\"\n        Create a FileContext instance from JSON data.\n\n        :param repo_dir: The repository directory path.\n        :param json_data: A JSON string representing the FileContext data.\n        :return: A new FileContext instance.\n        \"\"\"\n        data = json.loads(json_data)\n        return cls.from_dict(repo_dir, data)\n\n    @classmethod\n    def from_dict(cls, repo_dir: str, data: Dict):\n        repo = FileRepository(repo_dir)\n        instance = cls(max_tokens=data.get(\"max_tokens\", 4000), repo=repo)\n        instance.load_files_from_dict(data.get(\"files\", []))\n        return instance",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::14"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::15",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 116,
          "span_ids": [
            "FileContext.load_files_from_dict"
          ],
          "start_line": 440,
          "end_line": 449,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n\n    def load_files_from_dict(self, files: list[dict]):\n        for file_data in files:\n            file_path = file_data[\"file_path\"]\n            show_all_spans = file_data.get(\"show_all_spans\", False)\n            spans = [ContextSpan(**span) for span in file_data.get(\"spans\", [])]\n            self._file_context[file_path] = ContextFile(\n                file=self._repo.get_file(file_path),\n                spans=spans,\n                show_all_spans=show_all_spans,\n            )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::15"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::16",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 785,
          "span_ids": [
            "FileContext.add_span_to_context",
            "FileContext.snapshot",
            "FileContext.model_dump",
            "FileContext.add_files_with_spans",
            "FileContext.files",
            "FileContext.get_file",
            "FileContext.add_file",
            "FileContext.add_spans_to_context",
            "FileContext.restore_from_snapshot",
            "FileContext.exists",
            "FileContext.add_line_span_to_context",
            "FileContext.to_files_with_spans",
            "FileContext.add_file_with_lines",
            "FileContext.remove_file"
          ],
          "start_line": 451,
          "end_line": 548,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n\n    def model_dump(self, **kwargs):\n        if \"exclude_none\" not in kwargs:\n            kwargs[\"exclude_none\"] = True\n\n        files = [\n            file.model_dump(**kwargs)\n            for file in self.__dict__[\"_file_context\"].values()\n        ]\n        return {\"max_tokens\": self.__dict__[\"_max_tokens\"], \"files\": files}\n\n    def snapshot(self):\n        dict = self.model_dump()\n        del dict[\"max_tokens\"]\n        return dict\n\n    def restore_from_snapshot(self, snapshot: dict):\n        self._file_context = {}\n        self.load_files_from_dict(snapshot.get(\"files\", []))\n\n    def to_files_with_spans(self) -> List[FileWithSpans]:\n        return [\n            FileWithSpans(file_path=file_path, span_ids=list(file.span_ids))\n            for file_path, file in self._file_context.items()\n        ]\n\n    def add_files_with_spans(self, files_with_spans: List[FileWithSpans]):\n        for file_with_spans in files_with_spans:\n            self.add_spans_to_context(\n                file_with_spans.file_path, set(file_with_spans.span_ids)\n            )\n\n    def add_file(self, file_path: str, show_all_spans: bool = False):\n        if file_path not in self._file_context:\n            self._file_context[file_path] = ContextFile(\n                file=self._repo.get_file(file_path),\n                spans=[],\n                show_all_spans=show_all_spans,\n            )\n\n    def add_file_with_lines(\n        self, file_path: str, start_line: int, end_line: Optional[int] = None\n    ):\n        end_line = end_line or start_line\n        if file_path not in self._file_context:\n            self._file_context[file_path] = ContextFile(\n                file=self._repo.get_file(file_path), spans=[]\n            )\n\n        self._file_context[file_path].add_line_span(start_line, end_line)\n\n    def remove_file(self, file_path: str):\n        if file_path in self._file_context:\n            del self._file_context[file_path]\n\n    def exists(self, file_path: str):\n        return file_path in self._file_context\n\n    @property\n    def files(self):\n        return list(self._file_context.values())\n\n    def get_file(\n        self, file_path: str, add_if_not_found: bool = False\n    ) -> Optional[ContextFile]:\n        context_file = self._file_context.get(file_path)\n        if not context_file and add_if_not_found:\n            file = self._repo.get_file(file_path)\n            if file:\n                context_file = ContextFile(file=file, spans=[])\n                self._file_context[file_path] = context_file\n\n        return context_file\n\n    def add_spans_to_context(\n        self,\n        file_path: str,\n        span_ids: Set[str],\n        tokens: Optional[int] = None,\n    ):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            context_file.add_spans(span_ids, tokens)\n        else:\n            logger.warning(f\"Could not find file {file_path} in the repository\")\n\n    def add_span_to_context(\n        self, file_path: str, span_id: str, tokens: Optional[int] = None\n    ):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            context_file.add_span(span_id, tokens)\n\n    def add_line_span_to_context(self, file_path: str, start_line: int, end_line: int):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            context_file.add_line_span(start_line, end_line)\n        else:\n            logger.warning(f\"Could not find file {file_path} in the repository\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::16"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::17",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 273,
          "span_ids": [
            "FileContext.remove_spans_from_context",
            "FileContext.get_span",
            "FileContext.remove_span_from_context",
            "FileContext.has_span",
            "FileContext.get_spans"
          ],
          "start_line": 550,
          "end_line": 582,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n\n    def remove_span_from_context(\n        self, file_path: str, span_id: str, remove_file: bool = False\n    ):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            context_file.remove_span(span_id)\n\n            if not context_file.spans and remove_file:\n                self.remove_file(file_path)\n\n    def remove_spans_from_context(\n        self, file_path: str, span_ids: List[str], remove_file: bool = False\n    ):\n        for span_id in span_ids:\n            self.remove_span_from_context(file_path, span_id, remove_file)\n\n    def get_spans(self, file_path: str) -> List[BlockSpan]:\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return context_file.get_spans()\n        return []\n\n    def get_span(self, file_path: str, span_id: str) -> Optional[BlockSpan]:\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return context_file.get_block_span(span_id)\n        return None\n\n    def has_span(self, file_path: str, span_id: str):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return span_id in context_file.span_ids\n        return False",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::17"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::18",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 547,
          "span_ids": [
            "FileContext.add_ranked_spans"
          ],
          "start_line": 584,
          "end_line": 653,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n\n    def add_ranked_spans(\n        self,\n        ranked_spans: List[RankedFileSpan],\n        decay_rate: float = 1.05,\n        min_tokens: int = 50,\n    ):\n        if not ranked_spans:\n            logger.info(\"No ranked spans provided\")\n            return\n\n        sum_tokens = sum(span.tokens for span in ranked_spans)\n        if sum_tokens < self._max_tokens:\n            logger.info(\n                f\"Adding all {len(ranked_spans)} spans with {sum_tokens} tokens\"\n            )\n            for span in ranked_spans:\n                self.add_span_to_context(span.file_path, span.span_id)\n            return\n\n        ranked_spans.sort(key=lambda x: x.rank)\n\n        base_tokens_needed = sum(min(span.tokens, min_tokens) for span in ranked_spans)\n\n        # Filter out the lowest ranking spans if necessary\n        while base_tokens_needed > self._max_tokens and ranked_spans:\n            removed_span = ranked_spans.pop()\n            base_tokens_needed -= min(removed_span.tokens, min_tokens)\n\n        if not ranked_spans:\n            raise ValueError(\n                \"Not enough tokens to meet the minimum token requirement for any span\"\n            )\n\n        remaining_tokens = self._max_tokens - base_tokens_needed\n\n        # Calculate total weights using exponential decay\n        total_weight = sum([decay_rate ** (-span.rank) for span in ranked_spans])\n\n        # Assign tokens based on the weight and the span's token count\n        tokens_distribution = []\n        for span in ranked_spans:\n            weight = decay_rate ** (-span.rank)\n            allocated_tokens = min(\n                span.tokens,\n                min_tokens + int(remaining_tokens * (weight / total_weight)),\n            )\n            tokens_distribution.append((span, allocated_tokens))\n\n        # Adjust tokens for spans with the same rank\n        rank_groups = {}\n        for span, tokens in tokens_distribution:\n            if span.rank not in rank_groups:\n                rank_groups[span.rank] = []\n            rank_groups[span.rank].append((span, tokens))\n\n        final_tokens_distribution = []\n        for _rank, group in rank_groups.items():\n            for span, tokens in group:\n                adjusted_tokens = min(span.tokens, tokens)\n                final_tokens_distribution.append((span, adjusted_tokens))\n\n        # Distribute tokens and add spans to the context\n        sum_tokens = 0\n        for span, tokens in final_tokens_distribution:\n            self.add_span_to_context(span.file_path, span.span_id, tokens)\n            sum_tokens += tokens\n\n        logger.info(\n            f\"Added {len(final_tokens_distribution)} spans with {sum_tokens} tokens\"\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::18"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::19",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 318,
          "span_ids": [
            "FileContext.expand_context_with_init_spans",
            "FileContext.expand_context_with_related_spans",
            "FileContext.expand_small_classes"
          ],
          "start_line": 655,
          "end_line": 701,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n\n    def expand_context_with_init_spans(self):\n        for file in self._file_context.values():\n            file.expand_context_with_init_spans()\n\n    def expand_small_classes(self, max_tokens: int):\n        for file in self._file_context.values():\n            file.expand_small_classes(max_tokens)\n\n    def expand_context_with_related_spans(\n        self, max_tokens: int, set_tokens: bool = False\n    ):\n        # Add related spans if context allows it\n        if self.context_size() > max_tokens:\n            return\n\n        spans = []\n        for file in self._file_context.values():\n            if not file.file.supports_codeblocks:\n                continue\n            if not file.span_ids:\n                continue\n\n            for span in file.spans:\n                spans.append((file, span))\n\n        spans.sort(key=lambda x: x[1].tokens or 0, reverse=True)\n\n        for file, span in spans:\n            span_id = span.span_id\n            related_span_ids = file.module.find_related_span_ids(span_id)\n\n            for related_span_id in related_span_ids:\n                if related_span_id in file.span_ids:\n                    continue\n\n                related_span = file.module.find_span_by_id(related_span_id)\n\n                tokens = max(related_span.tokens, span.tokens or 0)\n                if tokens + self.context_size() > max_tokens:\n                    return spans\n\n                if set_tokens:\n                    file.add_span(related_span_id, tokens=tokens)\n                else:\n                    file.add_span(related_span_id)\n\n        return spans",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::19"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::20",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 192,
          "span_ids": [
            "FileContext.strip_line_breaks_only",
            "FileContext.save",
            "FileContext.reset",
            "FileContext.context_size",
            "FileContext.save_file",
            "FileContext.get_context_file"
          ],
          "start_line": 703,
          "end_line": 727,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n\n    def get_context_file(self, file_path: str) -> Optional[ContextFile]:\n        if file_path not in self._file_context:\n            file = self._repo.get_file(file_path)\n            if not file:\n                return None\n            self._file_context[file_path] = ContextFile(\n                file=self._repo.get_file(file_path), spans=[]\n            )\n\n        return self._file_context[file_path]\n\n    def context_size(self):\n        return sum(file.context_size() for file in self._file_context.values())\n\n    def save_file(self, file_path: str, updated_content: Optional[str] = None):\n        self._repo.save_file(file_path, updated_content)\n\n    def save(self):\n        self._repo.save()\n\n    def reset(self):\n        self._file_context = {}\n\n    def strip_line_breaks_only(self, text):\n        return text.lstrip(\"\\n\\r\").rstrip(\"\\n\\r\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::20"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/file_context.py::21",
        "metadata": {
          "file_path": "moatless\\file_context.py",
          "file_name": "file_context.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 127,
          "span_ids": [
            "FileContext.create_prompt"
          ],
          "start_line": 729,
          "end_line": 748,
          "community": null
        },
        "content": "class FileContext(BaseModel):\n\n    def create_prompt(\n        self,\n        show_span_ids=False,\n        show_line_numbers=False,\n        exclude_comments=False,\n        show_outcommented_code=False,\n        outcomment_code_comment: str = \"...\",\n    ):\n        file_context_content = \"\"\n        for file in self._file_context.values():\n            content = file.to_prompt(\n                show_span_ids,\n                show_line_numbers,\n                exclude_comments,\n                show_outcommented_code,\n                outcomment_code_comment,\n            )\n            file_context_content += \"\\n\\n\" + content\n        return self.strip_line_breaks_only(file_context_content)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/file_context.py::21"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/__init__.py::1",
        "metadata": {
          "file_path": "moatless\\find\\__init__.py",
          "file_name": "__init__.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 32,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 4,
          "community": null
        },
        "content": "from moatless.find.search import SearchCode\nfrom moatless.find.identify import IdentifyCode\nfrom moatless.find.decide import DecideRelevance",
        "summary": null,
        "ctxt_list": [],
        "id": "find/__init__.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/decide.py::1",
        "metadata": {
          "file_path": "moatless\\find\\decide.py",
          "file_name": "decide.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 403,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 45,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\nfrom moatless.find import SearchCode\nfrom moatless.state import AgenticState\nfrom moatless.types import (\n    ActionRequest,\n    ActionResponse,\n    Message,\n    UserMessage,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nMAYBE_FINISH_SYSTEM_PROMPT = \"\"\"You will be provided a reported issue and the file context containing existing code from the project's git repository. \nYour task is to make a decision if the code related to a reported issue is provided in the file context. \n\n# Input Structure:\n\n* <issue>: Contains the reported issue.\n* <file_context>: The file context.\n\nInstructions:\n\n * Analyze the Issue:\n   * Review the reported issue to understand what functionality or bug fix is being requested.\n\n * Analyze File Context:\n  * Examine the provided file context to identify if the relevant code for the reported issue is present.\n  * If the issue suggests that code should be implemented and doesn't yet exist in the code, consider the task completed if relevant code is found that would be modified to implement the new functionality.\n  * If relevant code in the file context points to other parts of the codebase not included, note these references.\n\n * Make a Decision:\n  * Decide if the relevant code is found in the file context.\n  * If you believe all existing relevant code is identified, mark the task as complete.\n  * If the specific method or code required to fix the issue is not present, still mark the task as complete as long as the relevant class or area for modification is identified.\n  * If you believe more relevant code can be identified, mark the task as not complete and provide your suggestions on how to find the relevant code.\n\nImportant:\n * You CANNOT change the codebase. DO NOT modify or suggest changes to any code.\n * Your task is ONLY to determine if the file context is complete. Do not go beyond this scope.\n\"\"\"",
        "summary": null,
        "ctxt_list": [],
        "id": "find/decide.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/decide.py::2",
        "metadata": {
          "file_path": "moatless\\find\\decide.py",
          "file_name": "decide.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 142,
          "span_ids": [
            "Decision"
          ],
          "start_line": 48,
          "end_line": 68,
          "community": null
        },
        "content": "class Decision(ActionRequest):\n    \"\"\"Provide your decision if all relevant file context is provided.\"\"\"\n\n    scratch_pad: str = Field(\n        description=\"Your thoughts on if the spans where relevant or not and if you found all relevant spans and can finish..\"\n    )\n\n    relevant: bool = Field(\n        default=False,\n        description=\"Set to true if the relevant code have been identified.\",\n    )\n\n    complete: bool = Field(\n        default=False,\n        description=\"Set to true if all the relevant code have been identified.\",\n    )\n\n    search_suggestions: Optional[str] = Field(\n        None,\n        description=\"Suggestions on how to find the relevant code not found in the file context.\",\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "find/decide.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/decide.py::3",
        "metadata": {
          "file_path": "moatless\\find\\decide.py",
          "file_name": "decide.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 377,
          "span_ids": [
            "DecideRelevance._relevant_count",
            "DecideRelevance._last_scratch_pad",
            "DecideRelevance._execute_action",
            "DecideRelevance.action_type",
            "DecideRelevance.system_prompt",
            "DecideRelevance"
          ],
          "start_line": 71,
          "end_line": 126,
          "community": null
        },
        "content": "class DecideRelevance(AgenticState):\n    expand_context: bool = Field(\n        False,\n        description=\"If true, the file context will be expanded with additional context.\",\n    )\n    finish_after_relevant_count: int = Field(\n        2,\n        description=\"Finish the task after this many relevant decisions have been made but not complete.\",\n    )\n    max_prompt_file_tokens: int = Field(\n        4000,\n        description=\"The maximum number of tokens to include in the file context prompt.\",\n    )\n\n    def _execute_action(self, action: Decision) -> ActionResponse:\n        if action.complete and action.relevant:\n            return ActionResponse.transition(\"finish\")\n\n        if (\n            action.relevant\n            and self._relevant_count() >= self.finish_after_relevant_count\n        ):\n            return ActionResponse.transition(\"finish\")\n\n        return ActionResponse.transition(\n            \"search\",\n            output={\"message\": action.search_suggestions},\n        )\n\n    def _relevant_count(self) -> int:\n        \"\"\"\n        Count the number of times a decision was made that the file context was relevant.\n        \"\"\"\n        relevant_count = 0\n        previous_states = self.get_previous_states(self)\n        for previous_state in previous_states:\n            if (\n                previous_state.last_action\n                and previous_state.last_action.request.relevant\n            ):\n                relevant_count += 1\n        return relevant_count\n\n    def action_type(self) -> type[BaseModel] | None:\n        return Decision\n\n    def system_prompt(self) -> str:\n        return MAYBE_FINISH_SYSTEM_PROMPT\n\n    def _last_scratch_pad(self):\n        previous_states = self.get_previous_states()\n        if previous_states and previous_states[-1].last_action:\n            last_action = previous_states[-1].last_action\n            return last_action.request.scratch_pad\n        else:\n            return None",
        "summary": null,
        "ctxt_list": [],
        "id": "find/decide.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/decide.py::4",
        "metadata": {
          "file_path": "moatless\\find\\decide.py",
          "file_name": "decide.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 218,
          "span_ids": [
            "DecideRelevance.messages"
          ],
          "start_line": 128,
          "end_line": 166,
          "community": null
        },
        "content": "class DecideRelevance(AgenticState):\n\n    def messages(self) -> list[Message]:\n        messages: list[Message] = []\n\n        if self.expand_context:\n            self.file_context.expand_context_with_init_spans()\n            self.file_context.expand_context_with_related_spans(\n                max_tokens=self.max_prompt_file_tokens\n            )\n            self.file_context.expand_small_classes(\n                max_tokens=self.max_prompt_file_tokens\n            )\n\n        file_context_str = self.file_context.create_prompt(\n            show_span_ids=False,\n            show_line_numbers=False,\n            exclude_comments=True,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"... rest of the code\",\n        )\n\n        content = f\"\"\"<issue>\n{self.initial_message}\n</issue>\n\"\"\"\n\n        scratch_pad = self._last_scratch_pad()\n        if scratch_pad:\n            content += f\"\"\"<scratch_pad>\n{scratch_pad}\n</scratch_pad>\"\"\"\n\n        content += f\"\"\"\n<file_context>\n{file_context_str}\n</file_context>\n\"\"\"\n\n        messages.append(UserMessage(content=content))\n        return messages",
        "summary": null,
        "ctxt_list": [],
        "id": "find/decide.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/find_code_snippet.py::1",
        "metadata": {
          "file_path": "moatless\\find\\find_code_snippet.py",
          "file_name": "find_code_snippet.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 224,
          "span_ids": [
            "imports",
            "find_code_snippet_in_files"
          ],
          "start_line": 1,
          "end_line": 37,
          "community": null
        },
        "content": "import logging\nimport os\n\nlogger = logging.getLogger(__name__)\n\nignored_dirs = [\"target\", \"node_modules\", \".git\", \".idea\"]\n\n\ndef find_code_snippet_in_files(repo_dir: str, code_snippet: str):\n    occurrences = []\n\n    for root, _dirs, files in os.walk(repo_dir):\n        for file in files:\n            if any(dir in root for dir in ignored_dirs):\n                continue\n\n            file_path = os.path.join(root, file)\n            if not file_path.endswith(\".java\"):\n                continue\n            try:\n                with open(file_path, encoding=\"utf-8\") as f:\n                    for line_number, line in enumerate(f, start=1):\n                        if code_snippet.lower() in line.lower():\n                            relative_path = os.path.relpath(file_path, repo_dir)\n                            occurrences.append(\n                                (\n                                    relative_path,\n                                    line_number,\n                                    line.strip(),\n                                )\n                            )\n            except Exception as e:\n                if \"invalid\" not in str(e):\n                    logger.error(f\"Could not read file {file_path}: {e}\")\n\n    return occurrences",
        "summary": null,
        "ctxt_list": [],
        "id": "find/find_code_snippet.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/identify.py::1",
        "metadata": {
          "file_path": "moatless\\find\\identify.py",
          "file_name": "identify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 548,
          "span_ids": [
            "imports",
            "Identify"
          ],
          "start_line": 1,
          "end_line": 64,
          "community": null
        },
        "content": "import fnmatch\nimport logging\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\nfrom moatless.file_context import RankedFileSpan\nfrom moatless.state import AgenticState\nfrom moatless.types import (\n    ActionRequest,\n    ActionResponse,\n    FileWithSpans,\n    Message,\n    UserMessage,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nIDENTIFY_SYSTEM_PROMPT = \"\"\"You are an autonomous AI assistant tasked with finding relevant code in an existing \ncodebase based on a reported issue. Your task is to identify the relevant code spans in the provided search \nresults and decide whether the search task is complete.\n\n# Input Structure:\n\n* <issue>: Contains the reported issue.\n* <file_context>: Contains the context of already identified files and code spans.\n* <search_results>: Contains the new search results with code divided into \"code spans\".\n\n# Your Task:\n\n1. Analyze User Instructions:\nCarefully read the reported issue within the <issue> tag.\n\n2. Review Current Context:\nExamine the current file context provided in the <file_context> tag to understand already identified relevant files.\n\n3. Process New Search Results:\n3.1. Thoroughly analyze each code span in the <search_results> tag.\n3.2. Match the code spans with the key elements, functions, variables, or patterns identified in the reported issue.\n3.3. Evaluate the relevance of each code span based on how well it aligns with the reported issue and current file context.\n3.4. If the issue suggests new functions or classes, identify the existing code that might be relevant to be able to implement the new functionality.\n3.5. Review entire sections of code, not just isolated spans, to ensure you have a complete understanding before making a decision. It's crucial to see all code in a section to accurately determine relevance and completeness.\n3.6. Verify if there are references to other parts of the codebase that might be relevant but not found in the search results. \n3.7. Identify and extract relevant code spans based on the reported issue. \n\n4. Respond Using the Function:\nUse the Identify function to provide your response.\n\nThink step by step and write out your thoughts in the scratch_pad field.\n\"\"\"\n\n\nclass Identify(ActionRequest):\n    \"\"\"Identify if the provided search result is relevant to the reported issue.\"\"\"\n\n    scratch_pad: str = Field(\n        description=\"Your thoughts on how to identify the relevant code and why.\"\n    )\n\n    identified_spans: Optional[list[FileWithSpans]] = Field(\n        default=None,\n        description=\"Files and code spans in the search results identified as relevant to the reported issue.\",\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "find/identify.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/identify.py::2",
        "metadata": {
          "file_path": "moatless\\find\\identify.py",
          "file_name": "identify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 117,
          "span_ids": [
            "IdentifyCode",
            "IdentifyCode.model_dump"
          ],
          "start_line": 67,
          "end_line": 83,
          "community": null
        },
        "content": "class IdentifyCode(AgenticState):\n    ranked_spans: Optional[list[RankedFileSpan]] = Field(\n        default=None, description=\"Ranked file spans from the search results.\"\n    )\n\n    expand_context: bool = Field(\n        default=False,\n        description=\"Whether to expand the search result with relevant code spans.\",\n    )\n\n    max_prompt_file_tokens: int = Field(\n        default=4000,\n        description=\"The maximum number of tokens to include in the prompt.\",\n    )\n\n    def model_dump(self, **kwargs):\n        return super().model_dump(**kwargs)",
        "summary": null,
        "ctxt_list": [],
        "id": "find/identify.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/identify.py::3",
        "metadata": {
          "file_path": "moatless\\find\\identify.py",
          "file_name": "identify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 229,
          "span_ids": [
            "IdentifyCode.system_prompt",
            "IdentifyCode.action_type",
            "IdentifyCode._execute_action"
          ],
          "start_line": 85,
          "end_line": 112,
          "community": null
        },
        "content": "class IdentifyCode(AgenticState):\n\n    def _execute_action(self, action: Identify) -> ActionResponse:\n        if action.identified_spans:\n            self.file_context.add_files_with_spans(action.identified_spans)\n\n            span_count = sum([len(file.span_ids) for file in action.identified_spans])\n            logger.info(\n                f\"Identified {span_count} spans in {len(action.identified_spans)} files. Current file context size is {self.file_context.context_size()} tokens.\"\n            )\n\n            return ActionResponse.transition(\"finish\")\n        else:\n            logger.info(\"No spans identified.\")\n\n        message = f\"The search returned {len(self.ranked_spans)} results. But unfortunately, I didn't find any of the search results relevant to the query.\"\n\n        message += \"\\n\\n\"\n        message += action.scratch_pad\n\n        return ActionResponse.transition(\n            \"search\",\n            output={\"message\": message},\n        )\n\n    def action_type(self) -> type[BaseModel] | None:\n        return Identify\n\n    def system_prompt(self) -> str:\n        return IDENTIFY_SYSTEM_PROMPT",
        "summary": null,
        "ctxt_list": [],
        "id": "find/identify.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/identify.py::4",
        "metadata": {
          "file_path": "moatless\\find\\identify.py",
          "file_name": "identify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 395,
          "span_ids": [
            "IdentifyCode.messages",
            "is_test_pattern"
          ],
          "start_line": 114,
          "end_line": 181,
          "community": null
        },
        "content": "class IdentifyCode(AgenticState):\n\n    def messages(self) -> list[Message]:\n        messages: list[Message] = []\n\n        file_context = self.create_file_context(max_tokens=self.max_prompt_file_tokens)\n        file_context.add_ranked_spans(self.ranked_spans)\n\n        if file_context.files:\n            file_context.expand_context_with_init_spans()\n\n            if self.expand_context:\n                file_context.expand_context_with_related_spans(\n                    max_tokens=self.max_prompt_file_tokens, set_tokens=True\n                )\n                file_context.expand_small_classes(\n                    max_tokens=self.max_prompt_file_tokens\n                )\n\n            search_result_str = file_context.create_prompt(\n                show_span_ids=True,\n                show_line_numbers=False,\n                exclude_comments=True,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"... rest of the code\",\n            )\n        else:\n            search_result_str = \"No new search results found.\"\n\n        if self.file_context.files:\n            file_context_str = self.file_context.create_prompt(\n                show_span_ids=True,\n                show_line_numbers=False,\n                exclude_comments=True,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"... rest of the code\",\n            )\n        else:\n            file_context_str = \"No relevant code identified yet.\"\n\n        content = f\"\"\"<issue>\n{self.initial_message}\n</issue>\n\n<file_context>\n{file_context_str}\n</file_context>\n\n<search_results>\n{search_result_str}\n</search_results>\n\"\"\"\n\n        messages.append(UserMessage(content=content))\n        return messages\n\n\ndef is_test_pattern(file_pattern: str):\n    test_patterns = [\"test_*.py\", \"/tests/\"]\n    for pattern in test_patterns:\n        if pattern in file_pattern:\n            return True\n\n    if file_pattern.startswith(\"test\"):\n        return True\n\n    test_patterns = [\"test_*.py\"]\n\n    return any(fnmatch.filter([file_pattern], pattern) for pattern in test_patterns)",
        "summary": null,
        "ctxt_list": [],
        "id": "find/identify.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::1",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 735,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 108,
          "community": null
        },
        "content": "import fnmatch\nimport logging\nfrom typing import Optional\n\nimport instructor\nfrom pydantic import BaseModel, Field, model_validator, ValidationError\n\nfrom moatless.file_context import RankedFileSpan\nfrom moatless.index.types import SearchCodeHit\nfrom moatless.state import ActionResponse, AgenticState\nfrom moatless.types import (\n    ActionRequest,\n    AssistantMessage,\n    Message,\n    UserMessage,\n)\nfrom moatless.utils.llm_utils import instructor_mode_by_model\n\nlogger = logging.getLogger(__name__)\n\n\nSEARCH_SYSTEM_PROMPT = \"\"\"You are an autonomous AI assistant.\nYour task is to locate the code relevant to an issue.\n\n# Instructions:\n\n1. Understand The Issue:\nRead the <issue> tag to understand the issue.\n\n2. Review Current File Context:\nExamine the <file_context> tag to see which files and code spans have already been identified.\nIf you believe that all relevant files have been identified, you can finish the search by setting complete to true.\n\n3. Consider the Necessary Search Parameters:\nDetermine if specific file types, directories, function or class names or code patterns are mentioned in the issue.\nIf you can you should always try to specify the search parameters as accurately as possible.\nYou can do more than one search request at the same time so you can try different search parameters to cover all possible relevant code.\n\n4. Ensure At Least One Search Parameter:\nMake sure that at least one of query, code_snippet, class_name, or function_name is provided.\n\n5. Formulate the Search function:\nSet at least one of the search paramaters `query`, `code_snippet`, `class_name` or `function_name`.\n\n\n\n\"\"\"\n\n\nSEARCH_FUNCTIONS_FEW_SHOT_OPENAI_FUNC = \"\"\"\n6. Execute the Search function:\nUse the Search function with the search parameters and your thoughts on how to approach this task.\n\nThink step by step and write out your thoughts in the thoughts field.\n\nExamples:\n\nUser:\nThe file uploader intermittently fails with \"TypeError: cannot unpack non-iterable NoneType object\". This issue appears sporadically during high load conditions..\n\nAI Assistant:\nfunctions.Search({\n    query: \"File upload process to fix intermittent 'TypeError: cannot unpack non-iterable NoneType object'\",\n    file_pattern: \"**/uploader/**/*.py\"\n)\n\nUser:\nThere's a bug in the PaymentProcessor class where transactions sometimes fail to log correctly, resulting in missing transaction records.\n\nAI Assistant:\nfunctions.Search({\n    class_names: [\"PaymentProcessor\"]\n)\n\nUser:\nThe generate_report function sometimes produces incomplete reports under certain conditions. This function is part of the reporting module. Locate the generate_report function in the reports directory to debug and fix the issue.\n\nAI Assistant:\nfunctions.Search({\n    function_names: [\"generate_report\"],\n    file_pattern: \"**/reports/**/*.py\"\n)\n\nUser:\nThe extract_data function in HTMLParser throws an \"AttributeError: 'NoneType' object has no attribute 'find'\" error when parsing certain HTML pages.\n\nAI Assistant:\nfunctions.Search({\n    class_names: [\"HTMLParser\"],\n    function_names: [\"extract_data\"]\n)\n\nUser:\nThe database connection setup is missing SSL configuration, causing insecure connections.\n\nHere's the stack trace of the error:\n\nFile \"/opt/app/db_config/database.py\", line 45, in setup_connection\n    engine = create_engine(DATABASE_URL)\nFile \"/opt/app/db_config/database.py\", line 50, in <module>\n    connection = setup_connection()\n\nAI Assistant:\nfunctions.Search({\n    code_snippet: \"engine = create_engine(DATABASE_URL)\",\n    file_pattern: \"db_config/database.py\"\n)\n\"\"\"",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::2",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 372,
          "span_ids": [
            "impl:7"
          ],
          "start_line": 110,
          "end_line": 162,
          "community": null
        },
        "content": "SEARCH_FUNCTIONS_FEW_SHOT = \"\"\"6. Execute the Search function:\nUse the Search function with the search parameters and your thoughts on how to approach this task.\n\nThink step by step and write out your thoughts in the scratch_pad field.\n\nExamples:\n\nUser:\nThe file uploader intermittently fails with \"TypeError: cannot unpack non-iterable NoneType object\". This issue appears sporadically during high load conditions..\n\nSearch parameters:\n    query: \"File upload process to fix intermittent 'TypeError: cannot unpack non-iterable NoneType object'\",\n    file_pattern: \"**/uploader/**/*.py\"\n\n\nUser:\nThere's a bug in the PaymentProcessor class where transactions sometimes fail to log correctly, resulting in missing transaction records.\n\nSearch parameters:\n    class_names: [\"PaymentProcessor\"]\n\n\nUser:\nThe generate_report function sometimes produces incomplete reports under certain conditions. This function is part of the reporting module. Locate the generate_report function in the reports directory to debug and fix the issue.\n\nSearch parameters:\n    function_names: [\"generate_report\"]\n    file_pattern: \"**/reports/**/*.py\"\n\n\nUser:\nThe extract_data function in HTMLParser throws an \"AttributeError: 'NoneType' object has no attribute 'find'\" error when parsing certain HTML pages.\n\nSearch parameters:\n    class_names: [\"HTMLParser\"]\n    function_names: [\"extract_data\"]\n\n\nUser:\nThe database connection setup is missing SSL configuration, causing insecure connections.\n\nHere's the stack trace of the error:\n\nFile \"/opt/app/db_config/database.py\", line 45, in setup_connection\n    engine = create_engine(DATABASE_URL)\nFile \"/opt/app/db_config/database.py\", line 50, in <module>\n    connection = setup_connection()\n\nSearch parameters:\n    code_snippet: \"engine = create_engine(DATABASE_URL)\",\n    file_pattern: \"db_config/database.py\"\n\n\"\"\"",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::3",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 617,
          "span_ids": [
            "impl:7",
            "impl:11"
          ],
          "start_line": 164,
          "end_line": 231,
          "community": null
        },
        "content": "SEARCH_JSON_FEW_SHOT = \"\"\"6. Execute the Search:\nExecute the search by providing the search parameters and your thoughts on how to approach this task in a JSON object. \n\nThink step by step and write out your thoughts in the scratch_pad field.\n\nExamples:\n\nUser:\nThe file uploader intermittently fails with \"TypeError: cannot unpack non-iterable NoneType object\". This issue appears sporadically during high load conditions..\n\nAssistant:\n{\n \"scratch_pad\": \"The error indicates that a variable expected to be iterable is None, which might be happening due to race conditions or missing checks under high load. Investigate the file upload logic to ensure all necessary checks are in place and improve concurrency handling.\",\n \"file_pattern\": \"**/uploader/**/*.py\",\n \"query\": \"TypeError: cannot unpack non-iterable NoneType object\"\n}\n\nUser:\nThere's a bug in the PaymentProcessor class where transactions sometimes fail to log correctly, resulting in missing transaction records.\n\nAssistant:\n{\n  \"scratch_pad\": \"Missing transaction logs can cause significant issues in tracking payments. The problem may be related to how the logging mechanism handles transaction states or errors. Investigate the PaymentProcessor class, focusing on the transaction logging part.\",\n  \"class_name\": \"PaymentProcessor\",\n  \"query\": \"transactions fail to log correctly\"\n}\n\nUser:\nThe generate_report function sometimes produces incomplete reports under certain conditions. This function is part of the reporting module. Locate the generate_report function in the reports directory to debug and fix the issue.\n\nAssistant:\n{\n  \"scratch_pad\": \"Incomplete reports suggest that the function might be encountering edge cases or unhandled exceptions that disrupt the report generation. Reviewing the function's logic and error handling in the reporting module is necessary.\",\n  \"function_name\": \"generate_report\",\n  \"file_pattern\": \"**/reports/**/*.py\",\n}\n\nUser:\nThe extract_data function in HTMLParser throws an \"AttributeError: 'NoneType' object has no attribute 'find'\" error when parsing certain HTML pages.\n\nAssistant:\n{\n  \"scratch_pad\": \"The error occurs when 'find' is called on a NoneType object, suggesting that the HTML structure might not match expected patterns. \",\n  \"class_name\": \"HTMLParser\",\n  \"function_name\": \"extract_data\",\n}\n\n\nUser:\nThe database connection setup is missing SSL configuration, causing insecure connections.\n\nHere's the stack trace of the error:\n\nFile \"/opt/app/db_config/database.py\", line 45, in setup_connection\n    engine = create_engine(DATABASE_URL)\nFile \"/opt/app/db_config/database.py\", line 50, in <module>\n    connection = setup_connection()\n\nAssistant:\n{\n  \"scratch_pad\": \"The missing SSL configuration poses a security risk by allowing unencrypted connections. Find the code snippet `engine = create_engine(DATABASE_URL)` provided in the issue.\",\n  \"code_snippet\": \"engine = create_engine(DATABASE_URL)\",\n}\n\"\"\"\n\nIGNORE_TEST_PROMPT = (\n    \"Test files are not in the search scope. Ignore requests to search for tests. \"\n)",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::4",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 235,
          "span_ids": [
            "SearchRequest",
            "SearchRequest.validate_search_requests",
            "SearchRequest.has_search_attributes"
          ],
          "start_line": 234,
          "end_line": 272,
          "community": null
        },
        "content": "class SearchRequest(BaseModel):\n    file_pattern: Optional[str] = Field(\n        default=None,\n        description=\"A glob pattern to filter search results to specific file types or directories. \",\n    )\n\n    query: Optional[str] = Field(\n        default=None,\n        description=\"A semantic similarity search query. Use natural language to describe what you are looking for.\",\n    )\n\n    code_snippet: Optional[str] = Field(\n        default=None,\n        description=\"Specific code snippet to that should be exactly matched.\",\n    )\n\n    class_names: list[str] = Field(\n        default=[], description=\"Specific class names to include in the search.\"\n    )\n\n    function_names: list[str] = Field(\n        default=[], description=\"Specific function names to include in the search.\"\n    )\n\n    def has_search_attributes(self):\n        return any(\n            [\n                self.query,\n                self.code_snippet,\n                self.class_names,\n                self.function_names,\n            ]\n        )\n\n    @model_validator(mode='after')\n    def validate_search_requests(self):\n        if not self.has_search_attributes:\n            raise ValueError(\"A search request must have at least one attribute set.\")\n        return self",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::5",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 150,
          "span_ids": [
            "Search.validate_search_requests",
            "Search"
          ],
          "start_line": 274,
          "end_line": 295,
          "community": null
        },
        "content": "class Search(ActionRequest):\n    \"\"\"Take action to search for code, identify found and finish up.\"\"\"\n\n    scratch_pad: str = Field(\n        description=\"Scratch pad for the search. Use this to write down your thoughts on how to approach the search.\"\n    )\n\n    search_requests: list[SearchRequest] = Field(\n        default=[],\n        description=\"List of search requests.\",\n    )\n\n    complete: Optional[bool] = Field(\n        default=False, description=\"Set to true when the search is complete.\"\n    )\n\n    @model_validator(mode='after')\n    def validate_search_requests(self):\n        if not self.complete:\n            if not self.search_requests:\n                raise ValueError(\"At least one search request must exist.\")\n        return self",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::6",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 166,
          "span_ids": [
            "SearchCode"
          ],
          "start_line": 298,
          "end_line": 324,
          "community": null
        },
        "content": "class SearchCode(AgenticState):\n    message: Optional[str] = Field(\n        None,\n        description=\"Message to the search\",\n    )\n\n    max_search_results: int = Field(\n        25,\n        description=\"The maximum number of search results.\",\n    )\n\n    max_retries_with_any_file_context: int = Field(\n        3,\n        description=\"The maximum number of retries when there are identified files in file context.\",\n    )\n\n    include_message_history: bool = Field(\n        True,\n        description=\"Include message history from previous iterations\",\n    )\n\n    provide_initial_context: bool = True\n    initial_context_tokens: int = 4000\n    initial_search_results: int = 50\n    initial_context_spans_per_file: int = 5\n\n    support_test_files: bool = False",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::7",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 373,
          "span_ids": [
            "SearchCode._execute_action"
          ],
          "start_line": 326,
          "end_line": 380,
          "community": null
        },
        "content": "class SearchCode(AgenticState):\n\n    def _execute_action(self, action: Search) -> ActionResponse:\n        if action.complete:\n            return ActionResponse.transition(\n                \"finish\",\n                output={\n                    \"message\": action.scratch_pad,\n                },\n            )\n\n        if isinstance(action, Search):\n            for request in action.search_requests:\n                if (\n                    not self.support_test_files\n                    and request.file_pattern\n                    and is_test_pattern(request.file_pattern)\n                ):\n                    return self._retry(\"It's not possible to search for test files.\")\n\n        message = \"\"\n        search_result: list[SearchCodeHit] = []\n        for search_request in action.search_requests:\n            search_response = self.workspace.code_index.search(\n                file_pattern=search_request.file_pattern,\n                query=search_request.query,\n                code_snippet=search_request.code_snippet,\n                class_names=search_request.class_names,\n                function_names=search_request.function_names,\n                max_results=int(self.max_search_results / len(action.search_requests)),\n            )\n            search_result.extend(search_response.hits)\n            message += \"\\n\" + search_response.message\n\n        logger.info(f\"Found {len(search_result)} hits.\")\n\n        ranked_spans = []\n        for hit in search_result:\n            for span in hit.spans:\n                ranked_spans.append(\n                    RankedFileSpan(\n                        file_path=hit.file_path,\n                        span_id=span.span_id,\n                        rank=span.rank,\n                        tokens=span.tokens,\n                    )\n                )\n\n        if len(ranked_spans) == 0:\n            logger.info(\"No search results found. Will retry.\")\n            message = \"\\n\\nUnfortunately, I didn't find any relevant results.\"\n            return self._retry(message)\n\n        return ActionResponse.transition(\n            trigger=\"did_search\",\n            output={\"ranked_spans\": ranked_spans},\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::8",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 223,
          "span_ids": [
            "SearchCode._retry",
            "SearchCode.action_type",
            "SearchCode.system_prompt"
          ],
          "start_line": 382,
          "end_line": 410,
          "community": null
        },
        "content": "class SearchCode(AgenticState):\n\n    def _retry(self, message: str) -> ActionResponse:\n        if (\n            self.retries() > self.max_retries_with_any_file_context\n            and self.file_context.files\n        ):\n            logger.info(\n                \"Exceeded max retries, will finish as there are identified files in the file context. Transitioning to finish.\"\n            )\n            return ActionResponse.transition(\"finish\")\n        else:\n            return ActionResponse.retry(message)\n\n    def action_type(self) -> type[BaseModel] | None:\n        return Search\n\n    def system_prompt(self) -> str:\n        system_prompt = SEARCH_SYSTEM_PROMPT\n\n        instructor_mode = instructor_mode_by_model(self.model)\n        if instructor_mode == instructor.Mode.JSON:\n            system_prompt += SEARCH_JSON_FEW_SHOT\n        elif self.model.startswith(\"openai\"):\n            system_prompt += SEARCH_FUNCTIONS_FEW_SHOT_OPENAI_FUNC\n        else:\n            system_prompt += SEARCH_FUNCTIONS_FEW_SHOT\n\n        if not self.support_test_files:\n            system_prompt += IGNORE_TEST_PROMPT\n        return system_prompt",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "find/search.py::9",
        "metadata": {
          "file_path": "moatless\\find\\search.py",
          "file_name": "search.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 482,
          "span_ids": [
            "SearchCode.messages",
            "is_test_pattern"
          ],
          "start_line": 412,
          "end_line": 486,
          "community": null
        },
        "content": "class SearchCode(AgenticState):\n\n    def messages(self) -> list[Message]:\n        messages: list[Message] = []\n\n        content = f\"<issue>\\n{self.initial_message}\\n</issue>\"\n\n        if self.provide_initial_context:\n            logger.info(\"Search for initial context to provide in the prompt\")\n            result = self.workspace.code_index.semantic_search(\n                query=self.initial_message,\n                exact_match_if_possible=False,\n                max_spans_per_file=5,\n                max_results=100,\n            )\n\n            file_context = self.create_file_context(max_tokens=4000)\n\n            for hit in result.hits:\n                for span in hit.spans:\n                    file_context.add_span_to_context(\n                        hit.file_path, span.span_id, tokens=1\n                    )\n\n            content += \"\\n\\nHere's some files that might be relevant when formulating the search.\\n\"\n            content += file_context.create_prompt(\n                show_span_ids=False,\n                show_line_numbers=False,\n                exclude_comments=True,\n                show_outcommented_code=False,\n            )\n\n        previous_states = self.get_previous_states(self)\n        for previous_state in previous_states:\n            if previous_state.message:\n                content += previous_state.message\n            messages.append(UserMessage(content=content))\n            messages.append(\n                AssistantMessage(\n                    action=previous_state.last_action.request,\n                )\n            )\n            content = \"\"\n\n        if self.message:\n            content += f\"\\n\\n{self.message}\\n\"\n\n        if self.file_context.files:\n            file_context_str = self.file_context.create_prompt(\n                exclude_comments=True,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"... rest of the code\",\n            )\n        else:\n            file_context_str = \"No files found yet.\"\n\n        content += f\"\\n\\n<file_context>\\n{file_context_str}\\n</file_context>\"\n\n        messages.append(UserMessage(content=content))\n        messages.extend(self.retry_messages())\n\n        return messages\n\n\ndef is_test_pattern(file_pattern: str):\n    test_patterns = [\"test_*.py\", \"/tests/\"]\n    for pattern in test_patterns:\n        if pattern in file_pattern:\n            return True\n\n    if file_pattern.startswith(\"test\"):\n        return True\n\n    test_patterns = [\"test_*.py\"]\n\n    return any(fnmatch.filter([file_pattern], pattern) for pattern in test_patterns)",
        "summary": null,
        "ctxt_list": [],
        "id": "find/search.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/__init__.py::1",
        "metadata": {
          "file_path": "moatless\\index\\__init__.py",
          "file_name": "__init__.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 35,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 4,
          "community": null
        },
        "content": "from moatless.index.code_index import CodeIndex\nfrom moatless.index.settings import IndexSettings\nfrom moatless.index.simple_faiss import SimpleFaissVectorStore",
        "summary": null,
        "ctxt_list": [],
        "id": "index/__init__.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::1",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 354,
          "span_ids": [
            "imports",
            "default_vector_store"
          ],
          "start_line": 1,
          "end_line": 51,
          "community": null
        },
        "content": "import fnmatch\nimport json\nimport logging\nimport mimetypes\nimport os\nimport shutil\nimport tempfile\nfrom typing import Optional\n\nimport requests\nfrom llama_index.core import SimpleDirectoryReader\nfrom llama_index.core.base.embeddings.base import BaseEmbedding\nfrom llama_index.core.ingestion import DocstoreStrategy, IngestionPipeline\nfrom llama_index.core.storage import docstore\nfrom llama_index.core.storage.docstore import DocumentStore, SimpleDocumentStore\nfrom llama_index.core.vector_stores.types import (\n    BasePydanticVectorStore,\n    FilterCondition,\n    MetadataFilter,\n    MetadataFilters,\n    VectorStoreQuery,\n)\nfrom rapidfuzz import fuzz\n\nfrom moatless.codeblocks import CodeBlock, CodeBlockType\nfrom moatless.index.embed_model import get_embed_model\nfrom moatless.index.epic_split import EpicSplitter\nfrom moatless.index.settings import IndexSettings\nfrom moatless.index.simple_faiss import SimpleFaissVectorStore\nfrom moatless.index.types import (\n    CodeSnippet,\n    SearchCodeHit,\n    SearchCodeResponse,\n)\nfrom moatless.repository import FileRepository\nfrom moatless.types import FileWithSpans\nfrom moatless.utils.tokenizer import count_tokens\n\nlogger = logging.getLogger(__name__)\n\n\ndef default_vector_store(settings: IndexSettings):\n    try:\n        import faiss\n    except ImportError as e:\n        raise ImportError(\n            \"faiss needs to be installed to set up a default index for CodeIndex. Run 'pip install faiss-cpu'\"\n        ) from e\n\n    faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(settings.dimensions))\n    return SimpleFaissVectorStore(faiss_index)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::2",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 338,
          "span_ids": [
            "CodeIndex.__init__",
            "CodeIndex"
          ],
          "start_line": 54,
          "end_line": 88,
          "community": null
        },
        "content": "class CodeIndex:\n    def __init__(\n        self,\n        file_repo: FileRepository,\n        index_name: Optional[str] = None,\n        vector_store: BasePydanticVectorStore | None = None,\n        docstore: DocumentStore | None = None,\n        embed_model: BaseEmbedding | None = None,\n        blocks_by_class_name: Optional[dict] = None,\n        blocks_by_function_name: Optional[dict] = None,\n        settings: IndexSettings | None = None,\n        max_results: int = 25,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n    ):\n        self._index_name = index_name\n        self._settings = settings or IndexSettings()\n\n        self.max_results = max_results\n        self.max_hits_without_exact_match = max_hits_without_exact_match\n        self.max_exact_results = max_exact_results\n\n        self._file_repo = file_repo\n\n        self._blocks_by_class_name = blocks_by_class_name or {}\n        self._blocks_by_function_name = blocks_by_function_name or {}\n\n        self._embed_model = embed_model or get_embed_model(self._settings.embed_model)\n        self._vector_store = vector_store or default_vector_store(self._settings)\n        self._docstore = docstore or SimpleDocumentStore()\n\n        logger.info(f\"Initiated CodeIndex {self._index_name} with:\\n\"\n                    f\" * {len(self._blocks_by_class_name)} classes\\n\"\n                    f\" * {len(self._blocks_by_function_name)} functions\\n\"\n                    f\" * {len(self._docstore.docs)} vectors\\n\")",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::3",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 251,
          "span_ids": [
            "CodeIndex.from_persist_dir"
          ],
          "start_line": 90,
          "end_line": 117,
          "community": null
        },
        "content": "class CodeIndex:\n\n    @classmethod\n    def from_persist_dir(cls, persist_dir: str, file_repo: FileRepository, **kwargs):\n        vector_store = SimpleFaissVectorStore.from_persist_dir(persist_dir)\n        docstore = SimpleDocumentStore.from_persist_dir(persist_dir)\n\n        settings = IndexSettings.from_persist_dir(persist_dir)\n\n        if os.path.exists(os.path.join(persist_dir, \"blocks_by_class_name.json\")):\n            with open(os.path.join(persist_dir, \"blocks_by_class_name.json\")) as f:\n                blocks_by_class_name = json.load(f)\n        else:\n            blocks_by_class_name = {}\n\n        if os.path.exists(os.path.join(persist_dir, \"blocks_by_function_name.json\")):\n            with open(os.path.join(persist_dir, \"blocks_by_function_name.json\")) as f:\n                blocks_by_function_name = json.load(f)\n        else:\n            blocks_by_function_name = {}\n\n        return cls(\n            file_repo=file_repo,\n            vector_store=vector_store,\n            docstore=docstore,\n            settings=settings,\n            blocks_by_class_name=blocks_by_class_name,\n            blocks_by_function_name=blocks_by_function_name,\n            **kwargs,\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::4",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 192,
          "span_ids": [
            "CodeIndex.from_url"
          ],
          "start_line": 119,
          "end_line": 142,
          "community": null
        },
        "content": "class CodeIndex:\n\n    @classmethod\n    def from_url(cls, url: str, persist_dir: str, file_repo: FileRepository):\n        try:\n            response = requests.get(url, stream=True)\n            response.raise_for_status()\n\n            with tempfile.TemporaryDirectory() as temp_dir:\n                temp_zip_file = os.path.join(temp_dir, url.split(\"/\")[-1])\n\n                with open(temp_zip_file, \"wb\") as data:\n                    for chunk in response.iter_content(chunk_size=8192):\n                        data.write(chunk)\n\n                shutil.unpack_archive(temp_zip_file, persist_dir)\n\n        except requests.exceptions.HTTPError as e:\n            logger.exception(f\"HTTP Error while fetching {url}\")\n            raise e\n        except Exception as e:\n            logger.exception(f\"Failed to download {url}\")\n            raise e\n\n        logger.info(f\"Downloaded existing index from {url}.\")\n        return cls.from_persist_dir(persist_dir, file_repo)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::5",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 238,
          "span_ids": [
            "CodeIndex.dict",
            "CodeIndex.from_index_name"
          ],
          "start_line": 144,
          "end_line": 169,
          "community": null
        },
        "content": "class CodeIndex:\n\n    @classmethod\n    def from_index_name(\n        cls,\n        index_name: str,\n        file_repo: FileRepository,\n        index_store_dir: Optional[str] = None,\n    ):\n        if not index_store_dir:\n            index_store_dir = os.getenv(\"INDEX_STORE_DIR\")\n\n        persist_dir = os.path.join(index_store_dir, index_name)\n        if os.path.exists(persist_dir):\n            logger.info(f\"Loading existing index {index_name} from {persist_dir}.\")\n            return cls.from_persist_dir(persist_dir, file_repo=file_repo)\n\n        if os.getenv(\"INDEX_STORE_URL\"):\n            index_store_url = os.getenv(\"INDEX_STORE_URL\")\n        else:\n            index_store_url = \"https://stmoatless.blob.core.windows.net/indexstore/20240522-voyage-code-2\"\n\n        store_url = os.path.join(index_store_url, f\"{index_name}.zip\")\n        logger.info(f\"Downloading existing index {index_name} from {store_url}.\")\n        return cls.from_url(store_url, persist_dir, file_repo)\n\n    def dict(self):\n        return {\"index_name\": self._index_name}",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::6",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 294,
          "span_ids": [
            "CodeIndex.search"
          ],
          "start_line": 171,
          "end_line": 218,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def search(\n        self,\n        query: Optional[str] = None,\n        code_snippet: Optional[str] = None,\n        class_names: list[str] = None,\n        function_names: list[str] = None,\n        file_pattern: Optional[str] = None,\n        max_results: int = 25,\n    ) -> SearchCodeResponse:\n        if class_names or function_names:\n            result = self.find_by_name(\n                class_names=class_names,\n                function_names=function_names,\n                file_pattern=file_pattern,\n            )\n\n            if len(result.hits) == 0 and class_names and function_names:\n                results = []\n                results.extend(\n                    self.find_by_name(\n                        class_names=class_names,\n                        file_pattern=file_pattern,\n                        include_functions_in_class=False,\n                    ).hits\n                )\n                results.extend(\n                    self.find_by_name(\n                        function_names=function_names, file_pattern=file_pattern\n                    ).hits\n                )\n\n                if len(results) > 0 and len(results) <= max_results:\n                    return SearchCodeResponse(\n                        message=f\"Found {len(results)} hits.\",\n                        hits=results,\n                    )\n\n        if query or code_snippet:\n            return self.semantic_search(\n                query=query,\n                code_snippet=code_snippet,\n                class_names=class_names,\n                function_names=function_names,\n                file_pattern=file_pattern,\n                max_results=max_results,\n            )\n\n        return result",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::7",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 387,
          "span_ids": [
            "CodeIndex.semantic_search"
          ],
          "start_line": 220,
          "end_line": 272,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def semantic_search(\n        self,\n        query: Optional[str] = None,\n        code_snippet: Optional[str] = None,\n        class_names: list[str] = None,\n        function_names: list[str] = None,\n        file_pattern: Optional[str] = None,\n        category: str = \"implementation\",\n        max_results: int = 25,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n        max_spans_per_file: Optional[int] = None,\n        exact_match_if_possible: bool = False,\n    ) -> SearchCodeResponse:\n        if query is None:\n            query = \"\"\n\n        if class_names:\n            query += f\", class {class_names}\"\n\n        if function_names:\n            query += f\", function {function_names}\"\n\n        message = \"\"\n        if file_pattern:\n            if category != \"test\":\n                exclude_files = self._file_repo.matching_files(\"**/test*/**\")\n            else:\n                exclude_files = []\n\n            matching_files = self._file_repo.matching_files(file_pattern)\n            matching_files = [\n                file for file in matching_files if file not in exclude_files\n            ]\n\n            if not matching_files:\n                logger.info(\n                    f\"semantic_search() No files found for file pattern {file_pattern}. Will search all files...\"\n                )\n                message += f\"No files found for file pattern {file_pattern}. Will search all files.\\n\"\n                file_pattern = None\n\n        search_results = self._vector_search(\n            query, file_pattern=file_pattern, exact_content_match=code_snippet\n        )\n\n        files_with_spans: dict[str, SearchCodeHit] = {}\n\n        span_count = 0\n        spans_with_exact_query_match = 0\n        filtered_out = 0\n\n        require_exact_query_match = False\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::8",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 746,
          "span_ids": [
            "CodeIndex.semantic_search"
          ],
          "start_line": 274,
          "end_line": 366,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def semantic_search(\n        self,\n        query: Optional[str] = None,\n        code_snippet: Optional[str] = None,\n        class_names: list[str] = None,\n        function_names: list[str] = None,\n        file_pattern: Optional[str] = None,\n        category: str = \"implementation\",\n        max_results: int = 25,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n        max_spans_per_file: Optional[int] = None,\n        exact_match_if_possible: bool = False,\n    ) -> SearchCodeResponse:\n        # ... other code\n\n        for rank, search_hit in enumerate(search_results):\n            file = self._file_repo.get_file(search_hit.file_path)\n            if not file:\n                logger.warning(\n                    f\"semantic_search() Could not find file {search_hit.file_path}.\"\n                )\n                continue\n\n            spans = []\n            for span_id in search_hit.span_ids:\n                span = file.module.find_span_by_id(span_id)\n\n                if span:\n                    spans.append(span)\n                else:\n                    logger.debug(\n                        f\"semantic_search() Could not find span with id {span_id} in file {file.file_path}\"\n                    )\n\n                    spans_by_line_number = file.module.find_spans_by_line_numbers(\n                        search_hit.start_line, search_hit.end_line\n                    )\n\n                    for span_by_line_number in spans_by_line_number:\n                        spans.append(span_by_line_number)\n\n            names = []\n            if class_names:\n                names.extend(class_names)\n\n            if function_names:\n                names.extend(function_names)\n\n            for span in spans:\n                has_exact_query_match = (\n                    exact_match_if_possible\n                    and query\n                    and span.initiating_block.has_content(query, span.span_id)\n                )\n\n                if has_exact_query_match:\n                    spans_with_exact_query_match += 1\n\n                if has_exact_query_match and not require_exact_query_match:\n                    require_exact_query_match = True\n                    files_with_spans = {}\n\n                if (\n                    not require_exact_query_match and span_count <= max_results\n                ) or has_exact_query_match:\n                    if search_hit.file_path not in files_with_spans:\n                        files_with_spans[search_hit.file_path] = SearchCodeHit(\n                            file_path=search_hit.file_path\n                        )\n\n                    if files_with_spans[search_hit.file_path].contains_span(\n                        span.span_id\n                    ):\n                        continue\n\n                    if names and not any(\n                        name in span.initiating_block.full_path() for name in names\n                    ):\n                        filtered_out += 1\n                        continue\n\n                    span_count += 1\n                    files_with_spans[search_hit.file_path].add_span(\n                        span_id=span.span_id, rank=rank, tokens=span.tokens\n                    )\n\n                    if (\n                        max_spans_per_file\n                        and len(files_with_spans[search_hit.file_path].spans)\n                        >= max_spans_per_file\n                    ):\n                        break\n\n            if exact_match_if_possible:\n                if spans_with_exact_query_match > max_exact_results or (\n                    spans_with_exact_query_match == 0\n                    and span_count > max_hits_without_exact_match\n                ):\n                    break\n            elif span_count > max_results:\n                break\n\n        span_count = sum([len(file.spans) for file in files_with_spans.values()])\n\n        if class_names or function_names:\n            logger.info(\n                f\"semantic_search() Filtered out {filtered_out} spans by class names {class_names} and function names {function_names}.\"\n            )\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::9",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 268,
          "span_ids": [
            "CodeIndex.semantic_search"
          ],
          "start_line": 368,
          "end_line": 379,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def semantic_search(\n        self,\n        query: Optional[str] = None,\n        code_snippet: Optional[str] = None,\n        class_names: list[str] = None,\n        function_names: list[str] = None,\n        file_pattern: Optional[str] = None,\n        category: str = \"implementation\",\n        max_results: int = 25,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n        max_spans_per_file: Optional[int] = None,\n        exact_match_if_possible: bool = False,\n    ) -> SearchCodeResponse:\n        # ... other code\n\n        if require_exact_query_match:\n            logger.info(\n                f\"semantic_search() Found {spans_with_exact_query_match} code spans with exact match out of {span_count} spans.\"\n            )\n            message = f\"Found {spans_with_exact_query_match} code spans with code that matches the exact query `{query}`.\"\n        else:\n            logger.info(\n                f\"semantic_search() Found {span_count} code spans in {len(files_with_spans.values())} files.\"\n            )\n            message = f\"Found {span_count} code spans.\"\n\n        return SearchCodeResponse(message=message, hits=list(files_with_spans.values()))",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::10",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 787,
          "span_ids": [
            "CodeIndex.find_by_name"
          ],
          "start_line": 381,
          "end_line": 494,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def find_by_name(\n        self,\n        class_names: list[str] = None,\n        function_names: list[str] = None,\n        file_pattern: Optional[str] = None,\n        include_functions_in_class: bool = True,\n        category: str = \"implementation\",\n    ) -> SearchCodeResponse:\n        if not class_names and not function_names:\n            raise ValueError(\n                \"At least one of class_name or function_name must be provided.\"\n            )\n\n        paths = []\n\n        if function_names:\n            for function_name in function_names:\n                paths.extend(self._blocks_by_function_name.get(function_name, []))\n\n        if class_names:\n            for class_name in class_names:\n                paths.extend(self._blocks_by_class_name.get(class_name, []))\n\n        logger.info(\n            f\"find_by_name(class_name={class_names}, function_name={function_names}, file_pattern={file_pattern}) {len(paths)} hits.\"\n        )\n\n        if not paths:\n            if function_names:\n                return SearchCodeResponse(\n                    message=f\"No functions found with the name {function_names}.\"\n                )\n            else:\n                return SearchCodeResponse(\n                    message=f\"No classes found with the name {class_names}.\"\n                )\n\n        if category != \"test\":\n            exclude_files = self._file_repo.matching_files(\"**/test*/**\")\n\n            filtered_paths = []\n            for file_path, block_path in paths:\n                if file_path not in exclude_files:\n                    filtered_paths.append((file_path, block_path))\n\n            filtered_out_test_files = len(paths) - len(filtered_paths)\n            if filtered_out_test_files > 0:\n                logger.info(\n                    f\"find_by_name() Filtered out {filtered_out_test_files} test files.\"\n                )\n\n            paths = filtered_paths\n\n        check_all_files = False\n        if file_pattern:\n            include_files = self._file_repo.matching_files(file_pattern)\n\n            if include_files:\n                filtered_paths = []\n                for file_path, block_path in paths:\n                    if file_path in include_files:\n                        filtered_paths.append((file_path, block_path))\n\n                filtered_out_by_file_pattern = len(paths) - len(filtered_paths)\n                if filtered_paths:\n                    logger.info(\n                        f\"find_by_name() Filtered out {filtered_out_by_file_pattern} files by file pattern.\"\n                    )\n                    paths = filtered_paths\n                else:\n                    logger.info(\n                        f\"find_by_name() No files found for file pattern {file_pattern}. Will search all files...\"\n                    )\n                    check_all_files = True\n\n        filtered_out_by_class_name = 0\n        invalid_blocks = 0\n\n        files_with_spans = {}\n        for file_path, block_path in paths:\n            file = self._file_repo.get_file(file_path)\n            block = file.module.find_by_path(block_path)\n\n            if not block:\n                invalid_blocks += 1\n                continue\n\n            if (\n                class_names\n                and function_names\n                and not self._found_class(block, class_names)\n            ):\n                filtered_out_by_class_name += 1\n                continue\n\n            if file_path not in files_with_spans:\n                files_with_spans[file_path] = SearchCodeHit(file_path=file_path)\n\n            files_with_spans[file_path].add_span(\n                block.belongs_to_span.span_id,\n                rank=0,\n                tokens=block.belongs_to_span.tokens,\n            )\n            if include_functions_in_class and not function_names:\n                for child in block.children:\n                    if (\n                        child.belongs_to_span.span_id\n                        not in files_with_spans[file_path].span_ids\n                    ):\n                        files_with_spans[file_path].add_span(\n                            child.belongs_to_span.span_id,\n                            rank=0,\n                            tokens=child.belongs_to_span.tokens,\n                        )\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::10"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::11",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 399,
          "span_ids": [
            "CodeIndex.find_by_name"
          ],
          "start_line": 496,
          "end_line": 533,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def find_by_name(\n        self,\n        class_names: list[str] = None,\n        function_names: list[str] = None,\n        file_pattern: Optional[str] = None,\n        include_functions_in_class: bool = True,\n        category: str = \"implementation\",\n    ) -> SearchCodeResponse:\n        # ... other code\n\n        if filtered_out_by_class_name > 0:\n            logger.info(\n                f\"find_by_function_name() Filtered out {filtered_out_by_class_name} functions by class name {class_name}.\"\n            )\n\n        if invalid_blocks > 0:\n            logger.info(\n                f\"find_by_function_name() Ignored {invalid_blocks} invalid blocks.\"\n            )\n\n        if check_all_files and len(files_with_spans) > 0:\n            message = f\"The file pattern {file_pattern} didn't match any files. But I found {len(files_with_spans)} matches in other files.\"\n        elif len(files_with_spans):\n            message = f\"Found {len(files_with_spans)} hits.\"\n        elif class_names and function_names:\n            message = f\"No functions found with the names {function_names} in class {class_names}.\"\n        elif class_names:\n            message = f\"No classes found with the name {class_names}.\"\n        elif function_names:\n            message = f\"No functions found with the names {function_names}.\"\n        else:\n            message = \"No results found.\"\n\n        file_paths = [file.file_path for file in files_with_spans.values()]\n        if file_pattern:\n            file_paths = _rerank_files(file_paths, file_pattern)\n\n        search_hits = []\n        for rank, file_path in enumerate(file_paths):\n            file = files_with_spans[file_path]\n            for span in file.spans:\n                span.rank = rank\n            search_hits.append(file)\n\n        return SearchCodeResponse(\n            message=message,\n            hits=search_hits,\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::11"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::12",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 125,
          "span_ids": [
            "CodeIndex._found_class",
            "CodeIndex._create_search_hit"
          ],
          "start_line": 535,
          "end_line": 547,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def _found_class(self, block: CodeBlock, class_names: list[str]):\n        for class_name in class_names:\n            parent_class = block.find_type_in_parents(CodeBlockType.CLASS)\n            if parent_class and parent_class.identifier == class_name:\n                return True\n        else:\n            return False\n\n    def _create_search_hit(self, file: FileWithSpans, rank: int = 0):\n        file_hit = SearchCodeHit(file_path=file.file_path)\n        for span_id in file.span_ids:\n            file_hit.add_span(span_id, rank)\n        return file_hit",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::12"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::13",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 818,
          "span_ids": [
            "CodeIndex._vector_search"
          ],
          "start_line": 549,
          "end_line": 666,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def _vector_search(\n        self,\n        query: str = \"\",\n        exact_query_match: bool = False,\n        category: str = \"implementation\",\n        file_pattern: Optional[str] = None,\n        exact_content_match: Optional[str] = None,\n    ):\n        if file_pattern:\n            query += f\" file:{file_pattern}\"\n\n        if exact_content_match:\n            query += \"\\n\" + exact_content_match\n\n        if not query:\n            raise ValueError(\n                \"At least one of query, span_keywords or content_keywords must be provided.\"\n            )\n\n        logger.info(\n            f\"vector_search() Searching for query [{query[:50]}...] and file pattern [{file_pattern}].\"\n        )\n\n        query_embedding = self._embed_model.get_query_embedding(query)\n\n        filters = MetadataFilters(filters=[], condition=FilterCondition.AND)\n        if category:\n            filters.filters.append(MetadataFilter(key=\"category\", value=category))\n\n        query_bundle = VectorStoreQuery(\n            query_str=query,\n            query_embedding=query_embedding,\n            similarity_top_k=500,  # TODO: Fix paging?\n            filters=filters,\n        )\n\n        result = self._vector_store.query(query_bundle)\n\n        filtered_out_snippets = 0\n        ignored_removed_snippets = 0\n        sum_tokens = 0\n\n        sum_tokens_per_file = {}\n\n        if file_pattern:\n            include_files = self._file_repo.matching_files(file_pattern)\n            if len(include_files) == 0:\n                logger.info(\n                    f\"vector_search() No files found for file pattern {file_pattern}, return empty result...\"\n                )\n                return []\n        else:\n            include_files = []\n\n        if category != \"test\":\n            exclude_files = self._file_repo.find_files(\n                [\"**/tests/**\", \"tests*\", \"*_test.py\", \"test_*.py\"]\n            )\n        else:\n            exclude_files = set()\n\n        search_results = []\n\n        for node_id, distance in zip(result.ids, result.similarities, strict=False):\n            node_doc = self._docstore.get_document(node_id, raise_error=False)\n            if not node_doc:\n                ignored_removed_snippets += 1\n                # TODO: Retry to get top_k results\n                continue\n\n            if exclude_files and node_doc.metadata[\"file_path\"] in exclude_files:\n                filtered_out_snippets += 1\n                continue\n\n            if include_files and node_doc.metadata[\"file_path\"] not in include_files:\n                filtered_out_snippets += 1\n                continue\n\n            if exact_query_match and query not in node_doc.get_content():\n                filtered_out_snippets += 1\n                continue\n\n            if exact_content_match and not is_string_in(\n                exact_content_match, node_doc.get_content()\n            ):\n                filtered_out_snippets += 1\n                continue\n\n            if node_doc.metadata[\"file_path\"] not in sum_tokens_per_file:\n                sum_tokens_per_file[node_doc.metadata[\"file_path\"]] = 0\n\n            sum_tokens += node_doc.metadata[\"tokens\"]\n            sum_tokens_per_file[node_doc.metadata[\"file_path\"]] += node_doc.metadata[\n                \"tokens\"\n            ]\n\n            code_snippet = CodeSnippet(\n                id=node_doc.id_,\n                file_path=node_doc.metadata[\"file_path\"],\n                distance=distance,\n                content=node_doc.get_content(),\n                tokens=node_doc.metadata[\"tokens\"],\n                span_ids=node_doc.metadata.get(\"span_ids\", []),\n                start_line=node_doc.metadata.get(\"start_line\", None),\n                end_line=node_doc.metadata.get(\"end_line\", None),\n            )\n\n            search_results.append(code_snippet)\n\n        # TODO: Rerank by file pattern if no exact matches on file pattern\n\n        logger.info(\n            f\"vector_search() Returning {len(search_results)} search results. \"\n            f\"(Ignored {ignored_removed_snippets} removed search results. \"\n            f\"Filtered out {filtered_out_snippets} search results.)\"\n        )\n\n        return search_results",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::13"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::14",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 232,
          "span_ids": [
            "CodeIndex.run_ingestion"
          ],
          "start_line": 668,
          "end_line": 699,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def run_ingestion(\n        self,\n        repo_path: Optional[str] = None,\n        input_files: list[str] | None = None,\n        num_workers: Optional[int] = None,\n    ):\n        repo_path = repo_path or self._file_repo.path\n\n        # Only extract file name and type to not trigger unnecessary embedding jobs\n        def file_metadata_func(file_path: str) -> dict:\n            file_path = file_path.replace(repo_path, \"\")\n            if file_path.startswith(\"/\"):\n                file_path = file_path[1:]\n\n            test_patterns = [\n                \"**/test/**\",\n                \"**/tests/**\",\n                \"**/test_*.py\",\n                \"**/*_test.py\",\n            ]\n            category = (\n                \"test\"\n                if any(fnmatch.fnmatch(file_path, pattern) for pattern in test_patterns)\n                else \"implementation\"\n            )\n\n            return {\n                \"file_path\": file_path,\n                \"file_name\": os.path.basename(file_path),\n                \"file_type\": mimetypes.guess_type(file_path)[0],\n                \"category\": category,\n            }\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::14"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::15",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 269,
          "span_ids": [
            "CodeIndex.run_ingestion"
          ],
          "start_line": 701,
          "end_line": 730,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def run_ingestion(\n        self,\n        repo_path: Optional[str] = None,\n        input_files: list[str] | None = None,\n        num_workers: Optional[int] = None,\n    ):\n        # ... other code\n\n        if self._settings and self._settings.language == \"java\":\n            required_exts = [\".java\"]\n        else:\n            required_exts = [\".py\"]\n\n        try:\n            reader = SimpleDirectoryReader(\n                input_dir=repo_path,\n                file_metadata=file_metadata_func,\n                input_files=input_files,\n                filename_as_id=True,\n                required_exts=required_exts,\n                recursive=True,\n            )\n        except Exception as e:\n            logger.exception(f\"Failed to create reader with input_dir {repo_path}, input_files {input_files} and required_exts {required_exts}.\")\n            raise e\n\n        embed_pipeline = IngestionPipeline(\n            transformations=[self._embed_model],\n            docstore_strategy=DocstoreStrategy.UPSERTS_AND_DELETE,\n            docstore=self._docstore,\n            vector_store=self._vector_store,\n        )\n\n        docs = reader.load_data()\n        logger.info(f\"Read {len(docs)} documents\")\n\n        blocks_by_class_name = {}\n        blocks_by_function_name = {}\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::15"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::16",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 189,
          "span_ids": [
            "CodeIndex.run_ingestion"
          ],
          "start_line": 732,
          "end_line": 745,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def run_ingestion(\n        self,\n        repo_path: Optional[str] = None,\n        input_files: list[str] | None = None,\n        num_workers: Optional[int] = None,\n    ):\n        # ... other code\n\n        def index_callback(codeblock: CodeBlock):\n            if codeblock.type == CodeBlockType.CLASS:\n                if codeblock.identifier not in blocks_by_class_name:\n                    blocks_by_class_name[codeblock.identifier] = []\n                blocks_by_class_name[codeblock.identifier].append(\n                    (codeblock.module.file_path, codeblock.full_path())\n                )\n\n            if codeblock.type == CodeBlockType.FUNCTION:\n                if codeblock.identifier not in blocks_by_function_name:\n                    blocks_by_function_name[codeblock.identifier] = []\n                blocks_by_function_name[codeblock.identifier].append(\n                    (codeblock.module.file_path, codeblock.full_path())\n                )\n        # ... other code",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::16"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::17",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 321,
          "span_ids": [
            "CodeIndex.run_ingestion"
          ],
          "start_line": 747,
          "end_line": 785,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def run_ingestion(\n        self,\n        repo_path: Optional[str] = None,\n        input_files: list[str] | None = None,\n        num_workers: Optional[int] = None,\n    ):\n        # ... other code\n\n        splitter = EpicSplitter(\n            language=self._settings.language,\n            min_chunk_size=self._settings.min_chunk_size,\n            chunk_size=self._settings.chunk_size,\n            hard_token_limit=self._settings.hard_token_limit,\n            max_chunks=self._settings.max_chunks,\n            comment_strategy=self._settings.comment_strategy,\n            index_callback=index_callback,\n            repo_path=repo_path,\n        )\n\n        prepared_nodes = splitter.get_nodes_from_documents(docs, show_progress=True)\n        prepared_tokens = sum(\n            [\n                count_tokens(node.get_content(), self._settings.embed_model)\n                for node in prepared_nodes\n            ]\n        )\n        logger.info(\n            f\"Prepared {len(prepared_nodes)} nodes and {prepared_tokens} tokens\"\n        )\n\n        embedded_nodes = embed_pipeline.run(\n            nodes=list(prepared_nodes), show_progress=True, num_workers=num_workers\n        )\n        embedded_tokens = sum(\n            [\n                count_tokens(node.get_content(), self._settings.embed_model)\n                for node in embedded_nodes\n            ]\n        )\n        logger.info(\n            f\"Embedded {len(embedded_nodes)} vectors with {embedded_tokens} tokens\"\n        )\n\n        self._blocks_by_class_name = blocks_by_class_name\n        self._blocks_by_function_name = blocks_by_function_name\n\n        return len(embedded_nodes), embedded_tokens",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::17"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::18",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 137,
          "span_ids": [
            "CodeIndex.persist"
          ],
          "start_line": 787,
          "end_line": 798,
          "community": null
        },
        "content": "class CodeIndex:\n\n    def persist(self, persist_dir: str):\n        self._vector_store.persist(persist_dir)\n        self._docstore.persist(\n            os.path.join(persist_dir, docstore.types.DEFAULT_PERSIST_FNAME)\n        )\n        self._settings.persist(persist_dir)\n\n        with open(os.path.join(persist_dir, \"blocks_by_class_name.json\"), \"w\") as f:\n            f.write(json.dumps(self._blocks_by_class_name, indent=2))\n\n        with open(os.path.join(persist_dir, \"blocks_by_function_name.json\"), \"w\") as f:\n            f.write(json.dumps(self._blocks_by_function_name, indent=2))",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::18"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_index.py::19",
        "metadata": {
          "file_path": "moatless\\index\\code_index.py",
          "file_name": "code_index.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 267,
          "span_ids": [
            "is_string_in",
            "_rerank_files"
          ],
          "start_line": 801,
          "end_line": 831,
          "community": null
        },
        "content": "def _rerank_files(file_paths: list[str], file_pattern: str):\n    if len(file_paths) < 2:\n        return file_paths\n\n    tokenized_query = file_pattern.replace(\".py\", \"\").replace(\"*\", \"\").split(\"/\")\n    tokenized_query = [part for part in tokenized_query if part.strip()]\n    query = \"/\".join(tokenized_query)\n\n    scored_files = []\n    for file_path in file_paths:\n        cleaned_file_path = file_path.replace(\".py\", \"\")\n        score = fuzz.partial_ratio(cleaned_file_path, query)\n        scored_files.append((file_path, score))\n\n    scored_files.sort(key=lambda x: x[1], reverse=True)\n\n    sorted_file_paths = [file for file, score in scored_files]\n\n    logger.info(\n        f\"rerank_files() Reranked {len(file_paths)} files with query {tokenized_query}. First hit {sorted_file_paths[0]}\"\n    )\n\n    return sorted_file_paths\n\n\ndef is_string_in(s1, s2):\n    s1_clean = s1.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"\\n\", \"\")\n    s2_clean = s2.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"\\n\", \"\")\n    found_in = s1_clean in s2_clean\n    return found_in",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_index.py::19"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/code_node.py::1",
        "metadata": {
          "file_path": "moatless\\index\\code_node.py",
          "file_name": "code_node.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 111,
          "span_ids": [
            "imports",
            "CodeNode",
            "CodeNode.hash"
          ],
          "start_line": 1,
          "end_line": 15,
          "community": null
        },
        "content": "from hashlib import sha256\n\nfrom llama_index.core.schema import TextNode\n\n\nclass CodeNode(TextNode):\n    # Skip start and end line in metadata to try to lower the number of changes and triggers of new embeddings.\n    @property\n    def hash(self):\n        metadata = self.metadata.copy()\n        metadata.pop(\"start_line\", None)\n        metadata.pop(\"end_line\", None)\n        doc_identity = str(self.text) + str(metadata)\n        return str(sha256(doc_identity.encode(\"utf-8\", \"surrogatepass\")).hexdigest())",
        "summary": null,
        "ctxt_list": [],
        "id": "index/code_node.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/embed_model.py::1",
        "metadata": {
          "file_path": "moatless\\index\\embed_model.py",
          "file_name": "embed_model.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 271,
          "span_ids": [
            "imports",
            "get_embed_model"
          ],
          "start_line": 1,
          "end_line": 36,
          "community": null
        },
        "content": "import os\n\nfrom llama_index.core.base.embeddings.base import BaseEmbedding\n\n\ndef get_embed_model(model_name: str) -> BaseEmbedding:\n    if model_name.startswith(\"voyage\"):\n        try:\n            from llama_index.embeddings.voyageai import VoyageEmbedding\n        except ImportError as e:\n            raise ImportError(\n                \"llama-index-embeddings-voyageai is not installed. Please install it using `pip install llama-index-embeddings-voyageai`\"\n            ) from e\n\n        if \"VOYAGE_API_KEY\" not in os.environ:\n            raise ValueError(\n                \"VOYAGE_API_KEY environment variable is not set. Please set it to your Voyage API key.\"\n            )\n\n        return VoyageEmbedding(\n            model_name=model_name,\n            voyage_api_key=os.environ.get(\"VOYAGE_API_KEY\"),\n            truncation=True,\n            embed_batch_size=50,\n        )\n    else:\n        # Assumes OpenAI otherwise\n        try:\n            from llama_index.embeddings.openai import OpenAIEmbedding\n        except ImportError as e:\n            raise ImportError(\n                \"llama-index-embeddings-openai is not installed. Please install it using `pip install llama-index-embeddings-openai`\"\n            ) from e\n\n        return OpenAIEmbedding(model_name=model_name)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/embed_model.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::1",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 275,
          "span_ids": [
            "imports",
            "count_parent_tokens",
            "impl:3",
            "count_chunk_tokens"
          ],
          "start_line": 1,
          "end_line": 39,
          "community": null
        },
        "content": "import re\nimport time\nfrom collections.abc import Callable, Sequence\nfrom typing import Any, Optional\n\nfrom llama_index.core.bridge.pydantic import Field\nfrom llama_index.core.callbacks import CallbackManager\nfrom llama_index.core.node_parser import NodeParser, TextSplitter, TokenTextSplitter\nfrom llama_index.core.node_parser.node_utils import logger\nfrom llama_index.core.schema import BaseNode, TextNode\nfrom llama_index.core.utils import get_tokenizer, get_tqdm_iterable\n\nfrom moatless.codeblocks import create_parser\nfrom moatless.codeblocks.codeblocks import CodeBlock, CodeBlockType, PathTree\nfrom moatless.codeblocks.parser.python import PythonParser\nfrom moatless.index.code_node import CodeNode\nfrom moatless.index.settings import CommentStrategy\n\nCodeBlockChunk = list[CodeBlock]\n\n\ndef count_chunk_tokens(chunk: CodeBlockChunk) -> int:\n    return sum([block.tokens for block in chunk])\n\n\ndef count_parent_tokens(codeblock: CodeBlock) -> int:\n    tokens = codeblock.tokens\n    if codeblock.parent:\n        tokens += codeblock.parent.tokens\n    return tokens\n\n\nSPLIT_BLOCK_TYPES = [\n    CodeBlockType.FUNCTION,\n    CodeBlockType.CLASS,\n    CodeBlockType.TEST_SUITE,\n    CodeBlockType.TEST_CASE,\n    CodeBlockType.MODULE,\n]",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::2",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 745,
          "span_ids": [
            "EpicSplitter",
            "EpicSplitter.class_name",
            "EpicSplitter.__init__"
          ],
          "start_line": 42,
          "end_line": 135,
          "community": null
        },
        "content": "class EpicSplitter(NodeParser):\n    language: str = Field(\n        default=\"python\", description=\"Language of the code blocks to parse.\"\n    )\n\n    text_splitter: TextSplitter = Field(\n        description=\"Text splitter to use for splitting non code documents into nodes.\"\n    )\n\n    include_non_code_files: bool = Field(\n        default=True, description=\"Whether or not to include non code files.\"\n    )\n\n    non_code_file_extensions: list[str] = Field(\n        default=[\"md\", \"txt\"],\n        description=\"File extensions to consider as non code files.\",\n    )\n\n    comment_strategy: CommentStrategy = Field(\n        default=CommentStrategy.INCLUDE, description=\"Comment strategy to use.\"\n    )\n\n    chunk_size: int = Field(\n        default=1500, description=\"Chunk size to use for splitting code documents.\"\n    )\n\n    max_chunks: int = Field(\n        default=100, description=\"Max number of chunks to split a document into.\"\n    )\n\n    min_chunk_size: int = Field(default=256, description=\"Min tokens to split code.\")\n\n    max_chunk_size: int = Field(default=2000, description=\"Max tokens in one chunk.\")\n\n    hard_token_limit: int = Field(\n        default=6000, description=\"Hard token limit for a chunk.\"\n    )\n\n    repo_path: str = Field(default=None, description=\"Path to the repository.\")\n\n    index_callback: Optional[Callable] = Field(\n        default=None, description=\"Callback to call when indexing a code block.\"\n    )\n\n    # _fallback_code_splitter: Optional[TextSplitter] = PrivateAttr() TODO: Implement fallback when tree sitter fails\n\n    def __init__(\n        self,\n        language: str = \"python\",\n        chunk_size: int = 750,\n        min_chunk_size: int = 100,\n        max_chunk_size: int = 1500,\n        hard_token_limit: int = 6000,\n        max_chunks: int = 100,\n        include_metadata: bool = True,\n        include_prev_next_rel: bool = True,\n        text_splitter: TextSplitter | None = None,\n        index_callback: Optional[Callable[[CodeBlock], None]] = None,\n        repo_path: Optional[str] = None,\n        comment_strategy: CommentStrategy = CommentStrategy.ASSOCIATE,\n        # fallback_code_splitter: Optional[TextSplitter] = None,\n        include_non_code_files: bool = True,\n        tokenizer: Optional[Callable] = None,\n        non_code_file_extensions: list[str] | None = None,\n        callback_manager: CallbackManager | None = None,\n    ) -> None:\n        if non_code_file_extensions is None:\n            non_code_file_extensions = [\"md\", \"txt\"]\n        callback_manager = callback_manager or CallbackManager([])\n\n        # self._fallback_code_splitter = fallback_code_splitter\n\n        super().__init__(\n            language=language,\n            chunk_size=chunk_size,\n            chunk_overlap=0,\n            text_splitter=text_splitter or TokenTextSplitter(),\n            min_chunk_size=min_chunk_size,\n            max_chunk_size=max_chunk_size,\n            hard_token_limit=hard_token_limit,\n            max_chunks=max_chunks,\n            index_callback=index_callback,\n            repo_path=repo_path,\n            comment_strategy=comment_strategy,\n            include_non_code_files=include_non_code_files,\n            non_code_file_extensions=non_code_file_extensions,\n            include_metadata=include_metadata,\n            include_prev_next_rel=include_prev_next_rel,\n            callback_manager=callback_manager,\n        )\n\n    @classmethod\n    def class_name(cls):\n        return \"GhostcoderNodeParser\"",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::3",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 488,
          "span_ids": [
            "EpicSplitter._parse_nodes"
          ],
          "start_line": 137,
          "end_line": 193,
          "community": null
        },
        "content": "class EpicSplitter(NodeParser):\n\n    def _parse_nodes(\n        self,\n        nodes: Sequence[BaseNode],\n        show_progress: bool = False,\n        **kwargs: Any,\n    ) -> list[BaseNode]:\n        nodes_with_progress = get_tqdm_iterable(nodes, show_progress, \"Parsing nodes\")\n\n        all_nodes: list[BaseNode] = []\n\n        for node in nodes_with_progress:\n            file_path = node.metadata.get(\"file_path\")\n            content = node.get_content()\n\n            try:\n                starttime = time.time_ns()\n\n                # TODO: Derive language from file extension\n                parser = create_parser(language=self.language, index_callback=self.index_callback)\n                codeblock = parser.parse(content, file_path=file_path)\n\n                parse_time = time.time_ns() - starttime\n                if parse_time > 1e9:\n                    logger.warning(\n                        f\"Parsing file {file_path} took {parse_time / 1e9:.2f} seconds.\"\n                    )\n\n            except Exception as e:\n                logger.warning(\n                    f\"Failed to use epic splitter to split {file_path}. Fallback to treesitter_split(). Error: {e}\"\n                )\n                # TODO: Fall back to treesitter or text split\n                continue\n\n            starttime = time.time_ns()\n            chunks = self._chunk_contents(codeblock=codeblock, file_path=file_path)\n            parse_time = time.time_ns() - starttime\n            if parse_time > 1e8:\n                logger.warning(\n                    f\"Splitting file {file_path} took {parse_time / 1e9:.2f} seconds.\"\n                )\n            if len(chunks) > 100:\n                logger.info(f\"Splitting file {file_path} in {len(chunks)} chunks\")\n\n            starttime = time.time_ns()\n            for chunk in chunks:\n                path_tree = self._create_path_tree(chunk)\n                content = self._to_context_string(codeblock, path_tree)\n                chunk_node = self._create_node(content, node, chunk=chunk)\n                if chunk_node:\n                    all_nodes.append(chunk_node)\n            parse_time = time.time_ns() - starttime\n            if parse_time > 1e9:\n                logger.warning(\n                    f\"Create nodes for file {file_path} took {parse_time / 1e9:.2f} seconds.\"\n                )\n        return all_nodes",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::4",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 304,
          "span_ids": [
            "EpicSplitter._chunk_contents"
          ],
          "start_line": 195,
          "end_line": 228,
          "community": null
        },
        "content": "class EpicSplitter(NodeParser):\n\n    def _chunk_contents(\n        self, codeblock: CodeBlock | None = None, file_path: Optional[str] = None\n    ) -> list[CodeBlockChunk]:\n        tokens = codeblock.sum_tokens()\n        if tokens == 0:\n            logger.debug(f\"Skipping file {file_path} because it has no tokens.\")\n            return []\n\n        if codeblock.find_errors():\n            logger.warning(\n                f\"Failed to use spic splitter to split {file_path}. {len(codeblock.find_errors())} codeblocks with type ERROR. Fallback to treesitter_split()\"\n            )\n            # TODO: Fall back to treesitter or text split\n            return []\n\n        if tokens > self.hard_token_limit:\n            for child in codeblock.children:\n                if (\n                    child.type == CodeBlockType.COMMENT\n                    and \"generated\" in child.content.lower()\n                ):  # TODO: Make a generic solution to detect files that shouldn't be indexed. Maybe ask an LLM?\n                    logger.info(\n                        f\"File {file_path} has {tokens} tokens and the word 'generated' in the first comments,\"\n                        f\" will assume it's a generated file.\"\n                    )\n                    return []\n                else:\n                    break\n\n        if tokens < self.min_chunk_size:\n            child_blocks = codeblock.get_all_child_blocks()\n            return [[codeblock] + child_blocks]\n\n        return self._chunk_block(codeblock, file_path)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::5",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 598,
          "span_ids": [
            "EpicSplitter._chunk_block"
          ],
          "start_line": 230,
          "end_line": 324,
          "community": null
        },
        "content": "class EpicSplitter(NodeParser):\n\n    def _chunk_block(\n        self, codeblock: CodeBlock, file_path: Optional[str] = None\n    ) -> list[CodeBlockChunk]:\n        chunks: list[CodeBlockChunk] = []\n        current_chunk = []\n        comment_chunk = []\n\n        parent_tokens = count_parent_tokens(codeblock)\n\n        ignoring_comment = False\n\n        for child in codeblock.children:\n            if child.type == CodeBlockType.COMMENT:\n                if self.comment_strategy == CommentStrategy.EXCLUDE:\n                    continue\n                elif self._ignore_comment(child) or ignoring_comment:\n                    ignoring_comment = True\n                    continue\n                elif (\n                    self.comment_strategy == CommentStrategy.ASSOCIATE\n                    and not codeblock.parent\n                ):\n                    comment_chunk.append(child)\n                    continue\n            else:\n                if child.tokens > self.max_chunk_size:\n                    start_content = child.content[:100]\n                    logger.warning(\n                        f\"Skipping code block {child.path_string()} in {file_path} as it has {child.tokens} tokens which is\"\n                        f\" more than chunk size {self.chunk_size}. Content: {start_content}...\"\n                    )\n                    continue\n\n                ignoring_comment = False\n\n            if (\n                child.type in SPLIT_BLOCK_TYPES\n                and child.sum_tokens() > self.min_chunk_size\n            ) or parent_tokens + child.sum_tokens() > self.max_chunk_size:\n                if current_chunk:\n                    chunks.append(current_chunk)\n                    current_chunk = []\n\n                current_chunk.extend(comment_chunk)\n                comment_chunk = []\n                current_chunk.append(child)\n\n                child_chunks = self._chunk_block(child, file_path=file_path)\n\n                if child_chunks:\n                    first_child_chunk = child_chunks[0]\n\n                    if (\n                        parent_tokens\n                        + child.tokens\n                        + count_chunk_tokens(first_child_chunk)\n                        < self.max_chunk_size\n                    ):\n                        current_chunk.extend(first_child_chunk)\n                        chunks.append(current_chunk)\n                        chunks.extend(child_chunks[1:])\n                        current_chunk = []\n                    else:\n                        chunks.append(current_chunk)\n                        chunks.extend(child_chunks)\n                        current_chunk = []\n\n                continue\n\n            new_token_count = (\n                parent_tokens + count_chunk_tokens(current_chunk) + child.sum_tokens()\n            )\n            if (\n                codeblock.type not in SPLIT_BLOCK_TYPES\n                and new_token_count < self.max_chunk_size\n                or new_token_count < self.chunk_size\n            ):\n                current_chunk.extend(comment_chunk)\n                current_chunk.append(child)\n            else:\n                if current_chunk:\n                    current_chunk.extend(comment_chunk)\n                    chunks.append(current_chunk)\n                current_chunk = [child]\n\n            comment_chunk = []\n            child_blocks = child.get_all_child_blocks()\n            current_chunk.extend(child_blocks)\n\n        if chunks and count_chunk_tokens(current_chunk) < self.min_chunk_size:\n            chunks[-1].extend(current_chunk)\n        else:\n            chunks.append(current_chunk)\n\n        return self._merge_chunks(chunks)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::6",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 525,
          "span_ids": [
            "EpicSplitter._ignore_comment",
            "EpicSplitter._merge_chunks",
            "EpicSplitter._create_path_tree"
          ],
          "start_line": 326,
          "end_line": 402,
          "community": null
        },
        "content": "class EpicSplitter(NodeParser):\n\n    def _merge_chunks(self, chunks: list[CodeBlockChunk]) -> list[CodeBlockChunk]:\n        while True:\n            merged_chunks = []\n            should_continue = False\n\n            for i, chunk in enumerate(chunks):\n                if (\n                    count_chunk_tokens(chunk) < self.min_chunk_size\n                    or len(chunks) > self.max_chunks\n                ):\n                    if i == 0 and len(chunks) > 1:\n                        if (\n                            count_chunk_tokens(chunks[1]) + count_chunk_tokens(chunk)\n                            <= self.hard_token_limit\n                        ):\n                            chunks[1] = chunk + chunks[1]\n                            should_continue = True\n                        else:\n                            merged_chunks.append(chunk)\n\n                    elif i == len(chunks) - 1:\n                        if (\n                            merged_chunks\n                            and count_chunk_tokens(merged_chunks[-1])\n                            + count_chunk_tokens(chunk)\n                            <= self.hard_token_limit\n                        ):\n                            merged_chunks[-1] = merged_chunks[-1] + chunk\n                            should_continue = True\n                        else:\n                            merged_chunks.append(chunk)\n\n                    else:\n                        if count_chunk_tokens(chunks[i - 1]) < count_chunk_tokens(\n                            chunks[i + 1]\n                        ):\n                            if (\n                                merged_chunks\n                                and count_chunk_tokens(merged_chunks[-1])\n                                + count_chunk_tokens(chunk)\n                                <= self.hard_token_limit\n                            ):\n                                merged_chunks[-1] = merged_chunks[-1] + chunk\n                                should_continue = True\n                            else:\n                                merged_chunks.append(chunk)\n                        else:\n                            if (\n                                count_chunk_tokens(chunks[i + 1])\n                                + count_chunk_tokens(chunk)\n                                <= self.hard_token_limit\n                            ):\n                                chunks[i + 1] = chunk + chunks[i + 1]\n                                should_continue = True\n                            else:\n                                merged_chunks.append(chunk)\n                else:\n                    merged_chunks.append(chunk)\n\n            chunks = merged_chunks + chunks[i + 1 :]\n\n            if len(chunks) < self.max_chunks or not should_continue:\n                break\n\n        return chunks\n\n    def _create_path_tree(self, blocks: list[CodeBlock]) -> PathTree:\n        path_tree = PathTree()\n        for block in blocks:\n            path_tree.add_to_tree(block.full_path())\n        return path_tree\n\n    def _ignore_comment(self, codeblock: CodeBlock) -> bool:\n        return (\n            re.search(r\"(?i)copyright|license|author\", codeblock.content)\n            or not codeblock.content\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::7",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 424,
          "span_ids": [
            "EpicSplitter._to_context_string"
          ],
          "start_line": 404,
          "end_line": 462,
          "community": null
        },
        "content": "class EpicSplitter(NodeParser):\n\n    def _to_context_string(self, codeblock: CodeBlock, path_tree: PathTree) -> str:\n        contents = \"\"\n\n        if codeblock.pre_lines:\n            contents += \"\\n\" * (codeblock.pre_lines - 1)\n            for i, line in enumerate(codeblock.content_lines):\n                if i == 0 and line:\n                    contents += \"\\n\" + codeblock.indentation + line\n                elif line:\n                    contents += \"\\n\" + line\n                else:\n                    contents += \"\\n\"\n        else:\n            contents += codeblock.pre_code + codeblock.content\n\n        has_outcommented_code = False\n        for _i, child in enumerate(codeblock.children):\n            child_tree = path_tree.child_tree(child.identifier)\n            if child_tree and child_tree.show:\n                if (\n                    has_outcommented_code\n                    and child.type\n                    not in [\n                        CodeBlockType.COMMENT,\n                        CodeBlockType.COMMENTED_OUT_CODE,\n                    ]\n                    and codeblock.type\n                    not in [\n                        CodeBlockType.CLASS,\n                        CodeBlockType.MODULE,\n                        CodeBlockType.TEST_SUITE,\n                    ]\n                ):\n                    contents += child.create_commented_out_block(\n                        \"... other code\"\n                    ).to_string()\n                contents += self._to_context_string(\n                    codeblock=child, path_tree=child_tree\n                )\n                has_outcommented_code = False\n            elif child_tree:\n                contents += self._to_context_string(\n                    codeblock=child, path_tree=child_tree\n                )\n                has_outcommented_code = False\n            elif child.type not in [\n                CodeBlockType.COMMENT,\n                CodeBlockType.COMMENTED_OUT_CODE,\n            ]:\n                has_outcommented_code = True\n\n        if has_outcommented_code and codeblock.type not in [\n            CodeBlockType.CLASS,\n            CodeBlockType.MODULE,\n            CodeBlockType.TEST_SUITE,\n        ]:\n            contents += child.create_commented_out_block(\"... other code\").to_string()\n\n        return contents",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/epic_split.py::8",
        "metadata": {
          "file_path": "moatless\\index\\epic_split.py",
          "file_name": "epic_split.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 408,
          "span_ids": [
            "EpicSplitter._contains_block_paths",
            "EpicSplitter._create_node",
            "EpicSplitter._count_tokens"
          ],
          "start_line": 464,
          "end_line": 518,
          "community": null
        },
        "content": "class EpicSplitter(NodeParser):\n\n    def _contains_block_paths(self, codeblock: CodeBlock, block_paths: list[list[str]]):\n        return [\n            block_path\n            for block_path in block_paths\n            if block_path[: len(codeblock.full_path())] == codeblock.full_path()\n        ]\n\n    def _create_node(\n        self, content: str, node: BaseNode, chunk: CodeBlockChunk | None = None\n    ) -> TextNode | None:\n        metadata = {}\n        metadata.update(node.metadata)\n\n        node_id = node.id_\n\n        if chunk:\n            metadata[\"start_line\"] = chunk[0].start_line\n            metadata[\"end_line\"] = chunk[-1].end_line\n\n            # TODO: Change this when EpicSplitter is adjusted to use the span concept natively\n            span_ids = set(\n                [\n                    block.belongs_to_span.span_id\n                    for block in chunk\n                    if block.belongs_to_span\n                ]\n            )\n            metadata[\"span_ids\"] = list(span_ids)\n\n            node_id += f\"_{chunk[0].path_string()}_{chunk[-1].path_string()}\"\n\n        content = content.strip(\"\\n\")\n\n        tokens = get_tokenizer()(content)\n        metadata[\"tokens\"] = len(tokens)\n\n        excluded_embed_metadata_keys = node.excluded_embed_metadata_keys.copy()\n        excluded_embed_metadata_keys.extend([\"start_line\", \"end_line\", \"tokens\"])\n\n        return CodeNode(\n            id_=node_id,\n            text=content,\n            metadata=metadata,\n            excluded_embed_metadata_keys=excluded_embed_metadata_keys,\n            excluded_llm_metadata_keys=node.excluded_llm_metadata_keys,\n            metadata_seperator=node.metadata_seperator,\n            metadata_template=node.metadata_template,\n            text_template=node.text_template,\n            # relationships={NodeRelationship.SOURCE: node.as_related_node_info()},\n        )\n\n    def _count_tokens(self, text: str):\n        tokenizer = get_tokenizer()\n        return len(tokenizer(text))",
        "summary": null,
        "ctxt_list": [],
        "id": "index/epic_split.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/settings.py::1",
        "metadata": {
          "file_path": "moatless\\index\\settings.py",
          "file_name": "settings.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 390,
          "span_ids": [
            "IndexSettings.persist",
            "CommentStrategy",
            "imports",
            "IndexSettings",
            "IndexSettings.to_serializable_dict",
            "IndexSettings.from_persist_dir"
          ],
          "start_line": 1,
          "end_line": 53,
          "community": null
        },
        "content": "import json\nimport os\nfrom enum import Enum\n\nfrom pydantic import BaseModel, Field\n\n\nclass CommentStrategy(Enum):\n    # Keep comments\n    INCLUDE = \"include\"\n\n    # Always associate comments before a code block with the code block\n    ASSOCIATE = \"associate\"\n\n    # Exclude comments in parsed chunks\n    EXCLUDE = \"exclude\"\n\n\nclass IndexSettings(BaseModel):\n    embed_model: str = Field(\n        default=\"text-embedding-3-small\", description=\"The embedding model to use.\"\n    )\n    dimensions: int = Field(\n        default=1536, description=\"The number of dimensions of the vectors.\"\n    )\n\n    language: str = Field(default=\"python\", description=\"The language of the code.\")\n    min_chunk_size: int = Field(default=100, description=\"The minimum chunk size.\")\n    chunk_size: int = Field(default=750, description=\"The soft max chunk size.\")\n    hard_token_limit: int = Field(default=2000, description=\"The hard token limit.\")\n    max_chunks: int = Field(\n        default=200, description=\"The maximum number of chunks for one file.\"\n    )\n    comment_strategy: CommentStrategy = Field(\n        default=CommentStrategy.ASSOCIATE,\n        description=\"Strategy on how comments will be indexed.\",\n    )\n\n    def to_serializable_dict(self):\n        data = self.dict()\n        data[\"comment_strategy\"] = data[\"comment_strategy\"].value\n        return data\n\n    def persist(self, persist_dir: str):\n        with open(os.path.join(persist_dir, \"settings.json\"), \"w\") as f:\n            json.dump(self.to_serializable_dict(), f, indent=4)\n\n    @classmethod\n    def from_persist_dir(cls, persist_dir: str):\n        with open(os.path.join(persist_dir, \"settings.json\")) as f:\n            data = json.load(f)\n        return cls(**data)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/settings.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/simple_faiss.py::1",
        "metadata": {
          "file_path": "moatless\\index\\simple_faiss.py",
          "file_name": "simple_faiss.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 291,
          "span_ids": [
            "docstring",
            "SimpleVectorStoreData"
          ],
          "start_line": 1,
          "end_line": 44,
          "community": null
        },
        "content": "\"\"\"Simple vector store index.\"\"\"\n\nimport json\nimport logging\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Any, cast\n\nimport faiss\nimport fsspec\nimport numpy as np\nfrom dataclasses_json import DataClassJsonMixin\nfrom fsspec.implementations.local import LocalFileSystem\nfrom llama_index.core.bridge.pydantic import PrivateAttr\nfrom llama_index.core.schema import BaseNode\nfrom llama_index.core.vector_stores.simple import _build_metadata_filter_fn\nfrom llama_index.core.vector_stores.types import (\n    DEFAULT_PERSIST_DIR,\n    BasePydanticVectorStore,\n    VectorStoreQuery,\n    VectorStoreQueryMode,\n    VectorStoreQueryResult,\n)\nfrom llama_index.core.vector_stores.utils import node_to_metadata_dict\n\nlogger = logging.getLogger(__name__)\n\nLEARNER_MODES = {\n    VectorStoreQueryMode.SVM,\n    VectorStoreQueryMode.LINEAR_REGRESSION,\n    VectorStoreQueryMode.LOGISTIC_REGRESSION,\n}\n\nMMR_MODE = VectorStoreQueryMode.MMR\n\nNAMESPACE_SEP = \"__\"\nDEFAULT_VECTOR_STORE = \"default\"\n\n\n@dataclass\nclass SimpleVectorStoreData(DataClassJsonMixin):\n    text_id_to_ref_doc_id: dict[str, str] = field(default_factory=dict)\n    vector_id_to_text_id: dict[int, str] = field(default_factory=dict)\n    metadata_dict: dict[str, Any] = field(default_factory=dict)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/simple_faiss.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/simple_faiss.py::2",
        "metadata": {
          "file_path": "moatless\\index\\simple_faiss.py",
          "file_name": "simple_faiss.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 439,
          "span_ids": [
            "SimpleFaissVectorStore.client",
            "SimpleFaissVectorStore",
            "SimpleFaissVectorStore.__init__",
            "SimpleFaissVectorStore.from_defaults"
          ],
          "start_line": 47,
          "end_line": 102,
          "community": null
        },
        "content": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n    \"\"\"Simple Vector Store using Faiss as .\n\n    In this vector store, embeddings are stored within a simple, in-memory dictionary.\n\n    Args:\n        simple_vector_store_data_dict (Optional[dict]): data dict\n            containing the embeddings and doc_ids. See SimpleVectorStoreData\n            for more details.\n    \"\"\"\n\n    _data: SimpleVectorStoreData = PrivateAttr()\n    _fs: fsspec.AbstractFileSystem = PrivateAttr()\n    _faiss_index: Any = PrivateAttr()\n    _d: int = PrivateAttr()\n\n    _vector_ids_to_delete: list[int] = PrivateAttr(default_factory=list)\n    _text_ids_to_delete: set[str] = PrivateAttr(default_factory=set)\n\n    stores_text: bool = False\n\n    def __init__(\n        self,\n        faiss_index: Any,\n        d: int = 1536,\n        data: SimpleVectorStoreData | None = None,\n        fs: fsspec.AbstractFileSystem | None = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n\n        import_err_msg = \"\"\"\n            `faiss` package not found. For instructions on\n            how to install `faiss` please visit\n            https://github.com/facebookresearch/faiss/wiki/Installing-Faiss\n        \"\"\"\n        try:\n            import faiss\n        except ImportError as e:\n            raise ImportError(import_err_msg) from e\n\n        self._d = d\n        self._faiss_index = cast(faiss.Index, faiss_index)\n        self._data = data or SimpleVectorStoreData()\n        self._fs = fs or fsspec.filesystem(\"file\")\n        super().__init__(**kwargs)\n\n    @classmethod\n    def from_defaults(cls, d: int = 1536):\n        faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(1536))\n        return cls(faiss_index, d)\n\n    @property\n    def client(self) -> Any:\n        \"\"\"Return the faiss index.\"\"\"\n        return self._faiss_index",
        "summary": null,
        "ctxt_list": [],
        "id": "index/simple_faiss.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/simple_faiss.py::3",
        "metadata": {
          "file_path": "moatless\\index\\simple_faiss.py",
          "file_name": "simple_faiss.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 284,
          "span_ids": [
            "SimpleFaissVectorStore.add"
          ],
          "start_line": 104,
          "end_line": 142,
          "community": null
        },
        "content": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n\n    def add(\n        self,\n        nodes: list[BaseNode],\n        **add_kwargs: Any,\n    ) -> list[str]:\n        \"\"\"Add nodes to index.\"\"\"\n\n        if not nodes:\n            return []\n\n        vector_id = (\n            max([int(k) for k in self._data.vector_id_to_text_id])\n            if self._data.vector_id_to_text_id\n            else 0\n        )\n\n        logger.info(f\"Adding {len(nodes)} nodes to index, start at id {vector_id}.\")\n\n        embeddings = []\n        ids = []\n        for node in nodes:\n            embeddings.append(node.get_embedding())\n            ids.append(int(vector_id))\n            self._data.vector_id_to_text_id[vector_id] = node.id_\n            self._data.text_id_to_ref_doc_id[node.id_] = node.ref_doc_id or node.id_\n            vector_id += 1\n\n            metadata = node_to_metadata_dict(\n                node, remove_text=True, flat_metadata=False\n            )\n            metadata.pop(\"_node_content\", None)\n            self._data.metadata_dict[node.node_id] = metadata\n\n        vectors_ndarray = np.array(embeddings)\n        ids_ndarray = np.array(ids)\n\n        self._faiss_index.add_with_ids(vectors_ndarray, ids_ndarray)\n\n        return [node.node_id for node in nodes]",
        "summary": null,
        "ctxt_list": [],
        "id": "index/simple_faiss.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/simple_faiss.py::4",
        "metadata": {
          "file_path": "moatless\\index\\simple_faiss.py",
          "file_name": "simple_faiss.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 159,
          "span_ids": [
            "SimpleFaissVectorStore.delete"
          ],
          "start_line": 144,
          "end_line": 160,
          "community": null
        },
        "content": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n\n    def delete(self, ref_doc_id: str, **delete_kwargs: Any) -> None:\n        \"\"\"\n        Delete nodes using with ref_doc_id.\n\n        Args:\n            ref_doc_id (str): The doc_id of the document to delete.\n\n        \"\"\"\n\n        self._text_ids_to_delete = set()\n        for text_id, ref_doc_id_ in self._data.text_id_to_ref_doc_id.items():\n            if ref_doc_id == ref_doc_id_:\n                self._text_ids_to_delete.add(text_id)\n\n        for vector_id, text_id in self._data.vector_id_to_text_id.items():\n            if text_id in self._text_ids_to_delete:\n                self._vector_ids_to_delete.append(vector_id)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/simple_faiss.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/simple_faiss.py::5",
        "metadata": {
          "file_path": "moatless\\index\\simple_faiss.py",
          "file_name": "simple_faiss.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 415,
          "span_ids": [
            "SimpleFaissVectorStore.query"
          ],
          "start_line": 162,
          "end_line": 217,
          "community": null
        },
        "content": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n\n    def query(\n        self,\n        query: VectorStoreQuery,\n        **kwargs: Any,\n    ) -> VectorStoreQueryResult:\n        \"\"\"Query index for top k most similar nodes.\n\n        Args:\n            query_embedding (List[float]): query embedding\n            similarity_top_k (int): top k most similar nodes\n\n        \"\"\"\n        query_filter_fn = _build_metadata_filter_fn(\n            lambda node_id: self._data.metadata_dict[node_id], query.filters\n        )\n\n        query_embedding = cast(list[float], query.query_embedding)\n        query_embedding_np = np.array(query_embedding, dtype=\"float32\")[np.newaxis, :]\n        dists, indices = self._faiss_index.search(\n            query_embedding_np, query.similarity_top_k\n        )\n        dists = list(dists[0])\n        if len(indices) == 0:\n            return VectorStoreQueryResult(similarities=[], ids=[])\n\n        node_idxs = indices[0]\n\n        duplicates = 0\n        not_found = 0\n        filtered_out = 0\n\n        filtered_dists = []\n        filtered_node_ids = []\n        for dist, idx in zip(dists, node_idxs, strict=False):\n            if idx < 0:\n                break\n\n            node_id = self._data.vector_id_to_text_id.get(idx)\n            if not query_filter_fn(node_id):\n                filtered_out += 1\n            elif node_id and node_id not in filtered_node_ids:\n                filtered_node_ids.append(node_id)\n                filtered_dists.append(dist.item())\n            elif node_id in filtered_node_ids:\n                duplicates += 1\n            else:\n                not_found += 1\n\n        if not_found or duplicates:\n            logger.debug(\n                f\"Return {len(filtered_node_ids)} nodes ({not_found} not found, {duplicates} duplicates and {filtered_out} nodes).\"\n            )\n\n        return VectorStoreQueryResult(\n            similarities=filtered_dists, ids=filtered_node_ids\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "index/simple_faiss.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/simple_faiss.py::6",
        "metadata": {
          "file_path": "moatless\\index\\simple_faiss.py",
          "file_name": "simple_faiss.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 386,
          "span_ids": [
            "SimpleFaissVectorStore.persist"
          ],
          "start_line": 219,
          "end_line": 258,
          "community": null
        },
        "content": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n\n    def persist(\n        self,\n        persist_dir: str = DEFAULT_PERSIST_DIR,\n        fs: fsspec.AbstractFileSystem | None = None,\n    ) -> None:\n        \"\"\"Persist the SimpleVectorStore to a directory.\"\"\"\n        fs = fs or self._fs\n\n        # I don't think FAISS supports fsspec, it requires a path in the SWIG interface\n        # TODO: write to a temporary file and then copy to the final destination\n        if fs and not isinstance(fs, LocalFileSystem):\n            raise NotImplementedError(\"FAISS only supports local storage for now.\")\n        import faiss\n\n        if not os.path.exists(persist_dir):\n            os.makedirs(persist_dir)\n\n        logger.info(f\"Deleting {len(self._vector_ids_to_delete)} vectors from index.\")\n\n        if self._vector_ids_to_delete:\n            ids_to_remove_array = np.array(self._vector_ids_to_delete, dtype=np.int64)\n            removed = self._faiss_index.remove_ids(ids_to_remove_array)\n            logger.info(f\"Removed {removed} vectors from index.\")\n\n        if self._text_ids_to_delete:\n            for text_id in self._text_ids_to_delete:\n                if self._data.metadata_dict is not None:\n                    self._data.metadata_dict.pop(text_id, None)\n\n        faiss.write_index(self._faiss_index, f\"{persist_dir}/vector_index.faiss\")\n\n        for vector_id in self._vector_ids_to_delete:\n            text_id = self._data.vector_id_to_text_id.pop(vector_id, None)\n            if text_id:\n                self._data.text_id_to_ref_doc_id.pop(text_id, None)\n\n        self._vector_ids_to_delete = []\n\n        with fs.open(f\"{persist_dir}/vector_index.json\", \"w\") as f:\n            json.dump(self._data.to_dict(), f)",
        "summary": null,
        "ctxt_list": [],
        "id": "index/simple_faiss.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/simple_faiss.py::7",
        "metadata": {
          "file_path": "moatless\\index\\simple_faiss.py",
          "file_name": "simple_faiss.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 314,
          "span_ids": [
            "SimpleFaissVectorStore.from_index",
            "SimpleFaissVectorStore.from_persist_dir",
            "SimpleFaissVectorStore.to_dict"
          ],
          "start_line": 260,
          "end_line": 292,
          "community": null
        },
        "content": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n\n    @classmethod\n    def from_persist_dir(\n        cls, persist_dir: str, fs: fsspec.AbstractFileSystem | None = None\n    ) -> \"SimpleFaissVectorStore\":\n        \"\"\"Create a SimpleKVStore from a persist directory.\"\"\"\n\n        fs = fs or fsspec.filesystem(\"file\")\n        if not fs.exists(persist_dir):\n            raise ValueError(f\"No existing index store found at {persist_dir}.\")\n\n        # I don't think FAISS supports fsspec, it requires a path in the SWIG interface\n        # TODO: copy to a temp file and load into memory from there\n        if fs and not isinstance(fs, LocalFileSystem):\n            raise NotImplementedError(\"FAISS only supports local storage for now.\")\n\n        faiss_index = faiss.read_index(f\"{persist_dir}/vector_index.faiss\")\n\n        logger.debug(f\"Loading {__name__} from {persist_dir}.\")\n        with fs.open(f\"{persist_dir}/vector_index.json\", \"rb\") as f:\n            data_dict = json.load(f)\n            data = SimpleVectorStoreData.from_dict(data_dict)\n\n        logger.info(f\"Loading {__name__} from {persist_dir}.\")\n\n        return cls(faiss_index=faiss_index, data=data)\n\n    @classmethod\n    def from_index(cls, faiss_index: Any):\n        return cls(faiss_index)\n\n    def to_dict(self) -> dict:\n        return self._data.to_dict()",
        "summary": null,
        "ctxt_list": [],
        "id": "index/simple_faiss.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/types.py::1",
        "metadata": {
          "file_path": "moatless\\index\\types.py",
          "file_name": "types.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 201,
          "span_ids": [
            "imports",
            "SpanHit",
            "CodeSnippet"
          ],
          "start_line": 1,
          "end_line": 28,
          "community": null
        },
        "content": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\n@dataclass\nclass CodeSnippet:\n    id: str\n    file_path: str\n    content: str = None\n    distance: float = 0.0\n    tokens: int = None\n    language: str = \"python\"\n    span_ids: list[str] = None\n    start_line: Optional[int] = None\n    end_line: Optional[int] = None\n    start_block: Optional[str] = None\n    end_block: Optional[str] = None\n\n\nclass SpanHit(BaseModel):\n    span_id: str = Field(description=\"The span id of the relevant code in the file\")\n    rank: int = Field(\n        default=0,\n        description=\"The rank of relevance of the span in the file. 0 is highest.\",\n    )\n    tokens: int = Field(default=0, description=\"The number of tokens in the span.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "index/types.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "index/types.py::2",
        "metadata": {
          "file_path": "moatless\\index\\types.py",
          "file_name": "types.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 272,
          "span_ids": [
            "SearchCodeHit.add_span",
            "SearchCodeHit.add_spans",
            "SearchCodeHit",
            "SearchCodeResponse",
            "SearchCodeHit.contains_span",
            "SearchCodeHit.span_ids"
          ],
          "start_line": 31,
          "end_line": 65,
          "community": null
        },
        "content": "class SearchCodeHit(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    spans: list[SpanHit] = Field(\n        default_factory=list,\n        description=\"The spans of the relevant code in the file\",\n    )\n\n    @property\n    def span_ids(self):\n        return [span.span_id for span in self.spans]\n\n    def add_span(self, span_id: str, rank: int = 0, tokens: int = 0):\n        if span_id not in [span.span_id for span in self.spans]:\n            self.spans.append(SpanHit(span_id=span_id, rank=rank, tokens=tokens))\n\n    def contains_span(self, span_id: str) -> bool:\n        return span_id in [span.span_id for span in self.spans]\n\n    def add_spans(self, span_ids: list[str], rank: int = 0):\n        for span_id in span_ids:\n            self.add_span(span_id, rank)\n\n\nclass SearchCodeResponse(BaseModel):\n    message: Optional[str] = Field(\n        default=None, description=\"A message to return to the user.\"\n    )\n\n    hits: list[SearchCodeHit] = Field(\n        default_factory=list,\n        description=\"Search results.\",\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "index/types.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::1",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 218,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 42,
          "community": null
        },
        "content": "import json\nimport logging\nimport os\nimport random\nimport string\nimport sys\nimport traceback\nfrom collections.abc import Callable\nfrom datetime import datetime\nfrom typing import Any, Optional, Type, Tuple\nimport subprocess\n\nimport instructor\nimport litellm\nfrom anthropic import Anthropic\nfrom litellm import completion_cost, cost_per_token, token_counter\nfrom pydantic import BaseModel, Field, PrivateAttr, ConfigDict\n\nfrom moatless.repository import GitRepository\nfrom moatless.state import (\n    AgenticState,\n    Finished,\n    NoopState,\n    Pending,\n    Rejected,\n    get_state_class,\n)\nfrom moatless.trajectory import Trajectory\nfrom moatless.transition_rules import TransitionRule, TransitionRules\nfrom moatless.types import (\n    ActionRequest,\n    AssistantMessage,\n    Content,\n    Message,\n    Response,\n    Usage,\n    UserMessage,\n)\nfrom moatless.utils.llm_utils import instructor_mode_by_model\nfrom moatless.workspace import Workspace\n\nlogger = logging.getLogger(\"Loop\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::2",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 817,
          "span_ids": [
            "AgenticLoop",
            "AgenticLoop.__init__",
            "AgenticLoop.persist",
            "AgenticLoop.from_trajectory_file"
          ],
          "start_line": 45,
          "end_line": 157,
          "community": null
        },
        "content": "class AgenticLoop:\n    def __init__(\n        self,\n        transition_rules: TransitionRules,\n        workspace: Workspace,\n        input_data: dict[str, Any] | None = None,\n        initial_message: str | None = None,\n        trajectory: Trajectory | None = None,\n        mocked_actions: list[dict] | None = None,\n        expected_states: list[Type[AgenticState]] | None = None,\n        reset_mocks_at_state: Optional[str] = None,\n        verify_state_func: Optional[Callable] = None,\n        max_cost: float = 0.25,\n        max_actions: int = 2,\n        max_transitions: int = 25,\n        max_message_tokens: Optional[int] = None,\n        max_retries: int = 2,\n        max_rejections: int = 2,\n        instructor_mode: instructor.Mode | None = None,\n        metadata: dict[str, Any] | None = None,\n        trajectory_path: Optional[str] = None,\n        prompt_log_dir: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the Loop instance.\n\n        Args:\n\n        \"\"\"\n\n        self._workspace = workspace\n\n        self._input_data = input_data\n\n        if trajectory_path:\n            parent_dir = os.path.dirname(trajectory_path)\n            if not os.path.exists(parent_dir):\n                os.makedirs(parent_dir)\n        self._trajectory_path = trajectory_path\n\n        if not trajectory:\n            self._trajectory = Trajectory(\n                \"MoatlessTools\",\n                initial_message=initial_message,\n                persist_path=self._trajectory_path,\n                workspace=self._workspace,\n                transition_rules=transition_rules,\n            )\n            pending_state = Pending()\n            self._trajectory.save_state(pending_state)\n            self._set_current_state(pending_state)\n        else:\n            self._trajectory = trajectory\n            self._current_state = trajectory.get_current_state()\n\n        self._initial_message = initial_message\n\n        if prompt_log_dir and not os.path.exists(prompt_log_dir):\n            os.makedirs(prompt_log_dir)\n        self._prompt_log_dir = prompt_log_dir\n\n        if expected_states and not verify_state_func:\n\n            def verify_state_func(state: AgenticState):\n                nonlocal expected_states\n                if not expected_states:\n                    raise ValueError(\n                        f\"No more expected states, but got {state.__class__}\"\n                    )\n                expected_state = expected_states.pop(0)\n                if isinstance(expected_state, str):\n                    if state.name != expected_state:\n                        raise ValueError(\n                            f\"Expected state {expected_state} but got {state.__class__.__name__}\"\n                        )\n                elif isinstance(expected_state, AgenticState) and not isinstance(state, expected_state):\n                    raise ValueError(\n                        f\"Expected state {expected_state} but got {state.__class__.__name__}\"\n                    )\n\n                self.log_info(f\"Verified expected next state {expected_state}\")\n\n        self._verify_state_func = verify_state_func\n        self._mocked_actions = mocked_actions\n        self._reset_mocks_at_state = reset_mocks_at_state\n\n        self._max_cost = max_cost\n        self._max_message_tokens = max_message_tokens\n        self._max_transitions = max_transitions\n        self._max_actions = max_actions\n        self._max_retries = max_retries\n        self._max_rejections = max_rejections\n        self._instructor_mode = instructor_mode\n\n        self._transition_count = 0\n        self._rejections = 0\n\n        self._transition_rules = transition_rules\n        self._metadata = metadata\n\n    @classmethod\n    def from_trajectory_file(cls, trajectory_path: str, **kwargs):\n        trajectory = Trajectory.load(trajectory_path)\n        return cls(\n            transition_rules=trajectory.transitions,\n            trajectory=trajectory,\n            workspace=trajectory.workspace,\n            **kwargs,\n        )\n\n    def persist(self, trajectory_path: str):\n        self.trajectory.persist(trajectory_path)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::3",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 383,
          "span_ids": [
            "AgenticLoop.run"
          ],
          "start_line": 159,
          "end_line": 204,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    def run(self, message: Optional[str] = None) -> Response:\n        \"\"\"\n        Executes the entire loop until completion or termination.\n\n        This method initializes the loop if it hasn't started, and then repeatedly\n        calls run_until_transition() until the loop is finished. It handles the\n        overall flow of the loop, including initialization and final state processing.\n\n        Args:\n            message (Optional[str]): An optional initial message to start the loop with.\n\n        Returns:\n            Response: An object containing the final status and message of the loop.\n                The status will be either \"finished\" or \"rejected\".\n\n        Raises:\n            RuntimeError: If an unexpected state or condition occurs during execution.\n                This includes cases where the loop is already running, exits with an \n                unknown state, or encounters other unexpected runtime conditions.\n\n        Note:\n            This method will continue running until a Finished or Rejected state is reached,\n            or until an exception occurs. It's designed to be the main entry point for\n            executing the entire loop process.\n        \"\"\"\n        if self.is_running():\n            raise RuntimeError(\"Loop is already running.\")\n\n        # TODO: Move to always set this when the Loop is created instead\n        if message:\n            logger.warning(\"Setting initial message in run is deprecated. Set in contructor.\")\n            self._initial_message = message\n            self._trajectory._initial_message = message\n\n        if not isinstance(self._current_state, Pending):\n            self._trajectory.update_workspace_to_current_state()\n\n        while not self.is_finished():\n            self._execute_state_until_transition()\n\n        if isinstance(self.state, Finished):\n            return Response(status=\"finished\", message=self.state.message or \"\")\n        elif isinstance(self.state, Rejected):\n            return Response(status=\"rejected\", message=self.state.message or \"\")\n\n        raise RuntimeError(f\"Loop exited with unknown state {self.state.name}.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::4",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 353,
          "span_ids": [
            "AgenticLoop._execute_state_until_transition"
          ],
          "start_line": 206,
          "end_line": 244,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    def _execute_state_until_transition(self) -> AgenticState | None:\n        \"\"\"\n        Executes the state until a transition to a new state occurs.\n\n        This method executes the state, processing actions and handling\n        state changes until one of the following conditions is met:\n        1. A transition to a new state occurs\n        2. Maximum cost, retries, or transitions are exceeded\n\n        Returns:\n            AgenticState: The new state after a transition occurs\n\n        Raises:\n            RuntimeError: If the loop exits without a transition or if the maximum cost is exceeded\n            ValueError: If the maximum number of retries is reached\n        \"\"\"\n        while not self.state.executed:\n            total_cost = self.total_cost()\n            if total_cost > self._max_cost:\n                self.log_info(f\"Max cost reached ({total_cost} > {self._max_cost}). Exiting.\")\n                self.trajectory.save_info({\"error\": \"Max cost reached.\"})\n                raise RuntimeError(\"The loop was aborted because the cost exceeded the limit.\")\n\n            self.log_info(f\"Running transition {len(self._trajectory.states)}. Current total cost: {total_cost}\")\n\n            try:\n                state = self._execute_state()\n                if state:\n                    return state\n            except Exception as e:\n                self.log_info(f\"Failed to run loop. Error: {e}\")\n                raise\n\n            if self.state.retries() > self._max_retries:\n                self.log_info(f\"Max retries reached ({self._max_retries}). Exiting.\")\n                self.trajectory.save_info({\"error\": \"Max retries reached.\"})\n                return self.transition_to(Rejected(message=\"Max retries reached.\"))\n\n        raise RuntimeError(\"Loop exited without a transition.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::5",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 351,
          "span_ids": [
            "AgenticLoop._execute_state"
          ],
          "start_line": 246,
          "end_line": 299,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    def _execute_state(self) -> AgenticState | None:\n        \"\"\"\n        Execute one iteration of the current state and handle potential transitions.\n\n        Processes the next action, updates the trajectory, and determines if a state\n        transition should occur based on the action's response.\n\n        Returns:\n            AgenticState | None: The next state if transitioning, or None if remaining in the current state.\n\n        Raises:\n            ValueError: \n        \"\"\"\n        if self.state.executed:\n            raise ValueError(\"Tried to execute already executed state.\")\n\n        if isinstance(self.state, Pending):\n            logger.info(\"Initializing first state.\")\n            trigger = \"init\"\n            output = {}\n\n        else:\n            action, usage = self._next_action()\n\n            self.log_info(f\"Received new action {action.action_name}.\")\n            response = self.state.handle_action(action, usage)\n\n            if not response.trigger:\n                self.log_info(\n                    f\"{self.state.name}: No trigger in action response. Staying in the same state.\"\n                )\n                return None\n\n            self.log_info(f\"Received response with trigger {response.trigger}\")\n\n            if response.trigger == \"retry\":\n                self.log_info(f\"Retry requested. {response.retry_message}\")\n                return None\n\n            trigger = response.trigger\n            output = response.output\n\n        transition_rule = self._transition_rules.get_next_rule(\n            self.state,\n            trigger,\n            output,\n        )\n        if not transition_rule:\n            raise RuntimeError(\n                f\"No transition rule found for {self.state.name} with trigger {response.trigger} and output {response.output}\"\n            )\n\n        next_state = self._create_state(transition_rule, output)\n        return self.transition_to(next_state)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::6",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 364,
          "span_ids": [
            "AgenticLoop._create_state"
          ],
          "start_line": 301,
          "end_line": 341,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    def _create_state(self, transition_rule: TransitionRule, output: dict) -> AgenticState:\n        params = {}\n        params.update(self._transition_rules.params(transition_rule))\n\n        for k, v in output.items():\n            if transition_rule.excluded_fields and k in transition_rule.excluded_fields:\n                continue\n\n            params[k] = v\n\n        params[\"id\"] = self.state_count()\n\n        next_state_type = transition_rule.dest\n        if next_state_type not in [Finished, Rejected]:\n\n            if self.state_count() >= self._max_transitions:\n                self.log_info(f\"Max transitions exceeded ({self._max_transitions}). Transitioning to Rejected.\")\n                next_state_type = Rejected\n                params[\"message\"] = \"Max transitions exceeded.\"\n            if (\n                params.get(\"max_iterations\")\n                and self.state_count(next_state_type) >= params[\"max_iterations\"]\n            ):\n                self.log_info(f\"Max iterations exceeded ({params['max_iterations']}). Transitioning to Rejected.\")\n                next_state_type = Rejected\n                params[\"message\"] = f\"Max iterations exceeded ({params['max_iterations']}).\"\n\n        self.log_info(f\"Creating state {next_state_type.__name__} with params {params}\")\n\n        try:\n            next_state = next_state_type.model_validate(params)\n            next_state.previous_state = self._current_state\n            next_state._workspace = self._workspace\n            next_state._initial_message = self._initial_message\n        except Exception as e:\n            logger.error(f\"Failed to create state {next_state_type.__name__} with params {params}\")\n            raise e\n\n        self._trajectory.save_state(next_state)\n        self._current_state.next_states.append(next_state)\n        return next_state",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::7",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 173,
          "span_ids": [
            "AgenticLoop.transition_to",
            "AgenticLoop.is_finished",
            "AgenticLoop._set_current_state",
            "AgenticLoop.total_cost",
            "AgenticLoop.is_running"
          ],
          "start_line": 343,
          "end_line": 365,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    def total_cost(self):\n        total_cost = 0\n        for state in self._trajectory.transitions:\n            total_cost += state.state.total_cost()\n        return total_cost\n\n    def is_running(self) -> bool:\n        return not isinstance(self.state, NoopState)\n\n    def is_finished(self) -> bool:\n        return isinstance(self.state, (Finished, Rejected))\n\n    def _set_current_state(self, state: AgenticState):\n        self._current_state = state\n        self._trajectory.set_current_state(state)\n\n    def transition_to(self, new_state: AgenticState) -> AgenticState:\n        self.log_info(f\"Transitioning from {self.state.name} to {new_state.name}\")\n\n        self._trajectory.save_state(new_state)\n        self._set_current_state(new_state)\n\n        return new_state",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::8",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 819,
          "span_ids": [
            "AgenticLoop._next_action"
          ],
          "start_line": 367,
          "end_line": 492,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    def _next_action(\n        self,\n    ) -> Tuple[ActionRequest, Usage | None]:\n        messages = self._to_completion_messages()\n        self.log_info(f\"Create completion with {len(messages)} messages\")\n\n        if self._verify_state_func:\n            self._verify_state_func(self.state)\n\n        mocked_action = self._next_mock_action()\n        if mocked_action:\n            return mocked_action, None\n\n        metadata = {}\n        if self._metadata:\n            metadata.update(self._metadata)\n        metadata[\"generation_name\"] = self.state.name\n\n        tokens = token_counter(messages=messages[-1:])\n        if self._max_message_tokens and tokens > self._max_message_tokens:\n            raise ValueError(f\"Too many tokens in the new message: {tokens}\")\n\n        self.log_info(f\"Do completion request to {self.state.model}\")\n\n        if self.state.model.startswith(\"claude\") and self.state.action_type():\n            try:\n                anthropic_client = instructor.from_anthropic(\n                    Anthropic(),\n                    mode=self.instructor_mode,\n                )\n\n                action_request, completion_response = (\n                    anthropic_client.chat.completions.create_with_completion(\n                        model=self.state.model,\n                        max_tokens=self.state.max_tokens,\n                        temperature=self.state.temperature,\n                        # stop=self.state.stop_words(),\n                        response_model=self.state.action_type(),\n                        messages=messages,\n                    )\n                )\n\n                self.log_info(\n                    f\"Input tokens: {completion_response.usage.input_tokens}, Output tokens: {completion_response.usage.output_tokens}\"\n                )\n                (\n                    prompt_tokens_cost_usd_dollar,\n                    completion_tokens_cost_usd_dollar,\n                ) = cost_per_token(\n                    model=self.state.model,\n                    prompt_tokens=completion_response.usage.input_tokens,\n                    completion_tokens=completion_response.usage.output_tokens,\n                )\n                _final_cost = (\n                    prompt_tokens_cost_usd_dollar + completion_tokens_cost_usd_dollar\n                )\n            except Exception as e:\n                self._log_prompt(messages, error=traceback.format_exc())\n                raise e\n\n\n            self._log_prompt(messages, completion_response.content)\n\n            usage = Usage(\n                completion_cost=_final_cost,\n                completion_tokens=completion_response.usage.output_tokens,\n                prompt_tokens=completion_response.usage.input_tokens,\n            )\n\n            return action_request, usage\n\n        if self.state.action_type() is None:\n            completion_response = litellm.completion(\n                model=self.state.model,\n                max_tokens=self.state.max_tokens,\n                temperature=self.state.temperature,\n                stop=self.state.stop_words(),\n                metadata=metadata,\n                messages=messages,\n            )\n            action_request = Content(\n                content=completion_response.choices[0].message.content\n            )\n        else:\n            client = instructor.from_litellm(\n                litellm.completion, mode=self.instructor_mode\n            )\n\n            try:\n                action_request, completion_response = (\n                    client.chat.completions.create_with_completion(\n                        model=self.state.model,\n                        max_tokens=self.state.max_tokens,\n                        temperature=self.state.temperature,\n                        stop=self.state.stop_words(),\n                        response_model=self.state.action_type(),\n                        metadata=metadata,\n                        messages=messages,\n                    )\n                )\n            except Exception as e:\n                self._log_prompt(messages, error=traceback.format_exc())\n                raise e\n\n        try:\n            cost = completion_cost(\n                completion_response=completion_response,\n                model=self.state.model,\n            )\n        except Exception as e:\n            self.log_info(f\"Error calculating completion cost: {e}\")\n            cost = 0\n\n        self._log_prompt(\n            messages, [completion_response.choices[0].message.model_dump()], error=None\n        )\n        prompt_tokens = completion_response.get(\"usage\", {}).get(\"prompt_tokens\", 0)\n        completion_tokens = completion_response.get(\"usage\", {}).get(\n            \"completion_tokens\", 0\n        )\n        usage = Usage(\n            completion_cost=cost,\n            completion_tokens=completion_tokens,\n            prompt_tokens=prompt_tokens,\n        )\n        return action_request, usage",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::9",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 603,
          "span_ids": [
            "AgenticLoop._to_completion_messages",
            "AgenticLoop.workspace",
            "AgenticLoop.state_count",
            "AgenticLoop.state",
            "AgenticLoop.trajectory"
          ],
          "start_line": 494,
          "end_line": 599,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    def state_count(self, state: AgenticState | None = None) -> int:\n        if not state:\n            return len(self._trajectory.transitions)\n\n        return len(\n            [s for s in self._trajectory.transitions if s.state.name == state.name]\n        )\n\n    @property\n    def state(self):\n        return self._current_state\n\n    @property\n    def workspace(self) -> Workspace:\n        return self._workspace\n\n    @property\n    def trajectory(self):\n        return self._trajectory\n\n    def _to_completion_messages(self) -> list[dict]:\n        messages = [{\"role\": \"system\", \"content\": self.state.system_prompt()}]\n\n        tool_call_id = None\n        state_messages = self.state.messages()\n        for message in state_messages:\n            if message.role == \"user\":\n                if tool_call_id and self.instructor_mode == instructor.Mode.TOOLS:\n                    messages.append(\n                        {\n                            \"role\": \"tool\",\n                            \"tool_call_id\": tool_call_id,\n                            \"content\": message.content,\n                        }\n                    )\n                elif (\n                    tool_call_id\n                    and self.instructor_mode == instructor.Mode.ANTHROPIC_TOOLS\n                ):\n                    messages.append(\n                        {\n                            \"role\": \"user\",\n                            \"content\": [\n                                {\n                                    \"tool_use_id\": tool_call_id,\n                                    \"content\": message.content,\n                                    \"type\": \"tool_result\",\n                                }\n                            ],\n                        }\n                    )\n                else:\n                    messages.append({\"role\": \"user\", \"content\": message.content})\n            elif message.role == \"assistant\":\n                if message.action:\n                    tool_call_id = generate_call_id()\n                    if self.instructor_mode == instructor.Mode.ANTHROPIC_TOOLS:\n                        messages.append(\n                            {\n                                \"role\": \"assistant\",\n                                \"content\": [\n                                    {\n                                        \"id\": tool_call_id,\n                                        \"input\": message.action.model_dump(),\n                                        \"type\": \"tool_use\",\n                                        \"name\": message.action.action_name,\n                                    }\n                                ],\n                            }\n                        )\n                    elif self.instructor_mode == instructor.Mode.TOOLS:\n                        messages.append(\n                            {\n                                \"role\": \"assistant\",\n                                \"tool_calls\": [\n                                    {\n                                        \"id\": tool_call_id,\n                                        \"type\": \"function\",\n                                        \"function\": {\n                                            \"name\": message.action.action_name,\n                                            \"arguments\": message.action.model_dump_json(\n                                                exclude_none=True\n                                            ),\n                                        },\n                                    }\n                                ],\n                            }\n                        )\n                    else:\n                        json_content = message.action.model_dump_json(indent=2)\n\n                        if self.state.model.startswith(\"deepseek\"):\n                            json_content = f\"```json\\n{json_content}\\n```\"\n\n                        messages.append(\n                            {\n                                \"role\": \"assistant\",\n                                \"content\": json_content,\n                            }\n                        )\n\n                else:\n                    tool_call_id = None\n                    messages.append({\"role\": \"assistant\", \"content\": message.content})\n\n        return messages",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::9"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::10",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 294,
          "span_ids": [
            "AgenticLoop.instructor_mode",
            "AgenticLoop._next_mock_action"
          ],
          "start_line": 601,
          "end_line": 638,
          "community": null
        },
        "content": "class AgenticLoop:\n\n    @property\n    def instructor_mode(self):\n        if self._instructor_mode:\n            return self._instructor_mode\n\n        return instructor_mode_by_model(self.state.model)\n\n    def _next_mock_action(\n        self,\n    ) -> ActionRequest | None:\n        if not self._mocked_actions:\n            return None\n\n        if self._reset_mocks_at_state and self.state.name == self._reset_mocks_at_state:\n            self.log_info(f\"Resetting mocked actions at state {self.state.name}\")\n            self._mocked_actions = []\n            return None\n\n        action = self._mocked_actions.pop(0)\n\n        if self.state.action_type():\n            try:\n                self.log_info(\n                    f\"Return mocked response with type {self.state.action_type().__name__} ({len(self._mocked_actions)} left).\"\n                )\n                return self.state.action_type().model_validate(action)\n\n            except Exception:\n                logger.error(\n                    f\"{self.transition_name}: Failed to parse {action} to {self.state.action_type().__name__} in state {self.state.name}\"\n                )\n                raise\n        elif \"content\" in action:\n            self.log_info(f\"Return mocked response ({len(self._mocked_actions)} left).\")\n            return Content(content=action[\"content\"])\n\n        else:\n            raise ValueError(f\"Mocked action {action} does not have 'content' field.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::10"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/loop.py::11",
        "metadata": {
          "file_path": "moatless\\loop.py",
          "file_name": "loop.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 658,
          "span_ids": [
            "AgenticLoop.log_info",
            "AgenticLoop._log_prompt",
            "generate_call_id",
            "AgenticLoop.transition_name"
          ],
          "start_line": 641,
          "end_line": 730,
          "community": null
        },
        "content": "class AgenticLoop:\n\n\n    def _log_prompt(\n        self,\n        messages: list[dict],\n        completion: Any | None = None,\n        error: Optional[str] = None,\n    ):\n        if not self._prompt_log_dir:\n            return\n\n        time_str = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        prompt_path = (\n            f\"{self._prompt_log_dir}/{self._current_state.id}_{self._current_state.name}\"\n        )\n        if self.state.retries() > 0:\n            prompt_path += f\"_retry_{self.state.retries()}\"\n\n        prompt_path += f\"_{time_str}.md\"\n\n        with open(prompt_path, \"w\") as f:\n            f.write(\"\\n\\n# Completion\\n\")\n\n            f.write(\"\\n\\n## Input\\n\")\n            for message in messages:\n                f.write(f\"\\n\\n### {message['role']}\\n\\n\")\n\n                if \"content\" in message:\n                    if isinstance(message[\"content\"], str):\n                        f.write(message[\"content\"])\n                    elif isinstance(message[\"content\"], list):\n                        for content in message[\"content\"]:\n                            if isinstance(content, str):\n                                f.write(content)\n                            if isinstance(content, dict) and \"content\" in content:\n                                f.write(content[\"content\"])\n                            else:\n                                f.write(\n                                    f\"\\n\\n```json\\n{json.dumps(content, indent=2)}\\n```\"\n                                )\n                elif isinstance(message.get(\"content\"), list):\n                    for block in message[\"content\"]:\n                        f.write(f\"\\n\\n### {block['tool_use_id']}\\n\")\n                        f.write(block[\"content\"])\n                else:\n                    f.write(f\"\\n\\n```json\\n{json.dumps(message, indent=2)}\\n```\")\n\n            if completion:\n                f.write(\"\\n\\n## Output\\n\")\n\n                if isinstance(completion, list):\n                    for block in completion:\n                        if isinstance(block, BaseModel):\n                            block = block.model_dump()\n\n                        if isinstance(block, dict):\n                            if block.get(\"content\"):\n                                f.write(f\"{block.get('content')}\\n\")\n                            else:\n                                f.write(f\"```json\\n{json.dumps(block, indent=2)}\\n```\")\n                        else:\n                            f.write(f\"```json\\n{json.dumps(block, indent=2)}\\n```\")\n                else:\n                    f.write(f\"```json\\n{json.dumps(completion, indent=2)}\\n```\")\n\n            if error:\n                f.write(\"\\n\\n# Error\\n\")\n                f.write(f\"\\n```\\n{error}\\n```\\n\")\n\n    def log_info(self, message: str):\n        logger.info(f\"{self.transition_name}: {message}\")\n\n    @property\n    def transition_name(self):\n        if self._current_state:\n            return f\"{self._current_state.name}:{self._current_state.id}\"\n        else:\n            return \"No state\"\n\n\ndef generate_call_id():\n    prefix = \"call_\"\n    chars = string.ascii_letters + string.digits\n    length = 24\n\n    random_chars = \"\".join(random.choices(chars, k=length))\n\n    random_string = prefix + random_chars\n\n    return random_string",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/loop.py::11"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/__init__.py::1",
        "metadata": {
          "file_path": "moatless\\repository\\__init__.py",
          "file_name": "__init__.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 25,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 3,
          "community": null
        },
        "content": "from moatless.repository.file import CodeFile, FileRepository, UpdateResult\nfrom moatless.repository.git import GitRepository",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/__init__.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::1",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 144,
          "span_ids": [
            "imports",
            "UpdateResult"
          ],
          "start_line": 1,
          "end_line": 24,
          "community": null
        },
        "content": "import difflib\nimport glob\nimport logging\nimport os\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict\n\nfrom moatless.codeblocks import get_parser_by_path\nfrom moatless.codeblocks.codeblocks import CodeBlockType, CodeBlockTypeGroup\nfrom moatless.codeblocks.module import Module\nfrom moatless.codeblocks.parser.python import PythonParser\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass UpdateResult:\n    file_path: str\n    updated: bool\n    diff: Optional[str] = None\n    error: Optional[str] = None\n    new_span_ids: set[str] | None = None",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::2",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 200,
          "span_ids": [
            "CodeFile.from_file",
            "CodeFile.supports_codeblocks",
            "CodeFile.from_content",
            "CodeFile"
          ],
          "start_line": 27,
          "end_line": 54,
          "community": null
        },
        "content": "class CodeFile(BaseModel):\n    file_path: str\n    content: str\n    module: Module | None = None\n    dirty: bool = False\n\n    model_config = ConfigDict(exclude={\"module\", \"dirty\"})\n\n    @classmethod\n    def from_file(cls, repo_path: str, file_path: str):\n        with open(os.path.join(repo_path, file_path)) as f:\n            parser = get_parser_by_path(file_path)\n            if parser:\n                content = f.read()\n                module = parser.parse(content)\n            else:\n                module = None\n            return cls(file_path=file_path, content=content, module=module)\n\n    @classmethod\n    def from_content(cls, file_path: str, content: str):\n        parser = PythonParser()\n        module = parser.parse(content)\n        return cls(file_path=file_path, content=content, module=module)\n\n    @property\n    def supports_codeblocks(self):\n        return self.module is not None",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::3",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 230,
          "span_ids": [
            "CodeFile.update_content_by_line_numbers"
          ],
          "start_line": 56,
          "end_line": 84,
          "community": null
        },
        "content": "class CodeFile(BaseModel):\n\n    def update_content_by_line_numbers(\n        self, start_line_index: int, end_line_index: int, replacement_content: str\n    ) -> UpdateResult:\n        replacement_lines = replacement_content.split(\"\\n\")\n\n        # Strip empty lines from the start and end\n        while replacement_lines and replacement_lines[0].strip() == \"\":\n            replacement_lines.pop(0)\n\n        while replacement_lines and replacement_lines[-1].strip() == \"\":\n            replacement_lines.pop()\n\n        original_lines = self.content.split(\"\\n\")\n\n        replacement_lines = remove_duplicate_lines(\n            replacement_lines, original_lines[end_line_index:]\n        )\n\n        updated_lines = (\n            original_lines[:start_line_index]\n            + replacement_lines\n            + original_lines[end_line_index:]\n        )\n        updated_content = \"\\n\".join(updated_lines)\n        logger.info(\n            f\"Updating content for {self.file_path} from line {start_line_index} to {end_line_index} with {len(replacement_lines)} lines. The updated file has {len(updated_lines)} lines.\"\n        )\n\n        return self.update_content(updated_content)",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::4",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 656,
          "span_ids": [
            "CodeFile.update_content"
          ],
          "start_line": 86,
          "end_line": 171,
          "community": null
        },
        "content": "class CodeFile(BaseModel):\n\n    def update_content(self, updated_content: str) -> UpdateResult:\n        diff = do_diff(self.file_path, self.content, updated_content)\n        if diff:\n            parser = get_parser_by_path(self.file_path)\n            if parser:\n                module = parser.parse(updated_content)\n                if not module.children:\n                    return UpdateResult(\n                        file_path=self.file_path,\n                        updated=False,\n                        diff=diff,\n                        error=\"The updated code is invalid.\",\n                    )\n\n                # TODO: Move the prompt instructions to the loop\n                error_blocks = module.find_errors()\n                validation_errors = module.find_validation_errors()\n                existing_placeholders = self.module.find_blocks_with_type(\n                    CodeBlockType.COMMENTED_OUT_CODE\n                )\n                new_placeholders = (\n                    module.find_blocks_with_type(CodeBlockType.COMMENTED_OUT_CODE)\n                    if not existing_placeholders\n                    else []\n                )\n                if error_blocks or validation_errors or new_placeholders:\n                    error_response = \"\"\n                    if error_blocks:\n                        for error_block in error_blocks:\n                            parent_block = error_block.find_type_group_in_parents(\n                                CodeBlockTypeGroup.STRUCTURE\n                            )\n                            if (\n                                parent_block\n                                and parent_block.type != CodeBlockType.MODULE\n                            ):\n                                error_response += f\"{parent_block.type.name} has invalid code:\\n\\n```{parent_block.to_string()}\\n```.\\n\"\n                            else:\n                                error_response += f\"This code is invalid: \\n```{error_block.to_string()}\\n```.\\n\"\n\n                    if new_placeholders:\n                        for new_placeholder in new_placeholders:\n                            parent_block = new_placeholder.find_type_group_in_parents(\n                                CodeBlockTypeGroup.STRUCTURE\n                            )\n                            if parent_block:\n                                error_response += f\"{parent_block.identifier} has a placeholder `{new_placeholder.content}` indicating that it's not fully implemented. Implement the full {parent_block.type.name} or reject the request.: \\n\\n```{parent_block.to_string()}```\\n\\n\"\n                            else:\n                                error_response += f\"There is a placeholder indicating out commented code : \\n```{new_placeholder.to_string()}\\n```. Do the full implementation or reject the request.\\n\"\n\n                    for validation_error in validation_errors:\n                        error_response += f\"{validation_error}\\n\"\n\n                    logger.warning(\n                        f\"Errors in updated file {self.file_path}:\\n{error_response}\"\n                    )\n\n                    return UpdateResult(\n                        file_path=self.file_path,\n                        updated=False,\n                        diff=diff,\n                        error=error_response,\n                    )\n\n                new_span_ids = module.get_all_span_ids() - set(\n                    self.module.get_all_span_ids()\n                )\n\n                logger.info(\n                    f\"Updated content for {self.file_path} with {len(new_span_ids)} new span ids.\"\n                )\n                self.module = module\n            else:\n                new_span_ids = []\n\n            self.dirty = True\n            self.content = updated_content\n\n            return UpdateResult(\n                file_path=self.file_path,\n                updated=True,\n                diff=diff,\n                new_span_ids=new_span_ids,\n            )\n\n        return UpdateResult(file_path=self.file_path, updated=False)",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::5",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 143,
          "span_ids": [
            "FileRepository.repo_dir",
            "FileRepository.snapshot",
            "FileRepository.restore_from_snapshot",
            "FileRepository.restore_from_disk",
            "FileRepository",
            "FileRepository.path",
            "FileRepository.__init__",
            "FileRepository.dict"
          ],
          "start_line": 174,
          "end_line": 198,
          "community": null
        },
        "content": "class FileRepository:\n    def __init__(self, repo_path: str):\n        self._repo_path = repo_path\n        self._files: dict[str, CodeFile] = {}\n\n    @property\n    def repo_dir(self):\n        return self._repo_path\n\n    def dict(self):\n        return {\"type\": \"file\", \"path\": self._repo_path}\n\n    def snapshot(self) -> dict:\n        return {}\n\n    def restore_from_snapshot(self, snapshot: dict):\n        pass\n\n    def restore_from_disk(self):\n        for file_path in self._files.keys():\n            self.get_file(file_path, refresh=True)\n\n    @property\n    def path(self):\n        return self._repo_path",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::6",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 276,
          "span_ids": [
            "FileRepository.get_file"
          ],
          "start_line": 200,
          "end_line": 236,
          "community": null
        },
        "content": "class FileRepository:\n\n    def get_file(\n        self, file_path: str, refresh: bool = False, from_origin: bool = False\n    ):\n        \"\"\"\n        Get a file from the repository.\n\n        Args:\n\n        \"\"\"\n        existing_file = self._files.get(file_path)\n        if not existing_file or refresh or from_origin:\n            full_file_path = os.path.join(self._repo_path, file_path)\n            if not os.path.exists(full_file_path):\n                logger.warning(f\"File not found: {full_file_path}\")\n                return None\n            if not os.path.isfile(full_file_path):\n                logger.warning(f\"{full_file_path} is not a file\")\n                return None\n\n            with open(full_file_path) as f:\n                parser = get_parser_by_path(file_path)\n                if parser:\n                    content = f.read()\n                    module = parser.parse(content)\n                    found_file = CodeFile(file_path=file_path, content=content, module=module)\n                else:\n                    found_file = CodeFile(file_path=file_path, content=f.read())\n\n            if not existing_file:\n                existing_file = found_file\n                self._files[file_path] = existing_file\n            elif refresh or not from_origin:\n                existing_file.content = found_file.content\n                existing_file.module = found_file.module\n                existing_file.dirty = False\n\n        return existing_file",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::7",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 364,
          "span_ids": [
            "FileRepository.find_files",
            "FileRepository.has_matching_files",
            "FileRepository.file_match",
            "FileRepository.save_file",
            "FileRepository.save",
            "FileRepository.matching_files"
          ],
          "start_line": 238,
          "end_line": 287,
          "community": null
        },
        "content": "class FileRepository:\n\n    def save_file(self, file_path: str, updated_content: Optional[str] = None):\n        file = self._files.get(file_path)\n        full_file_path = os.path.join(self._repo_path, file_path)\n        with open(full_file_path, \"w\") as f:\n            updated_content = updated_content or file.module.to_string()\n            f.write(updated_content)\n\n        file.dirty = False\n\n    def save(self):\n        for file in self._files.values():\n            if file.dirty:\n                self.save_file(file.file_path, file.content)\n\n    def matching_files(self, file_pattern: str):\n        matched_files = []\n        for matched_file in glob.iglob(\n            file_pattern, root_dir=self._repo_path, recursive=True\n        ):\n            matched_files.append(matched_file)\n\n        if not matched_files and not file_pattern.startswith(\"*\"):\n            return self.matching_files(f\"**/{file_pattern}\")\n\n        return matched_files\n\n    def find_files(self, file_patterns: list[str]) -> set[str]:\n        found_files = set()\n        for file_pattern in file_patterns:\n            matched_files = self.matching_files(file_pattern)\n            found_files.update(matched_files)\n\n        return found_files\n\n    def has_matching_files(self, file_pattern: str):\n        for _matched_file in glob.iglob(\n            file_pattern, root_dir=self._repo_path, recursive=True\n        ):\n            return True\n        return False\n\n    def file_match(self, file_pattern: str, file_path: str):\n        match = False\n        for matched_file in glob.iglob(\n            file_pattern, root_dir=self._repo_path, recursive=True\n        ):\n            if matched_file == file_path:\n                match = True\n                break\n        return match",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/file.py::8",
        "metadata": {
          "file_path": "moatless\\repository\\file.py",
          "file_name": "file.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 180,
          "span_ids": [
            "do_diff",
            "remove_duplicate_lines"
          ],
          "start_line": 290,
          "end_line": 318,
          "community": null
        },
        "content": "def remove_duplicate_lines(replacement_lines, original_lines):\n    \"\"\"\n    Removes overlapping lines at the end of replacement_lines that match the beginning of original_lines.\n    \"\"\"\n    if not replacement_lines or not original_lines:\n        return replacement_lines\n\n    max_overlap = min(len(replacement_lines), len(original_lines))\n\n    for overlap in range(max_overlap, 0, -1):\n        if replacement_lines[-overlap:] == original_lines[:overlap]:\n            return replacement_lines[:-overlap]\n\n    return replacement_lines\n\n\ndef do_diff(\n    file_path: str, original_content: str, updated_content: str\n) -> Optional[str]:\n    return \"\".join(\n        difflib.unified_diff(\n            original_content.strip().splitlines(True),\n            updated_content.strip().splitlines(True),\n            fromfile=file_path,\n            tofile=file_path,\n            lineterm=\"\\n\",\n        )\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/file.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/git.py::1",
        "metadata": {
          "file_path": "moatless\\repository\\git.py",
          "file_name": "git.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 649,
          "span_ids": [
            "GitRepository",
            "GitRepository.commit",
            "GitRepository.from_repo",
            "GitRepository.dict",
            "GitRepository.save",
            "imports",
            "GitRepository.snapshot",
            "GitRepository.save_file",
            "GitRepository.from_dict",
            "GitRepository.restore_from_snapshot",
            "GitRepository.__init__"
          ],
          "start_line": 1,
          "end_line": 99,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nimport litellm\nfrom git import Repo\n\nfrom moatless.repository.file import FileRepository\nfrom moatless.settings import Settings\nfrom moatless.utils.repo import maybe_clone, checkout_commit\n\nlogger = logging.getLogger(__name__)\n\n\nclass GitRepository(FileRepository):\n    def __init__(\n        self, repo_path: str, git_repo_url: Optional[str], commit: Optional[str] = None\n    ):\n        super().__init__(repo_path)\n        self._repo_path = repo_path\n        self._repo_url = git_repo_url\n        self._repo = Repo(path=repo_path)\n        if not self._repo.heads:\n            raise Exception(\n                \"Git repository has no heads, you need to do an initial commit.\"\n            )\n\n        # TODO: Add support for branches\n        # self._current_branch = self._repo.active_branch.name\n\n        # TODO: Check if current branch is mainline\n\n        # TODO: Check if repo is dirty\n\n        if commit:\n            checkout_commit(repo_path, commit)\n\n        self._current_commit = self._repo.head.commit.hexsha\n        self._initial_commit = self._current_commit\n\n    @classmethod\n    def from_repo(cls, git_repo_url: str, repo_path: str, commit: Optional[str] = None):\n        logger.info(\n            f\"Create GitRepository for {git_repo_url} with commit {commit} on path {repo_path} \"\n        )\n\n        maybe_clone(git_repo_url, repo_path)\n\n        return cls(repo_path=repo_path, git_repo_url=git_repo_url, commit=commit)\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        return cls.from_repo(\n            git_repo_url=data[\"repo_url\"],\n            repo_path=data[\"path\"],\n            commit=data[\"commit\"],\n        )\n\n    def restore_from_snapshot(self, snapshot: dict):\n        self._current_commit = snapshot[\"commit\"]\n\n\n        self._repo.git.checkout(self._current_commit)\n\n        # TODO: Check diff and only reset changed files\n\n        self.restore_from_disk()\n\n    def dict(self):\n        return {\n            \"type\": \"git\",\n            \"repo_path\": self._repo_path,\n            \"git_repo_url\": self._repo_url,\n            \"commit\": self._initial_commit,\n        }\n\n    def snapshot(self) -> dict:\n        return {\n            \"commit\": self._current_commit,\n        }\n\n    def save_file(self, file_path: str, updated_content: Optional[str] = None):\n        super().save_file(file_path, updated_content)\n        self.commit(file_path)\n\n    def save(self):\n        super().save()\n        self.commit()\n\n    def commit(self, file_path: str | None = None):\n        commit_message = self.commit_message(file_path)\n\n        if file_path:\n            self._repo.index.add(file_path)\n        else:\n            self._repo.index.add(\"*\")\n        self._repo.index.commit(commit_message)\n        self._current_commit = self._repo.head.commit.hexsha\n\n        logger.info(f\"Committed changes to git with message '{commit_message}' and commit hash '{self._current_commit}'\")",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/git.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "repository/git.py::2",
        "metadata": {
          "file_path": "moatless\\repository\\git.py",
          "file_name": "git.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 231,
          "span_ids": [
            "GitRepository.diff",
            "GitRepository.commit_message"
          ],
          "start_line": 101,
          "end_line": 129,
          "community": null
        },
        "content": "class GitRepository(FileRepository):\n\n    def commit_message(self, file_path: str | None = None) -> str:\n        if file_path:\n            diff = self._repo.git.diff(\"HEAD\", file_path)\n        else:\n            diff = self._repo.git.diff(\"HEAD\")\n\n        if not diff:\n            return \"No changes.\"\n\n        if Settings.cheap_model:\n            prompt = f\"Generate a concise commit message for the following git diff\"\n            if file_path:\n                prompt += f\" of file {file_path}\"\n            prompt += f\":\\n\\n{diff}\\n\\nCommit message:\"\n\n            try:\n                response = litellm.completion(\n                    model=Settings.cheap_model,\n                    messages=[{\"role\": \"user\", \"content\": prompt}],\n                    max_tokens=50,\n                )\n                return response.choices[0].message.content.strip()\n            except Exception as e:\n                logging.error(f\"Error generating commit message: {e}\")\n\n        return \"Automated commit by Moatless Tools\"\n\n    def diff(self):\n        return self._repo.git.diff(self._initial_commit, self._current_commit)",
        "summary": null,
        "ctxt_list": [],
        "id": "repository/git.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/settings.py::1",
        "metadata": {
          "file_path": "moatless\\settings.py",
          "file_name": "settings.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 385,
          "span_ids": [
            "_Settings.max_message_tokens",
            "_Settings.cheap_model",
            "_Settings.max_context_tokens",
            "_Settings.cheap_model_3",
            "_Settings",
            "imports",
            "_Settings.default_model_1",
            "_Settings.default_model",
            "_Settings.embed_model_5",
            "_Settings.max_message_tokens_9",
            "_Settings.max_context_tokens_7",
            "_Settings.embed_model",
            "impl"
          ],
          "start_line": 1,
          "end_line": 56,
          "community": null
        },
        "content": "import os\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass _Settings:\n    _default_model: str = os.environ.get(\"DEFAULT_MODEL\", \"gpt-4o-2024-05-13\")\n    _cheap_model: str | None = os.environ.get(\"CHEAP_MODEL\", \"gpt-4o-mini-2024-07-18\")\n    _embed_model: str = \"text-embedding-3-small\"\n\n    _max_context_tokens: int = 8000\n    _max_message_tokens: int = 16000\n\n    @property\n    def default_model(self) -> str:\n        return self._default_model\n\n    @default_model.setter\n    def default_model(self, default_model: str) -> None:\n        self._default_model = default_model\n\n    @property\n    def cheap_model(self) -> str | None:\n        return self._cheap_model\n\n    @cheap_model.setter\n    def cheap_model(self, cheap_model: str | None) -> None:\n        self._cheap_model = cheap_model\n\n    @property\n    def embed_model(self) -> str:\n        return self._embed_model\n\n    @embed_model.setter\n    def embed_model(self, embed_model: str) -> None:\n        self._embed_model = embed_model\n\n    @property\n    def max_context_tokens(self) -> int:\n        return self._max_context_tokens\n\n    @max_context_tokens.setter\n    def max_context_tokens(self, max_context_tokens: int) -> None:\n        self._max_context_tokens = max_context_tokens\n\n    @property\n    def max_message_tokens(self) -> int:\n        return self._max_message_tokens\n\n    @max_message_tokens.setter\n    def max_message_tokens(self, max_message_tokens: int) -> None:\n        self._max_message_tokens = max_message_tokens\n\n\nSettings = _Settings()",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/settings.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/state.py::1",
        "metadata": {
          "file_path": "moatless\\state.py",
          "file_name": "state.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 124,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 22,
          "community": null
        },
        "content": "import logging\nimport sys\nimport importlib\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Optional, List\nfrom copy import deepcopy\n\nfrom pydantic import BaseModel, Field, PrivateAttr, ConfigDict, model_validator\n\nfrom moatless.file_context import FileContext\nfrom moatless.repository import FileRepository\nfrom moatless.types import (\n    ActionRequest,\n    ActionResponse,\n    ActionTransaction,\n    FileWithSpans,\n    Message, Content, AssistantMessage,\n    Usage, UserMessage,\n)\nfrom moatless.workspace import Workspace\n\nlogger = logging.getLogger(__name__)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/state.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/state.py::2",
        "metadata": {
          "file_path": "moatless\\state.py",
          "file_name": "state.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 740,
          "span_ids": [
            "AgenticState.finish",
            "AgenticState._execute_action",
            "AgenticState.executed",
            "AgenticState.required_fields",
            "AgenticState.workspace",
            "AgenticState.file_repo",
            "AgenticState.last_action",
            "AgenticState.file_context",
            "AgenticState.initial_message",
            "AgenticState.name",
            "AgenticState.response",
            "AgenticState.create_file_context",
            "AgenticState",
            "AgenticState.__init__",
            "AgenticState.init",
            "AgenticState.messages",
            "AgenticState.handle_action"
          ],
          "start_line": 25,
          "end_line": 132,
          "community": null
        },
        "content": "class AgenticState(ABC, BaseModel):\n    id: int = Field(..., description=\"The unique identifier of the state\")\n    previous_state: Optional[\"AgenticState\"] = Field(\n        default=None, description=\"The state that led to this state\"\n    )\n    next_states: List[\"AgenticState\"] = Field(\n        default_factory=list, description=\"The states this state transitioned to\"\n    )\n    model: Optional[str] = Field(\n        default=None, description=\"The model to use for completion\"\n    )\n    temperature: float = Field(0.0, description=\"The temperature to use for completion\")\n    max_tokens: int = Field(\n        1000, description=\"The maximum number of tokens to generate\"\n    )\n    include_message_history: bool = Field(\n        default=False,\n        description=\"The message history from previous initations should be included in the completion request\",\n    )\n    max_iterations: Optional[int] = Field(\n        None, description=\"The maximum number of transitions to this state.\"\n    )\n\n    _workspace: Optional[Workspace] = PrivateAttr(None)\n    _initial_message: Optional[str] = PrivateAttr(None)\n\n    _executed: bool = PrivateAttr(False)\n    _actions: List[ActionTransaction] = PrivateAttr(default_factory=list)\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        exclude={\"previous_state\", \"next_states\"}\n    )\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        self._workspace = data.get('_workspace')\n        self._initial_message = data.get('_initial_message')\n\n    def handle_action(self, action: ActionRequest, usage: Usage | None) -> ActionResponse:\n        if self._executed:\n            raise ValueError(f\"State has already been executed\")\n\n        response = self._execute_action(action)\n        self._actions.append(ActionTransaction(request=action, response=response, usage=usage))\n\n        if response.trigger and response.trigger != \"retry\":\n            self._executed = True\n\n        return response\n\n    @abstractmethod\n    def _execute_action(self, action: ActionRequest) -> ActionResponse:\n        raise NotImplementedError\n\n    @property\n    def name(self):\n        return self.__class__.__name__\n\n    @property\n    def executed(self):\n        return self._executed\n\n    @property\n    def last_action(self) -> Optional[ActionTransaction]:\n        return self._actions[-1] if self._actions else None\n\n    @property\n    def response(self) -> Optional[ActionResponse]:\n        return self._actions[-1].response if self._actions else None\n\n    @property\n    def workspace(self) -> Workspace:\n        return self._workspace\n\n    @property\n    def file_repo(self) -> FileRepository:\n        return self._workspace.file_repo\n\n    @property\n    def file_context(self) -> FileContext:\n        return self._workspace.file_context\n\n    @property\n    def initial_message(self) -> str:\n        return self._initial_message\n\n    def create_file_context(\n        self, files: list[FileWithSpans] = None, **kwargs\n    ) -> FileContext:\n        if files is None:\n            files = []\n        return self.workspace.create_file_context(files, **kwargs)\n\n    def init(self):\n        \"\"\"Initialization logic for the state.\"\"\"\n        pass\n\n    def finish(self, message: str):\n        # TODO!!\n        logger.info(message)\n\n    def messages(self) -> list[Message]:\n        return []\n\n    @classmethod\n    def required_fields(cls) -> set[str]:\n        return set()",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/state.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/state.py::3",
        "metadata": {
          "file_path": "moatless\\state.py",
          "file_name": "state.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 202,
          "span_ids": [
            "AgenticState.get_previous_states"
          ],
          "start_line": 134,
          "end_line": 157,
          "community": null
        },
        "content": "class AgenticState(ABC, BaseModel):\n\n    def get_previous_states(self, state: Optional[\"AgenticState\"] = None) -> list[\"AgenticState\"]:\n        \"\"\"\n        Retrieves previous states of the same type as the given state.\n        If no state is provided, it returns all previous states.\n\n        Args:\n            state (AgenticState | None): The state to filter by. If None, all previous states are returned.\n\n        Returns:\n            list: A list of previous states, filtered by type if a state is provided.\n        \"\"\"\n        previous_states = []\n        current_state = self\n\n        while current_state and current_state.previous_state:\n            current_state = current_state.previous_state\n            if not state or isinstance(current_state, type(state)):\n                previous_states.insert(0, current_state)\n\n        logger.debug(\n            f\"Found {len(previous_states)} previous states of type {state.__class__.__name__ if state else 'all types'}\"\n        )\n\n        return previous_states",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/state.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/state.py::4",
        "metadata": {
          "file_path": "moatless\\state.py",
          "file_name": "state.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 469,
          "span_ids": [
            "AgenticState.validate_previous_state",
            "AgenticState.retries",
            "AgenticState.retry_messages",
            "AgenticState.system_prompt",
            "AgenticState.model_dump",
            "AgenticState.total_cost",
            "AgenticState.clone",
            "AgenticState.action_type",
            "AgenticState.__eq__",
            "AgenticState.stop_words"
          ],
          "start_line": 159,
          "end_line": 238,
          "community": null
        },
        "content": "class AgenticState(ABC, BaseModel):\n\n    def retries(self) -> int:\n        retries = 0\n        for action in reversed(self._actions):\n            if action.response.trigger == \"retry\":\n                retries += 1\n            else:\n                return retries\n\n        return retries\n\n    def retry_messages(self) -> list[Message]:\n        messages: list[Message] = []\n\n        for action in self._actions:\n            if isinstance(action.request, Content):\n                messages.append(\n                    AssistantMessage(\n                        content=action.request.content,\n                    )\n                )\n            else:\n                messages.append(AssistantMessage(action=action.request))\n\n            if action.response.retry_message:\n                messages.append(\n                    UserMessage(\n                        content=action.response.retry_message,\n                    )\n                )\n\n        return messages\n\n    def system_prompt(self) -> str:\n        return \"\"\n\n    def action_type(self) -> type[ActionRequest] | None:\n        \"\"\"\n        The type of the action to expect in the completion response.\n        If not set a content string is expected.\n        \"\"\"\n        raise NotImplementedError\n\n    def stop_words(self) -> list[str] | None:\n        return None\n\n    def model_dump(self, **kwargs):\n        if 'exclude' not in kwargs:\n            kwargs['exclude'] = {\"previous_state\", \"next_states\"}\n\n        data = super().model_dump(**kwargs)\n        return data\n\n    @classmethod\n    @model_validator(mode=\"before\")\n    def validate_previous_state(cls, values):\n        if isinstance(obj, dict) and \"previous_state_id\" in obj:\n            obj = obj.copy()\n            obj[\"previous_state\"] = None\n        return super().model_validate(obj)\n\n    def clone(self) -> \"AgenticState\":\n        new_state = self.__class__(**self.model_dump())\n        if hasattr(self, '_workspace'):\n            new_state._workspace = self._workspace\n        return new_state\n\n    def total_cost(self):\n        total_cost = 0\n        for action in self._actions:\n            if action.usage:\n                total_cost += action.usage.completion_cost\n\n        return total_cost\n\n    def __eq__(self, other):\n        if not isinstance(other, AgenticState):\n            return NotImplemented\n        if self.model_dump() != other.model_dump():\n            return False\n        return True",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/state.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/state.py::5",
        "metadata": {
          "file_path": "moatless\\state.py",
          "file_name": "state.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 121,
          "span_ids": [
            "Pending",
            "Pending.__init__",
            "NoopState",
            "Rejected",
            "Finished",
            "NoopState._execute_action"
          ],
          "start_line": 241,
          "end_line": 260,
          "community": null
        },
        "content": "class NoopState(AgenticState):\n\n    def _execute_action(self, action: ActionRequest):\n        raise ValueError(\"NoopState cannot handle actions\")\n\n\nclass Finished(NoopState):\n    message: Optional[str] = None\n    output: dict[str, Any] | None = None\n\n\nclass Rejected(NoopState):\n    message: Optional[str] = None\n\n\nclass Pending(NoopState):\n    def __init__(self, **data):\n        if 'id' not in data:\n            data['id'] = 0\n        super().__init__(**data)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/state.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/state.py::6",
        "metadata": {
          "file_path": "moatless\\state.py",
          "file_name": "state.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 241,
          "span_ids": [
            "get_state_class"
          ],
          "start_line": 263,
          "end_line": 297,
          "community": null
        },
        "content": "def get_state_class(name: str) -> type[AgenticState]:\n    builtin_states = {\n        \"NoopState\": NoopState,\n        \"Finished\": Finished,\n        \"Rejected\": Rejected,\n        \"Pending\": Pending,\n    }\n    if name in builtin_states:\n        return builtin_states[name]\n\n    # If not a built-in state, try to import dynamically\n    possible_modules = [\n        \"moatless.edit\",\n        \"moatless.find\",\n    ]\n\n    for module_name in possible_modules:\n\n        try:\n            module = importlib.import_module(module_name)\n            if hasattr(module, name):\n                cls = getattr(module, name)\n                if isinstance(cls, type) and issubclass(cls, AgenticState):\n                    return cls\n        except ImportError:\n            logger.debug(f\"Could not import module {module_name}\")\n\n    # If still not found, try sys.modules as a fallback\n    for module in sys.modules.values():\n        if hasattr(module, name):\n            cls = getattr(module, name)\n            if isinstance(cls, type) and issubclass(cls, AgenticState):\n                return cls\n\n    raise ValueError(f\"State {name} not found\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/state.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/trajectory.py::1",
        "metadata": {
          "file_path": "moatless\\trajectory.py",
          "file_name": "trajectory.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 303,
          "span_ids": [
            "imports",
            "TrajectoryState.model_dump",
            "TrajectoryState",
            "TrajectoryState.name"
          ],
          "start_line": 1,
          "end_line": 48,
          "community": null
        },
        "content": "import json\nimport logging\nfrom datetime import datetime\nfrom typing import Any, Optional, List\n\nfrom pydantic import BaseModel, Field\nfrom pydantic_core import to_jsonable_python\n\nfrom moatless.workspace import Workspace\nfrom moatless.transition_rules import TransitionRules\nfrom moatless.state import AgenticState, get_state_class\nfrom moatless.types import ActionRequest, ActionTransaction, ActionResponse, Usage, Content\n\nlogger = logging.getLogger(__name__)\n\n\n\nclass TrajectoryState(BaseModel):\n    id: int\n    timestamp: datetime = Field(default_factory=datetime.now)\n    snapshot: Optional[dict] = None\n    state: AgenticState\n\n    @property\n    def name(self):\n        return self.state.name if self.state else None\n\n    def model_dump(self, **kwargs):\n        data = {\n            \"id\": self.id,\n            \"name\": self.state.name,\n            \"timestamp\": self.timestamp,\n        }\n\n        if self.snapshot:\n            data[\"snapshot\"] = self.snapshot\n\n        if self.state.previous_state:\n            data[\"previous_state_id\"] = self.state.previous_state.id\n\n        properties = self.state.model_dump(exclude={\"previous_state\", \"next_states\", \"id\"}, **kwargs) if self.state else None\n        if properties:\n            data[\"properties\"] = properties\n\n        if self.state._actions:\n            data[\"actions\"] = [a.model_dump(**kwargs) for a in self.state._actions]\n\n        return data",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/trajectory.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/trajectory.py::2",
        "metadata": {
          "file_path": "moatless\\trajectory.py",
          "file_name": "trajectory.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 182,
          "span_ids": [
            "Trajectory",
            "Trajectory.__init__"
          ],
          "start_line": 51,
          "end_line": 74,
          "community": null
        },
        "content": "class Trajectory:\n    def __init__(\n        self,\n        name: str,\n        workspace: Workspace,\n        initial_message: Optional[str] = None,\n        persist_path: Optional[str] = None,\n        transition_rules: Optional[TransitionRules] = None,\n    ):\n        self._name = name\n        self._persist_path = persist_path\n        self._initial_message = initial_message\n        self._workspace = workspace\n\n        # Workaround to set to keep the current initial workspace state when loading an existing trajectory.\n        # TODO: Remove this when we have a better way to handle this.\n        self._initial_workspace_state = self._workspace.dict()\n\n        self._transition_rules = transition_rules\n\n        self._current_transition_id = 0\n        self._transitions: dict[int, TrajectoryState] = {}\n\n        self._info: dict[str, Any] = {}",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/trajectory.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/trajectory.py::3",
        "metadata": {
          "file_path": "moatless\\trajectory.py",
          "file_name": "trajectory.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 546,
          "span_ids": [
            "Trajectory.load"
          ],
          "start_line": 76,
          "end_line": 148,
          "community": null
        },
        "content": "class Trajectory:\n\n    @classmethod\n    def load(cls, file_path: str):\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n\n        if \"transition_rules\" in data:\n            transition_rules = TransitionRules.model_validate(data[\"transition_rules\"])\n        else:\n            transition_rules = None\n\n        workspace = Workspace.from_dict(data[\"workspace\"])\n        trajectory = cls(\n            name=data[\"name\"],\n            initial_message=data[\"initial_message\"],\n            transition_rules=transition_rules,\n            workspace=workspace\n        )\n\n        trajectory._info = data.get(\"info\", {})\n\n        trajectory._transitions = {}\n        trajectory._current_transition_id = data.get(\"current_transition_id\", 0)\n\n        for t in data[\"transitions\"]:\n            state_class = get_state_class(t[\"name\"])\n            state_data = t[\"properties\"]\n            state_data[\"id\"] = t[\"id\"]\n            state = state_class.model_validate(state_data)\n\n            state._workspace = trajectory._workspace\n            state._initial_message = trajectory._initial_message\n            state._actions = []\n            if \"actions\" in t:\n                for a in t[\"actions\"]:\n                    try:\n                        if state.action_type() is None:\n                            request = Content.model_validate(a[\"request\"])\n                        else:\n                            request = state.action_type().model_validate(a[\"request\"])\n                        response = ActionResponse.model_validate(a.get(\"response\"))\n                        if a.get(\"usage\"):\n                            usage = Usage.model_validate(a.get(\"usage\"))\n                        else:\n                            usage = None\n                        state._actions.append(ActionTransaction(request=request, response=response, usage=usage))\n                    except Exception as e:\n                        logger.exception(f\"Error loading action for state {state.name}: {a}\")\n                        raise e\n\n            trajectory_state = TrajectoryState(\n                id=t[\"id\"],\n                timestamp=datetime.fromisoformat(t[\"timestamp\"]),\n                snapshot=t.get(\"snapshot\"),\n                state=state\n            )\n\n            trajectory._transitions[t[\"id\"]] = trajectory_state\n\n        # Set previous_state and next_states\n        for t in data[\"transitions\"]:\n            try:\n                current_state = trajectory._transitions[t[\"id\"]].state\n                if t.get(\"previous_state_id\") is not None:\n                    current_state.previous_state = trajectory._transitions.get(t[\"previous_state_id\"]).state\n            except KeyError as e:\n                logger.exception(f\"Missing key {e}, existing keys: {trajectory._transitions.keys()}\")\n                raise\n\n        trajectory._info = data.get(\"info\", {})\n\n        logger.info(f\"Loaded trajectory {trajectory._name} with {len(trajectory._transitions)} transitions\")\n\n        return trajectory",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/trajectory.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/trajectory.py::4",
        "metadata": {
          "file_path": "moatless\\trajectory.py",
          "file_name": "trajectory.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 216,
          "span_ids": [
            "Trajectory.info",
            "Trajectory.get_current_state",
            "Trajectory.transition_rules",
            "Trajectory.update_workspace_to_current_state",
            "Trajectory.states",
            "Trajectory.initial_message",
            "Trajectory.transitions",
            "Trajectory.set_current_state",
            "Trajectory.workspace"
          ],
          "start_line": 150,
          "end_line": 182,
          "community": null
        },
        "content": "class Trajectory:\n\n    @property\n    def initial_message(self):\n        return self._initial_message\n\n    @property\n    def info(self):\n        return self._info\n\n    @property\n    def states(self) -> List[dict]:\n        return [t.state.model_dump() for t in self.transitions]\n\n    @property\n    def transition_rules(self) -> TransitionRules:\n        return self._transition_rules\n\n    @property\n    def workspace(self) -> Workspace:\n        return self._workspace\n\n    @property\n    def transitions(self) -> List[TrajectoryState]:\n        return sorted(self._transitions.values(), key=lambda x: x.id)\n\n    def set_current_state(self, state: AgenticState):\n        self._current_transition_id = state.id\n        self._maybe_persist()\n\n    def get_current_state(self) -> AgenticState:\n        return self._transitions.get(self._current_transition_id).state\n\n    def update_workspace_to_current_state(self):\n        self.restore_from_snapshot(self._transitions[self._current_transition_id])",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/trajectory.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/trajectory.py::5",
        "metadata": {
          "file_path": "moatless\\trajectory.py",
          "file_name": "trajectory.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 116,
          "span_ids": [
            "Trajectory.restore_from_snapshot"
          ],
          "start_line": 184,
          "end_line": 195,
          "community": null
        },
        "content": "class Trajectory:\n\n    def restore_from_snapshot(self, state: TrajectoryState):\n        if not state.snapshot:\n            logger.info(f\"restore_from_snapshot(state: {state.id}:{state.name}) No snapshot found\")\n            return\n\n        logger.info(f\"restore_from_snapshot(starte: {state.id}:{state.name}) Restoring from snapshot\")\n\n        if state.snapshot.get(\"repository\"):\n            self._workspace.file_repo.restore_from_snapshot(state.snapshot[\"repository\"])\n\n        if state.snapshot.get(\"file_context\"):\n            self._workspace.file_context.restore_from_snapshot(state.snapshot[\"file_context\"])",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/trajectory.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/trajectory.py::6",
        "metadata": {
          "file_path": "moatless\\trajectory.py",
          "file_name": "trajectory.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 258,
          "span_ids": [
            "Trajectory.save_info",
            "Trajectory.get_expected_states",
            "Trajectory.save_state",
            "Trajectory.get_mocked_actions",
            "Trajectory.get_state"
          ],
          "start_line": 197,
          "end_line": 232,
          "community": null
        },
        "content": "class Trajectory:\n\n    def save_state(self, state: AgenticState):\n        if state.id in self._transitions:\n            self._transitions[state.id].state = state\n        else:\n            transition = TrajectoryState(\n                id=state.id,\n                state=state,\n                snapshot=state.workspace.snapshot() if state.workspace else None,\n            )\n            self._transitions[state.id] = transition\n\n        self._maybe_persist()\n\n    def get_state(self, state_id: int) -> TrajectoryState | None:\n        return self._transitions.get(state_id)\n\n    def save_info(self, info: dict):\n        self._info = info\n        self._maybe_persist()\n\n    def get_mocked_actions(self) -> List[dict]:\n        \"\"\"\n        Return a list of actions that can be used to mock the trajectory.\n        \"\"\"\n        actions = []\n\n        for transition in self.transitions:\n            for action in transition.state._actions:\n                actions.append(action.request.model_dump())\n        return actions\n\n    def get_expected_states(self) -> List[str]:\n        \"\"\"\n        Return a list of expected states in the trajectory to use for verification when rerunning the trajectory.\n        \"\"\"\n        return [transition.state.name for transition in self.transitions[1:]]",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/trajectory.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/trajectory.py::7",
        "metadata": {
          "file_path": "moatless\\trajectory.py",
          "file_name": "trajectory.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 190,
          "span_ids": [
            "Trajectory.persist",
            "Trajectory._maybe_persist",
            "Trajectory.to_dict"
          ],
          "start_line": 234,
          "end_line": 261,
          "community": null
        },
        "content": "class Trajectory:\n\n    def to_dict(self):\n        return {\n            \"name\": self._name,\n            \"transition_rules\": self._transition_rules.model_dump(\n                exclude_none=True\n            )\n            if self._transition_rules\n            else None,\n            \"workspace\": self._initial_workspace_state,\n            \"initial_message\": self._initial_message,\n            \"current_transition_id\": self._current_transition_id,\n            \"transitions\": [t.model_dump(exclude_none=True) for t in self.transitions],\n            \"info\": self._info,\n        }\n\n    def _maybe_persist(self):\n        if self._persist_path:\n            self.persist(self._persist_path)\n\n    def persist(self, file_path: str):\n        with open(f\"{file_path}\", \"w\") as f:\n            f.write(\n                json.dumps(\n                    self.to_dict(),\n                    indent=2,\n                    default=to_jsonable_python,\n                )\n            )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/trajectory.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transition_rules.py::1",
        "metadata": {
          "file_path": "moatless\\transition_rules.py",
          "file_name": "transition_rules.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 444,
          "span_ids": [
            "TransitionRule",
            "TransitionRule.model_dump",
            "imports",
            "TransitionRule.get",
            "TransitionRule.validate_state_classes"
          ],
          "start_line": 1,
          "end_line": 62,
          "community": null
        },
        "content": "import logging\n\nfrom pydantic import BaseModel, Field, PrivateAttr, model_validator\nfrom typing import Any, Type, Optional\n\nfrom moatless.settings import Settings\nfrom moatless.state import AgenticState, get_state_class\nfrom moatless.workspace import Workspace\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass TransitionRule(BaseModel):\n    trigger: str = Field(\n        ...,\n        description=\"The trigger from the current state that causes the transition to fire.\",\n    )\n    source: type[AgenticState] = Field(\n        ..., description=\"The source state that the transition rule is defined for.\"\n    )\n    dest: type[AgenticState] = Field(\n        ...,\n        description=\"The destination state that the transition rule is defined for.\",\n    )\n    required_fields: Optional[set[str]] = Field(\n        default=None,\n        description=\"The fields that are required for the transition to fire.\",\n    )\n    excluded_fields: Optional[set[str]] = Field(\n        default=None, description=\"The fields that are excluded from the transition.\"\n    )\n\n    def get(self, key: str, default: Any = None) -> Any:\n        return getattr(self, key, default)\n\n    def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n        data[\"source\"] = self.source.__name__\n        data[\"dest\"] = self.dest.__name__\n\n        if data.get(\"required_fields\"):\n            data[\"required_fields\"] = list(data.get(\"required_fields\"))\n\n        if data.get(\"excluded_fields\"):\n            data[\"excluded_fields\"] = list(data.get(\"excluded_fields\"))\n\n        return data\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_state_classes(cls, data: Any) -> Any:\n        if isinstance(data, dict):\n            if isinstance(data.get(\"source\"), str):\n                data[\"source\"] = get_state_class(data[\"source\"])\n            if isinstance(data.get(\"dest\"), str):\n                data[\"dest\"] = get_state_class(data[\"dest\"])\n\n        if data[\"source\"] == data[\"dest\"]:\n            raise ValueError(\"Source and destination states cannot be the same.\")\n\n        return data",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transition_rules.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transition_rules.py::2",
        "metadata": {
          "file_path": "moatless\\transition_rules.py",
          "file_name": "transition_rules.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 285,
          "span_ids": [
            "TransitionRules",
            "TransitionRules.__init__",
            "TransitionRules.model_dump"
          ],
          "start_line": 65,
          "end_line": 101,
          "community": null
        },
        "content": "class TransitionRules(BaseModel):\n    initial_state: type[AgenticState] | None = Field(\n        default=None, \n        description=\"The initial state for the loop.\",\n        deprecated=\"Initial state should be set in transition_rules instead.\"\n    )\n    transition_rules: list[TransitionRule] = Field(\n        ..., description=\"The transition rules for the loop.\"\n    )\n    global_params: dict[str, Any] = Field(\n        default_factory=dict, description=\"Global parameters used by all transitions.\"\n    )\n    state_params: dict[type[AgenticState], dict[str, Any]] = Field(\n        default_factory=dict, description=\"State-specific parameters.\"\n    )\n\n    _source_trigger_index: dict[\n        tuple[type[AgenticState], str], list[TransitionRule]\n    ] = PrivateAttr(default_factory=dict)\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        self._build_source_trigger_index()\n\n    def model_dump(self, **kwargs):\n        data = {\n            \"global_params\": self.global_params,\n            \"state_params\": {k.__name__: v for k, v in self.state_params.items()},\n            \"transition_rules\": [\n                rule.model_dump(**kwargs) for rule in self.transition_rules\n            ],\n        }\n\n        if self.initial_state:\n            data[\"initial_state\"] = self.initial_state.__name__\n\n        return data",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transition_rules.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transition_rules.py::3",
        "metadata": {
          "file_path": "moatless\\transition_rules.py",
          "file_name": "transition_rules.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 180,
          "span_ids": [
            "TransitionRules.validate_before_init"
          ],
          "start_line": 103,
          "end_line": 123,
          "community": null
        },
        "content": "class TransitionRules(BaseModel):\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_before_init(cls, data: Any) -> Any:\n        if isinstance(data, dict):\n            if isinstance(data.get(\"initial_state\"), str):\n                data[\"initial_state\"] = get_state_class(data[\"initial_state\"])\n\n            if \"state_params\" in data:\n                data[\"state_params\"] = {\n                    get_state_class(k) if isinstance(k, str) else k: v\n                    for k, v in data[\"state_params\"].items()\n                }\n\n        if \"global_params\" not in data:\n            data[\"global_params\"] = {}\n\n        if \"model\" not in data[\"global_params\"]:\n            logger.info(f\"No model specified in global_params. Using default model: {Settings.default_model}\")\n            data[\"global_params\"][\"model\"] = Settings.default_model\n\n        return data",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transition_rules.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transition_rules.py::4",
        "metadata": {
          "file_path": "moatless\\transition_rules.py",
          "file_name": "transition_rules.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 154,
          "span_ids": [
            "TransitionRules._build_source_trigger_index",
            "TransitionRules.params",
            "TransitionRules.find_transition_rule_by_source_and_trigger"
          ],
          "start_line": 125,
          "end_line": 141,
          "community": null
        },
        "content": "class TransitionRules(BaseModel):\n\n    def _build_source_trigger_index(self):\n        for rule in self.transition_rules:\n            key = (rule.source, rule.trigger)\n            if key not in self._source_trigger_index:\n                self._source_trigger_index[key] = []\n            self._source_trigger_index[key].append(rule)\n\n    def find_transition_rule_by_source_and_trigger(\n        self, source: type[AgenticState], trigger: str\n    ) -> list[TransitionRule]:\n        return self._source_trigger_index.get((source, trigger), [])\n\n    def params(self, rule: TransitionRule) -> dict[str, Any]:\n        params = {}\n        params.update(self.global_params)\n        params.update(self.state_params.get(rule.dest, {}))\n        return params",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transition_rules.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transition_rules.py::5",
        "metadata": {
          "file_path": "moatless\\transition_rules.py",
          "file_name": "transition_rules.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 176,
          "span_ids": [
            "TransitionRules.get_next_rule"
          ],
          "start_line": 143,
          "end_line": 168,
          "community": null
        },
        "content": "class TransitionRules(BaseModel):\n\n    def get_next_rule(\n        self, source: AgenticState, trigger: str, data: dict[str, Any]\n    ) -> TransitionRule | None:\n\n        if trigger == \"init\" and self.initial_state:\n            logger.warning(\"Using deprecated 'initial_state'. Set initial state in transition_rules instead.\")\n            return TransitionRule(\n                trigger=\"init\",\n                source=source.__class__,\n                dest=self.initial_state,\n            )\n\n        transition_rules = self.find_transition_rule_by_source_and_trigger(\n            source.__class__, trigger\n        )\n        for transition_rule in transition_rules:\n            if (\n                transition_rule.required_fields\n                and not transition_rule.required_fields.issubset(data.keys())\n            ):\n                logger.info(f\"Missing required fields for transition {transition_rule}\")\n                continue\n\n            return transition_rule\n\n        return None",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transition_rules.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::1",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 326,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 41,
          "community": null
        },
        "content": "import logging\nfrom typing import Optional\n\nfrom moatless.edit.clarify import ClarifyCodeChange\nfrom moatless.edit.edit import EditCode\nfrom moatless.edit.plan import PlanToCode\nfrom moatless.edit.plan_lines import PlanToCodeWithLines\nfrom moatless.find.decide import DecideRelevance\nfrom moatless.find.identify import IdentifyCode\nfrom moatless.find.search import SearchCode\nfrom moatless.transition_rules import TransitionRule, TransitionRules\nfrom moatless.state import Finished, Rejected, Pending\n\nCODE_TRANSITIONS = [\n    TransitionRule(\n        source=PlanToCode,\n        dest=EditCode,\n        trigger=\"edit_code\",\n        required_fields=EditCode.required_fields(),\n    ),\n    TransitionRule(\n        source=PlanToCode,\n        dest=ClarifyCodeChange,\n        trigger=\"edit_code\",\n        required_fields=ClarifyCodeChange.required_fields(),\n    ),\n    TransitionRule(source=PlanToCode, dest=Finished, trigger=\"finish\"),\n    TransitionRule(source=PlanToCode, dest=Rejected, trigger=\"reject\"),\n    TransitionRule(\n        source=ClarifyCodeChange,\n        dest=EditCode,\n        trigger=\"edit_code\",\n        required_fields=EditCode.required_fields(),\n    ),\n    TransitionRule(source=ClarifyCodeChange, dest=PlanToCode, trigger=\"reject\"),\n    TransitionRule(source=EditCode, dest=PlanToCode, trigger=\"finish\"),\n    TransitionRule(source=EditCode, dest=PlanToCode, trigger=\"reject\"),\n]\n\n\nlogger = logging.getLogger(__name__)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::2",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 149,
          "span_ids": [
            "code_transitions"
          ],
          "start_line": 44,
          "end_line": 64,
          "community": null
        },
        "content": "def code_transitions(\n    global_params: Optional[dict] = None,\n    state_params: Optional[dict] = None,\n    max_prompt_file_tokens: Optional[int] = 16000,\n    max_tokens_in_edit_prompt: Optional[int] = 500,\n) -> TransitionRules:\n    state_params = state_params or {}\n    state_params.setdefault(\n        PlanToCode,\n        {\n            \"max_prompt_file_tokens\": max_prompt_file_tokens,\n            \"max_tokens_in_edit_prompt\": max_tokens_in_edit_prompt,\n        },\n    )\n\n    return TransitionRules(\n        global_params=global_params or {},\n        state_params=state_params,\n        initial_state=PlanToCode,\n        transition_rules=CODE_TRANSITIONS,\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::3",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 193,
          "span_ids": [
            "code_transitions_use_line_numbers"
          ],
          "start_line": 67,
          "end_line": 86,
          "community": null
        },
        "content": "def code_transitions_use_line_numbers(\n    global_params: Optional[dict] = None, state_params: Optional[dict] = None\n) -> TransitionRules:\n    return TransitionRules(\n        global_params=global_params or {},\n        state_params=state_params or {},\n        initial_state=PlanToCodeWithLines,\n        transition_rules=[\n            TransitionRule(\n                source=PlanToCodeWithLines,\n                dest=EditCode,\n                trigger=\"edit_code\",\n                required_fields=PlanToCodeWithLines.required_fields(),\n            ),\n            TransitionRule(source=PlanToCodeWithLines, dest=Finished, trigger=\"finish\"),\n            TransitionRule(source=PlanToCodeWithLines, dest=Rejected, trigger=\"reject\"),\n            TransitionRule(source=EditCode, dest=PlanToCodeWithLines, trigger=\"finish\"),\n            TransitionRule(source=EditCode, dest=PlanToCodeWithLines, trigger=\"reject\"),\n        ],\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::4",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 103,
          "span_ids": [
            "edit_code_transitions"
          ],
          "start_line": 89,
          "end_line": 100,
          "community": null
        },
        "content": "def edit_code_transitions(\n    global_params: Optional[dict] = None, state_params: Optional[dict] = None\n) -> TransitionRules:\n    return TransitionRules(\n        global_params=global_params or {},\n        state_params=state_params or {},\n        initial_state=EditCode,\n        transition_rules=[\n            TransitionRule(source=EditCode, dest=Finished, trigger=\"finish\"),\n            TransitionRule(source=EditCode, dest=Rejected, trigger=\"reject\"),\n        ],\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::5",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 342,
          "span_ids": [
            "search_transitions"
          ],
          "start_line": 103,
          "end_line": 145,
          "community": null
        },
        "content": "def search_transitions(\n    model: Optional[str] = None,\n    max_prompt_file_tokens: Optional[int] = None,\n    max_search_results: Optional[int] = None,\n    max_maybe_finish_iterations: int = 5,\n    global_params: Optional[dict] = None,\n    state_params: Optional[dict] = None,\n) -> TransitionRules:\n    global_params = global_params or {}\n\n    if model is not None:\n        global_params[\"model\"] = model\n\n    if state_params is None:\n        state_params = {}\n\n    if max_search_results is not None:\n        state_params.setdefault(SearchCode, {\"max_search_results\": max_search_results})\n\n    if max_prompt_file_tokens is not None:\n        state_params.setdefault(\n            IdentifyCode, {\"max_prompt_file_tokens\": max_prompt_file_tokens}\n        )\n\n    state_params.setdefault(\n        DecideRelevance, {\"max_iterations\": max_maybe_finish_iterations}\n    )\n\n    logger.info(state_params)\n\n    return TransitionRules(\n        global_params=global_params,\n        state_params=state_params,\n        initial_state=SearchCode,\n        transition_rules=[\n            TransitionRule(source=SearchCode, dest=IdentifyCode, trigger=\"did_search\"),\n            TransitionRule(source=SearchCode, dest=Finished, trigger=\"finish\"),\n            TransitionRule(source=IdentifyCode, dest=SearchCode, trigger=\"search\"),\n            TransitionRule(source=IdentifyCode, dest=DecideRelevance, trigger=\"finish\"),\n            TransitionRule(source=DecideRelevance, dest=SearchCode, trigger=\"search\"),\n            TransitionRule(source=DecideRelevance, dest=Finished, trigger=\"finish\"),\n        ],\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::6",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 237,
          "span_ids": [
            "identify_directly_transition"
          ],
          "start_line": 148,
          "end_line": 181,
          "community": null
        },
        "content": "def identify_directly_transition(\n    model: Optional[str] = None,\n    max_prompt_file_tokens: Optional[int] = 30000,\n    max_search_results: Optional[int] = 100,\n    global_params: Optional[dict] = None,\n    state_params: Optional[dict] = None,\n) -> TransitionRules:\n    global_params = global_params or {}\n\n    if model is not None:\n        global_params[\"model\"] = model\n\n    if state_params is None:\n        state_params = {}\n\n    if max_search_results is not None:\n        state_params.setdefault(SearchCode, {\"max_search_results\": max_search_results})\n\n    if max_prompt_file_tokens is not None:\n        state_params.setdefault(\n            IdentifyCode, {\"max_prompt_file_tokens\": max_prompt_file_tokens}\n        )\n\n    logger.info(state_params)\n\n    return TransitionRules(\n        global_params=global_params,\n        state_params=state_params,\n        initial_state=IdentifyCode,\n        transition_rules=[\n            TransitionRule(source=IdentifyCode, dest=Finished, trigger=\"search\"),\n            TransitionRule(source=IdentifyCode, dest=Finished, trigger=\"finish\"),\n        ],\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::6"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::7",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 268,
          "span_ids": [
            "search_and_code_transitions"
          ],
          "start_line": 184,
          "end_line": 212,
          "community": null
        },
        "content": "def search_and_code_transitions(\n    max_tokens_in_edit_prompt: Optional[int] = 500,\n    global_params: Optional[dict] = None,\n    state_params: Optional[dict] = None,\n) -> TransitionRules:\n    state_params = state_params or {}\n    if max_tokens_in_edit_prompt is not None:\n        state_params.setdefault(\n            PlanToCode, {\"max_tokens_in_edit_prompt\": max_tokens_in_edit_prompt}\n        )\n    return TransitionRules(\n        global_params=global_params,\n        state_params=state_params,\n        transition_rules=[\n            TransitionRule(source=Pending, dest=SearchCode, trigger=\"init\"),\n            TransitionRule(source=SearchCode, dest=IdentifyCode, trigger=\"did_search\"),\n            TransitionRule(source=SearchCode, dest=PlanToCode, trigger=\"finish\"),\n            TransitionRule(source=IdentifyCode, dest=SearchCode, trigger=\"search\"),\n            TransitionRule(source=IdentifyCode, dest=DecideRelevance, trigger=\"finish\"),\n            TransitionRule(source=DecideRelevance, dest=SearchCode, trigger=\"search\"),\n            TransitionRule(\n                source=DecideRelevance,\n                dest=PlanToCode,\n                trigger=\"finish\",\n                exclude_fields={\"message\"},\n            ),\n        ]\n        + CODE_TRANSITIONS,\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::7"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/transitions.py::8",
        "metadata": {
          "file_path": "moatless\\transitions.py",
          "file_name": "transitions.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 310,
          "span_ids": [
            "identify_and_code_transitions"
          ],
          "start_line": 215,
          "end_line": 258,
          "community": null
        },
        "content": "def identify_and_code_transitions(\n    model: Optional[str] = None,\n    max_prompt_file_tokens: Optional[int] = 16000,\n    max_tokens_in_edit_prompt: Optional[int] = 500,\n    max_search_results: Optional[int] = 100,\n    global_params: Optional[dict] = None,\n    state_params: Optional[dict] = None,\n) -> TransitionRules:\n    global_params = global_params or {}\n\n    if model is not None:\n        global_params[\"model\"] = model\n\n    if state_params is None:\n        state_params = {}\n\n    if max_search_results is not None:\n        state_params.setdefault(SearchCode, {\"max_search_results\": max_search_results})\n\n    if max_prompt_file_tokens is not None:\n        state_params.setdefault(\n            IdentifyCode, {\"max_prompt_file_tokens\": max_prompt_file_tokens}\n        )\n\n    if max_tokens_in_edit_prompt is not None:\n        state_params.setdefault(\n            PlanToCode,\n            {\n                \"max_prompt_file_tokens\": max_prompt_file_tokens,\n                \"max_tokens_in_edit_prompt\": max_tokens_in_edit_prompt,\n            },\n        )\n\n    return TransitionRules(\n        global_params=global_params,\n        state_params=state_params or {},\n        initial_state=IdentifyCode,\n        transition_rules=[\n            TransitionRule(source=IdentifyCode, dest=SearchCode, trigger=\"search\"),\n            TransitionRule(source=IdentifyCode, dest=PlanToCode, trigger=\"finish\"),\n        ]\n        + CODE_TRANSITIONS,\n    )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/transitions.py::8"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/types.py::1",
        "metadata": {
          "file_path": "moatless\\types.py",
          "file_name": "types.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 162,
          "span_ids": [
            "FileWithSpans.add_span_ids",
            "FileWithSpans.add_span_id",
            "imports",
            "ActionRequest",
            "ActionRequest.action_name",
            "FileWithSpans"
          ],
          "start_line": 1,
          "end_line": 28,
          "community": null
        },
        "content": "from typing import Any, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass FileWithSpans(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    span_ids: list[str] = Field(\n        default_factory=list,\n        description=\"The span ids of the relevant code in the file\",\n    )\n\n    def add_span_id(self, span_id):\n        if span_id not in self.span_ids:\n            self.span_ids.append(span_id)\n\n    def add_span_ids(self, span_ids: list[str]):\n        for span_id in span_ids:\n            self.add_span_id(span_id)\n\nclass ActionRequest(BaseModel):\n    pass\n\n    @property\n    def action_name(self):\n        return self.__class__.__name__",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/types.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/types.py::2",
        "metadata": {
          "file_path": "moatless\\types.py",
          "file_name": "types.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 188,
          "span_ids": [
            "ActionResponse.no_transition",
            "ActionResponse.retry",
            "ActionResponse.transition",
            "ActionResponse"
          ],
          "start_line": 30,
          "end_line": 56,
          "community": null
        },
        "content": "class ActionResponse(BaseModel):\n    trigger: Optional[str] = Field(\n        default=None,\n        description=\"Trigger to transition to the next state. If None, no transition is made.\",\n    )\n    output: Optional[dict[str, Any]] = Field(\n        default=None,\n        description=\"Output data to be passed to the next state.\",\n    )\n\n    retry_message: Optional[str] = Field(\n        default=None,\n        description=\"Message to use in retry.\"\n    )\n\n    @classmethod\n    def retry(cls, retry_message: str):\n        return cls(trigger=\"retry\", retry_message=retry_message)\n\n    @classmethod\n    def transition(cls, trigger: str, output: dict[str, Any] | None = None):\n        output = output or {}\n        return cls(trigger=trigger, output=output)\n\n    @classmethod\n    def no_transition(cls, output: dict[str, Any]):\n        return cls(output=output)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/types.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/types.py::3",
        "metadata": {
          "file_path": "moatless\\types.py",
          "file_name": "types.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 385,
          "span_ids": [
            "ActionTransaction",
            "Content",
            "Message",
            "Reject",
            "UserMessage",
            "Response",
            "ActionTransaction.model_dump",
            "AssistantMessage",
            "Usage",
            "VerificationError",
            "CodeChange",
            "Finish",
            "EmptyRequest"
          ],
          "start_line": 58,
          "end_line": 126,
          "community": null
        },
        "content": "class Usage(BaseModel):\n    completion_cost: float\n    completion_tokens: int\n    prompt_tokens: int\n\n\nclass ActionTransaction(BaseModel):\n    request: ActionRequest\n    response: Optional[ActionResponse] = None\n    usage: Optional[Usage] = None\n\n    def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n        data[\"request\"] = self.request.model_dump(**kwargs)\n        data[\"response\"] = self.response.model_dump(**kwargs) if self.response else None\n        return data\n\n\nclass EmptyRequest(ActionRequest):\n    pass\n\n\nclass Finish(ActionRequest):\n    thoughts: str = Field(..., description=\"The reason to finishing the request.\")\n\n\nclass Reject(ActionRequest):\n    thoughts: str = Field(..., description=\"The reason for rejecting the request.\")\n\n\nclass Content(ActionRequest):\n    content: str\n\n\nclass Message(BaseModel):\n    role: str\n    content: Optional[str] = None\n    action: Optional[ActionRequest] = Field(default=None)\n\n\nclass AssistantMessage(Message):\n    role: str = \"assistant\"\n    content: Optional[str] = None\n    action: Optional[ActionRequest] = Field(default=None)\n\n\nclass UserMessage(Message):\n    role: str = \"user\"\n    content: Optional[str] = None\n\n\nclass Response(BaseModel):\n    status: str\n    message: str\n    output: Optional[dict[str, Any]] = None\n\n\nclass VerificationError(BaseModel):\n    code: str\n    file_path: str\n    message: str\n    line: int\n\n\nclass CodeChange(BaseModel):\n    instructions: str = Field(..., description=\"Instructions to do the code change.\")\n    file_path: str = Field(..., description=\"The file path of the code to be updated.\")\n    span_id: str = Field(..., description=\"The span id of the code to be updated.\")",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/types.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/colors.py::1",
        "metadata": {
          "file_path": "moatless\\utils\\colors.py",
          "file_name": "colors.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 87,
          "span_ids": [
            "Colors"
          ],
          "start_line": 1,
          "end_line": 11,
          "community": null
        },
        "content": "class Colors:\n    RED = \"\\033[91m\"\n    GREEN = \"\\033[92m\"\n    YELLOW = \"\\033[93m\"\n    BLUE = \"\\033[94m\"\n    MAGENTA = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n    GRAY = \"\\033[90m\"\n    RESET = \"\\033[0m\"",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/colors.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/llm_utils.py::1",
        "metadata": {
          "file_path": "moatless\\utils\\llm_utils.py",
          "file_name": "llm_utils.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 96,
          "span_ids": [
            "imports",
            "instructor_mode_by_model"
          ],
          "start_line": 2,
          "end_line": 19,
          "community": null
        },
        "content": "import instructor\n\n\ndef instructor_mode_by_model(model: str) -> instructor.Mode | None:\n    if \"gpt\" in model:\n        return instructor.Mode.TOOLS\n\n    if \"claude\" in model:\n        return instructor.Mode.TOOLS\n\n    if model.startswith(\"claude\"):\n        return instructor.Mode.ANTHROPIC_TOOLS\n\n    if model.startswith(\"openrouter/anthropic/claude\"):\n        return instructor.Mode.TOOLS\n\n    return instructor.Mode.JSON",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/llm_utils.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/repo.py::1",
        "metadata": {
          "file_path": "moatless\\utils\\repo.py",
          "file_name": "repo.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 166,
          "span_ids": [
            "imports",
            "setup_github_repo",
            "get_repo_dir_name"
          ],
          "start_line": 1,
          "end_line": 24,
          "community": null
        },
        "content": "import logging\nimport os\nimport subprocess\n\nlogger = logging.getLogger(__name__)\n\n\ndef setup_github_repo(repo: str, base_commit: str, base_dir: str = \"/tmp/repos\") -> str:\n    repo_name = get_repo_dir_name(repo)\n    repo_url = f\"https://github.com/{repo}.git\"\n    path = f\"{base_dir}/{repo_name}\"\n    logger.info(\n        f\"Clone Github repo {repo_url} to {path} and checkout commit {base_commit}\"\n    )\n    if not os.path.exists(path):\n        os.makedirs(path)\n        logger.info(f\"Directory '{path}' was created.\")\n    maybe_clone(repo_url, path)\n    checkout_commit(path, base_commit)\n    return path\n\n\ndef get_repo_dir_name(repo: str):\n    return repo.replace(\"/\", \"_\")",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/repo.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/repo.py::2",
        "metadata": {
          "file_path": "moatless\\utils\\repo.py",
          "file_name": "repo.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 150,
          "span_ids": [
            "maybe_clone"
          ],
          "start_line": 27,
          "end_line": 42,
          "community": null
        },
        "content": "def maybe_clone(repo_url, repo_dir):\n    if not os.path.exists(f\"{repo_dir}/.git\"):\n        logger.info(f\"Cloning repo '{repo_url}'\")\n        # Clone the repo if the directory doesn't exist\n        result = subprocess.run(\n            [\"git\", \"clone\", repo_url, repo_dir],\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n\n        if result.returncode == 0:\n            logger.info(f\"Repo '{repo_url}' was cloned to '{repo_dir}'\")\n        else:\n            logger.info(f\"Failed to clone repo '{repo_url}' to '{repo_dir}'\")\n            raise ValueError(f\"Failed to clone repo '{repo_url}' to '{repo_dir}'\")",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/repo.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/repo.py::3",
        "metadata": {
          "file_path": "moatless\\utils\\repo.py",
          "file_name": "repo.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 182,
          "span_ids": [
            "clean_and_reset_state",
            "pull_latest",
            "create_branch"
          ],
          "start_line": 45,
          "end_line": 83,
          "community": null
        },
        "content": "def pull_latest(repo_dir):\n    subprocess.run(\n        [\"git\", \"pull\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n\n\ndef clean_and_reset_state(repo_dir):\n    subprocess.run(\n        [\"git\", \"clean\", \"-fd\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n    subprocess.run(\n        [\"git\", \"reset\", \"--hard\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n\n\ndef create_branch(repo_dir, branch_name):\n    try:\n        subprocess.run(\n            [\"git\", \"branch\", branch_name],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/repo.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/repo.py::4",
        "metadata": {
          "file_path": "moatless\\utils\\repo.py",
          "file_name": "repo.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 167,
          "span_ids": [
            "create_and_checkout_branch"
          ],
          "start_line": 86,
          "end_line": 114,
          "community": null
        },
        "content": "def create_and_checkout_branch(repo_dir, branch_name):\n    try:\n        branches = subprocess.run(\n            [\"git\", \"branch\"],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        ).stdout.split(\"\\n\")\n        branches = [branch.strip() for branch in branches]\n        if branch_name in branches:\n            subprocess.run(\n                [\"git\", \"checkout\", branch_name],\n                cwd=repo_dir,\n                check=True,\n                text=True,\n                capture_output=True,\n            )\n        else:\n            subprocess.run(\n                [\"git\", \"checkout\", \"-b\", branch_name],\n                cwd=repo_dir,\n                check=True,\n                text=True,\n                capture_output=True,\n            )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/repo.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/repo.py::5",
        "metadata": {
          "file_path": "moatless\\utils\\repo.py",
          "file_name": "repo.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 455,
          "span_ids": [
            "checkout_branch",
            "push_branch",
            "setup_repo",
            "stage_all_files",
            "checkout_commit",
            "commit_changes",
            "clean_and_reset_repo",
            "get_diff",
            "create_and_checkout_new_branch"
          ],
          "start_line": 117,
          "end_line": 200,
          "community": null
        },
        "content": "def commit_changes(repo_dir, commit_message):\n    subprocess.run(\n        [\"git\", \"commit\", \"-m\", commit_message, \"--no-verify\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n\n\ndef checkout_branch(repo_dir, branch_name):\n    subprocess.run(\n        [\"git\", \"checkout\", branch_name],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n\n\ndef push_branch(repo_dir, branch_name):\n    subprocess.run(\n        [\"git\", \"push\", \"origin\", branch_name, \"--no-verify\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n\n\ndef get_diff(repo_dir):\n    output = subprocess.run(\n        [\"git\", \"diff\"], cwd=repo_dir, check=True, text=True, capture_output=True\n    )\n\n    return output.stdout\n\n\ndef stage_all_files(repo_dir):\n    subprocess.run(\n        [\"git\", \"add\", \".\"], cwd=repo_dir, check=True, text=True, capture_output=True\n    )\n\n\ndef checkout_commit(repo_dir, commit_hash):\n    try:\n        subprocess.run(\n            [\"git\", \"reset\", \"--hard\", commit_hash],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e\n\n\ndef create_and_checkout_new_branch(repo_dir: str, branch_name: str):\n    try:\n        subprocess.run(\n            [\"git\", \"checkout\", \"-b\", branch_name],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e\n\n\ndef setup_repo(repo_url, repo_dir, branch_name=\"master\"):\n    maybe_clone(repo_url, repo_dir)\n    clean_and_reset_state(repo_dir)\n    checkout_branch(repo_dir, branch_name)\n    pull_latest(repo_dir)\n\n\ndef clean_and_reset_repo(repo_dir, branch_name=\"master\"):\n    clean_and_reset_state(repo_dir)\n    checkout_branch(repo_dir, branch_name)\n    pull_latest(repo_dir)",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/repo.py::5"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/tokenizer.py::1",
        "metadata": {
          "file_path": "moatless\\utils\\tokenizer.py",
          "file_name": "tokenizer.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 315,
          "span_ids": [
            "imports",
            "count_tokens"
          ],
          "start_line": 1,
          "end_line": 49,
          "community": null
        },
        "content": "import os\n\n_enc = None\n\n_voyageai = None\n\n\ndef count_tokens(content: str, model: str = \"gpt-3.5-turbo\") -> int:\n    global _enc, _voyageai\n\n    if model.startswith(\"voyage\"):\n        if _voyageai is None:\n            voyageai_import_err = (\n                \"`voyageai` package not found, please run `pip install voyageai`\"\n            )\n            try:\n                import voyageai\n            except ImportError as e:\n                raise ImportError(voyageai_import_err) from e\n\n            _voyageai = voyageai.Client()\n\n        return _voyageai.count_tokens([content])\n\n    if _enc is None:\n        tiktoken_import_err = (\n            \"`tiktoken` package not found, please run `pip install tiktoken`\"\n        )\n        try:\n            import tiktoken\n        except ImportError as e:\n            raise ImportError(tiktoken_import_err) from e\n\n        # set tokenizer cache temporarily\n        should_revert = False\n        if \"TIKTOKEN_CACHE_DIR\" not in os.environ:\n            should_revert = True\n            os.environ[\"TIKTOKEN_CACHE_DIR\"] = os.path.join(\n                os.path.dirname(os.path.abspath(__file__)),\n                \"_static/tiktoken_cache\",\n            )\n\n        _enc = tiktoken.encoding_for_model(model)\n\n        if should_revert:\n            del os.environ[\"TIKTOKEN_CACHE_DIR\"]\n\n    return len(_enc.encode(content, allowed_special=\"all\"))",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/tokenizer.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "utils/xml.py::1",
        "metadata": {
          "file_path": "moatless\\utils\\xml.py",
          "file_name": "xml.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 148,
          "span_ids": [
            "imports",
            "extract_between_tags",
            "contains_tag"
          ],
          "start_line": 1,
          "end_line": 17,
          "community": null
        },
        "content": "import re\n\n\ndef extract_between_tags(tag: str, string: str, strip: bool = False) -> list[str]:\n    ext_list = re.findall(f\"<{tag}>(.+?)</{tag}>\", string, re.DOTALL)\n    if strip:\n        ext_list = [e.strip() for e in ext_list]\n    return ext_list\n\n\ndef contains_tag(tag: str, string: str) -> bool:\n    return bool(re.search(f\"<{tag}>\", string, re.DOTALL))\n\n\n# def contains_tag(tag: str, string: str) -> bool:\n#    return bool(re.search(f\"<{tag}>(.+?)</{tag}>\", string, re.DOTALL))\r",
        "summary": null,
        "ctxt_list": [],
        "id": "utils/xml.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "verify/lint.py::1",
        "metadata": {
          "file_path": "moatless\\verify\\lint.py",
          "file_name": "lint.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 297,
          "span_ids": [
            "imports",
            "PylintVerifier.__init__",
            "PylintVerifier.verify",
            "PylintVerifier"
          ],
          "start_line": 1,
          "end_line": 48,
          "community": null
        },
        "content": "import logging\n\nfrom astroid import MANAGER\nfrom pylint.lint import Run\nfrom pylint.testutils import MinimalTestReporter\n\nfrom moatless.repository import CodeFile\nfrom moatless.types import VerificationError\nfrom moatless.verify.verify import Verifier\n\nlogger = logging.getLogger(__name__)\n\n\nclass PylintVerifier(Verifier):\n    def __init__(self, repo_dir: str, run_tests: bool = True):\n        self.repo_dir = repo_dir\n        self.run_tests = run_tests\n\n    def verify(self, file: CodeFile | None = None) -> list[VerificationError]:\n        if not file:\n            logger.warning(\"No file to verify\")\n            return []\n\n        try:\n            MANAGER.astroid_cache.clear()\n            results = Run(\n                [f\"{self.repo_dir}/{file.file_path}\"],\n                exit=False,\n                reporter=MinimalTestReporter(),\n            )\n\n            for msg in results.linter.reporter.messages:\n                logger.debug(f\"Message: {msg.msg_id} {msg.msg} {msg.line}\")\n\n            return [\n                VerificationError(\n                    code=msg.msg_id,\n                    file_path=msg.path.replace(f\"{self.repo_dir}/\", \"\"),\n                    message=msg.msg,\n                    line=msg.line,\n                )\n                for msg in results.linter.reporter.messages\n                if msg.msg_id[0] in [\"E\", \"F\"]\n            ]\n        except Exception:\n            logger.exception(\"Error running pylint\")\n            return []",
        "summary": null,
        "ctxt_list": [],
        "id": "verify/lint.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "verify/maven.py::1",
        "metadata": {
          "file_path": "moatless\\verify\\maven.py",
          "file_name": "maven.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 385,
          "span_ids": [
            "imports",
            "MavenVerifier.__init__",
            "MavenVerifier.verify",
            "MavenVerifier"
          ],
          "start_line": 1,
          "end_line": 58,
          "community": null
        },
        "content": "import logging\nimport os\nimport re\nimport subprocess\n\nfrom moatless.repository import CodeFile\nfrom moatless.types import VerificationError\nfrom moatless.verify.verify import Verifier\n\nlogger = logging.getLogger(__name__)\n\n\nclass MavenVerifier(Verifier):\n    def __init__(self, repo_dir: str, run_tests: bool = True):\n        self.repo_dir = repo_dir\n        self.run_tests = run_tests\n\n    def verify(self, file: CodeFile | None = None) -> list[VerificationError]:\n        try:\n            # os.environ[\"JAVA_HOME\"] = \"/home/albert/.sdkman/candidates/java/17.0.8-tem\"\n\n            version = \"21-tem\"\n\n            sdkman_cmd = (\n                f\"source $HOME/.sdkman/bin/sdkman-init.sh && sdk use java {version}\"\n            )\n\n            if self.run_tests:\n                mvn_cmd = \"./mvnw clean test\"\n            else:\n                mvn_cmd = \"./mvnw clean compile test-compile\"\n\n            logger.info(\n                f\"Running Maven command: {mvn_cmd} with Java version {version} in {self.repo_dir}\"\n            )\n            result = subprocess.run(\n                f\"{sdkman_cmd} && {mvn_cmd}\",\n                cwd=self.repo_dir,\n                check=False,\n                text=True,\n                shell=True,\n                capture_output=True,\n            )\n\n            stdout = result.stdout\n            stderr = result.stderr\n\n            combined_output = stdout + \"\\n\" + stderr\n            compilation_errors = self.parse_compilation_errors(combined_output)\n            if compilation_errors or not self.run_tests:\n                return compilation_errors\n\n            test_failures = self.parse_test_failures(combined_output)\n            return test_failures\n\n        except subprocess.CalledProcessError as e:\n            logger.warning(\"Error running Maven command:\")\n            logger.warning(e.stderr)",
        "summary": null,
        "ctxt_list": [],
        "id": "verify/maven.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "verify/maven.py::2",
        "metadata": {
          "file_path": "moatless\\verify\\maven.py",
          "file_name": "maven.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 138,
          "span_ids": [
            "MavenVerifier.parse_compilation_errors"
          ],
          "start_line": 60,
          "end_line": 76,
          "community": null
        },
        "content": "class MavenVerifier(Verifier):\n\n    def parse_compilation_errors(self, output: str) -> list[VerificationError]:\n        error_pattern = re.compile(r\"\\[ERROR\\] (.*?):\\[(\\d+),(\\d+)\\] (.*)\")\n        matches = error_pattern.findall(output)\n\n        errors = []\n        for match in matches:\n            file_path, line, column, message = match\n\n            file_path = file_path.replace(f\"{self.repo_dir}/\", \"\")\n            error = VerificationError(\n                code=\"COMPILATION_ERROR\",\n                file_path=file_path.strip(),\n                message=message.strip(),\n                line=int(line),\n            )\n            errors.append(error)\n        return errors",
        "summary": null,
        "ctxt_list": [],
        "id": "verify/maven.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "verify/maven.py::3",
        "metadata": {
          "file_path": "moatless\\verify\\maven.py",
          "file_name": "maven.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 206,
          "span_ids": [
            "MavenVerifier.parse_test_failures",
            "MavenVerifier.find_file"
          ],
          "start_line": 78,
          "end_line": 106,
          "community": null
        },
        "content": "class MavenVerifier(Verifier):\n\n    def find_file(self, class_name: str) -> str:\n        for root, _, files in os.walk(self.repo_dir):\n            for file in files:\n                if file == f\"{class_name}.java\":\n                    absolute_path = os.path.join(root, file)\n                    return os.path.relpath(absolute_path, self.repo_dir)\n        return \"\"\n\n    def parse_test_failures(self, output: str) -> list[VerificationError]:\n        failure_pattern = re.compile(r\"\\[ERROR\\]   (.*?):(\\d+) (.*)\")\n        matches = failure_pattern.findall(output)\n\n        errors = []\n        for match in matches:\n            test_case, line, message = match\n\n            class_name = test_case.split(\".\")[0]\n\n            file_path = self.find_file(class_name)\n\n            error = VerificationError(\n                code=\"TEST_FAILURE\",\n                file_path=file_path.strip(),\n                message=message.strip(),\n                line=int(line),\n            )\n            errors.append(error)\n        return errors",
        "summary": null,
        "ctxt_list": [],
        "id": "verify/maven.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "verify/verify.py::1",
        "metadata": {
          "file_path": "moatless\\verify\\verify.py",
          "file_name": "verify.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 58,
          "span_ids": [
            "imports",
            "Verifier",
            "Verifier.verify"
          ],
          "start_line": 1,
          "end_line": 11,
          "community": null
        },
        "content": "from abc import ABC, abstractmethod\n\nfrom moatless.repository import CodeFile\nfrom moatless.types import VerificationError\n\n\nclass Verifier(ABC):\n    @abstractmethod\n    def verify(self, file: CodeFile | None = None) -> list[VerificationError]:\n        pass",
        "summary": null,
        "ctxt_list": [],
        "id": "verify/verify.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/workspace.py::1",
        "metadata": {
          "file_path": "moatless\\workspace.py",
          "file_name": "workspace.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 118,
          "span_ids": [
            "imports"
          ],
          "start_line": 1,
          "end_line": 15,
          "community": null
        },
        "content": "import logging\nfrom typing import Any, Optional, Dict\n\nfrom moatless.codeblocks.parser.python import PythonParser\nfrom moatless.file_context import FileContext\nfrom moatless.index import IndexSettings\nfrom moatless.index.code_index import CodeIndex\nfrom moatless.repository import CodeFile, FileRepository, GitRepository\nfrom moatless.types import FileWithSpans, VerificationError\nfrom moatless.verify.lint import PylintVerifier\nfrom moatless.verify.maven import MavenVerifier\n\n_parser = PythonParser()\n\nlogger = logging.getLogger(__name__)",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/workspace.py::1"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/workspace.py::2",
        "metadata": {
          "file_path": "moatless\\workspace.py",
          "file_name": "workspace.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 321,
          "span_ids": [
            "Workspace.__init__",
            "Workspace"
          ],
          "start_line": 18,
          "end_line": 64,
          "community": null
        },
        "content": "class Workspace:\n    def __init__(\n        self,\n        file_repo: FileRepository,\n        index_dir: Optional[str] = None,\n        index_settings: IndexSettings | None = None,\n        max_results: int = 25,\n        code_index: CodeIndex | None = None,\n        verification_job: Optional[str] = \"pylint\",\n        max_file_context_tokens: int = 4000,\n        file_context: FileContext | None = None,\n    ):\n        self.file_repo = file_repo\n\n        if code_index:\n            self.code_index = code_index\n        elif index_dir:\n            try:\n                self.code_index = CodeIndex.from_persist_dir(\n                    index_dir, file_repo=file_repo, max_results=max_results\n                )\n            except FileNotFoundError:\n                logger.info(\"No index found. Creating a new index.\")\n                code_index = CodeIndex(\n                    file_repo=file_repo,\n                    settings=index_settings,\n                    max_results=max_results,\n                )\n                code_index.run_ingestion()\n                code_index.persist(index_dir)\n                self.code_index = code_index\n        else:\n            self.code_index = None\n\n        if verification_job == \"maven\":\n            self.verifier = MavenVerifier(self.file_repo.path)\n        elif verification_job == \"pylint\":\n            self.verifier = PylintVerifier(self.file_repo.path)\n        else:\n            self.verifier = None\n\n        if file_context:\n            self._file_context = file_context\n        else:\n            self._file_context = self.create_file_context(\n                max_tokens=max_file_context_tokens\n            )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/workspace.py::2"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/workspace.py::3",
        "metadata": {
          "file_path": "moatless\\workspace.py",
          "file_name": "workspace.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 157,
          "span_ids": [
            "Workspace.from_dirs"
          ],
          "start_line": 66,
          "end_line": 88,
          "community": null
        },
        "content": "class Workspace:\n\n    @classmethod\n    def from_dirs(\n        cls,\n        git_repo_url: Optional[str] = None,\n        commit: Optional[str] = None,\n        repo_path: Optional[str] = None,\n        max_file_context_tokens: int = 4000,\n        **kwargs,\n    ):\n        if git_repo_url:\n            file_repo = GitRepository.from_repo(\n                git_repo_url=git_repo_url, repo_path=repo_path, commit=commit\n            )\n        elif repo_path:\n            file_repo = FileRepository(repo_path)\n        else:\n            raise ValueError(\"Either git_repo_url or repo_dir must be provided.\")\n\n        return cls(\n            file_repo=file_repo,\n            max_file_context_tokens=max_file_context_tokens,\n            **kwargs,\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/workspace.py::3"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/workspace.py::4",
        "metadata": {
          "file_path": "moatless\\workspace.py",
          "file_name": "workspace.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 264,
          "span_ids": [
            "Workspace.from_dict"
          ],
          "start_line": 90,
          "end_line": 123,
          "community": null
        },
        "content": "class Workspace:\n\n    @classmethod\n    def from_dict(cls, data: dict, **kwargs):\n        if \"repository\" not in data:\n            raise ValueError(\"Missing repository key\")\n\n        if data[\"repository\"].get(\"git_repo_url\"):\n            file_repo = GitRepository.from_repo(\n                git_repo_url=data[\"repository\"].get(\"git_repo_url\"),\n                repo_path=data[\"repository\"].get(\"repo_path\"),\n                commit=data[\"repository\"].get(\"commit\"),\n            )\n        elif data[\"repository\"].get(\"repo_path\"):\n            file_repo = FileRepository(data[\"repository\"].get(\"repo_path\"))\n        else:\n            raise ValueError(\"Either git_repo_url or repo_dir must be provided.\")\n\n        file_context = FileContext(\n            repo=file_repo, max_tokens=data[\"file_context\"].get(\"max_tokens\")\n        )\n        file_context.load_files_from_dict(data[\"file_context\"].get(\"files\", []))\n\n        if data.get(\"code_index\", {}).get(\"index_name\"):\n            code_index = CodeIndex.from_index_name(\n                data[\"code_index\"].get(\"index_name\"), file_repo=file_repo\n            )\n        else:\n            code_index = None\n\n        return cls(\n            file_repo=file_repo,\n            file_context=file_context,\n            code_index=code_index,\n            **kwargs,\n        )",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/workspace.py::4"
      },
      {
        "kind": "ChunkNode",
        "og_id": "moatless/workspace.py::5",
        "metadata": {
          "file_path": "moatless\\workspace.py",
          "file_name": "workspace.py",
          "file_type": "text/x-python",
          "category": "implementation",
          "tokens": 329,
          "span_ids": [
            "Workspace.restore_from_snapshot",
            "Workspace.save",
            "Workspace.verify",
            "Workspace.create_file_context",
            "Workspace.file_context",
            "Workspace.dict",
            "Workspace.snapshot",
            "Workspace.get_file"
          ],
          "start_line": 125,
          "end_line": 171,
          "community": null
        },
        "content": "class Workspace:\n\n    def restore_from_snapshot(self, snapshot: dict):\n        self.file_repo.restore_from_snapshot(snapshot[\"repository\"])\n        self._file_context.restore_from_snapshot(snapshot[\"file_context\"])\n\n    def dict(self):\n        return {\n            \"repository\": self.file_repo.dict(),\n            \"file_context\": self.file_context.model_dump(\n                exclude_none=True, exclude_unset=True\n            ),\n            \"code_index\": self.code_index.dict() if self.code_index else None,\n        }\n\n    def snapshot(self) -> Dict[str, Any]:\n        return {\n            \"repository\": self.file_repo.snapshot(),\n            \"file_context\": self.file_context.snapshot(),\n        }\n\n    def create_file_context(\n        self,\n        files_with_spans: list[FileWithSpans] | None = None,\n        max_tokens: int = 4000,\n    ):\n        file_context = FileContext(self.file_repo, max_tokens=max_tokens)\n        if files_with_spans:\n            file_context.add_files_with_spans(files_with_spans)\n        return file_context\n\n    @property\n    def file_context(self):\n        return self._file_context\n\n    def get_file(self, file_path, refresh: bool = False, from_origin: bool = False):\n        return self.file_repo.get_file(\n            file_path, refresh=refresh, from_origin=from_origin\n        )\n\n    def save(self):\n        self.file_repo.save()\n\n    def verify(self, file: CodeFile | None = None) -> list[VerificationError]:\n        if self.verifier:\n            return self.verifier.verify(file)\n\n        logger.info(\"No verifier configured.\")\n        return []",
        "summary": null,
        "ctxt_list": [],
        "id": "moatless/workspace.py::5"
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Evaluation and Transition Management for Code Search and Identification",
        "summary": "This code provides a framework for evaluating different code search and identification tasks by utilizing transition rules, which dictate the progression of states during evaluation. It defines multiple evaluation functions that set up and execute these tasks, leveraging a shared Evaluation class to manage the evaluation process and generate detailed reports.",
        "key_variables": "Evaluation, evaluate_search_and_identify, search_and_code_transitions, TransitionRules",
        "id": 10
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Evaluation and Analysis of Code Predictions",
        "summary": "This code feature manages the evaluation and analysis of code prediction experiments, generating detailed reports and managing repository contexts for different code versions. It includes functions to generate structured markdown reports, manage file contexts, handle Git repository operations, and evaluate prediction accuracy against expected outcomes.",
        "key_variables": "generate_report, generate_md_report, FileContext, GitRepository",
        "id": 5
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Evaluation and Workflow Management",
        "summary": "This collection of code focuses on evaluating coding instances by setting up a workspace, managing transitions through an agentic loop, and generating markdown reports based on the evaluation results. It handles previous actions, manages state transitions, and provides a detailed report on the evaluation, including costs and changes made.",
        "key_variables": "Evaluation, AgenticLoop, Trajectory, generate_md_report",
        "id": 9
      },
      {
        "kind": "ClusterNode",
        "title": "Code Transition Analysis and Evaluation",
        "summary": "This code processes transitions in code search and identification workflows, evaluating different stages like search, identification, planning, and editing. It captures various metrics and status results for each transition, comparing them against expected and alternative spans to determine success and effectiveness.",
        "key_variables": "to_result,found_in_alternative_spans,sync_file_context_with_search_trajectory,get_missing_files",
        "id": 17
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Trajectory Verification and Context Expansion",
        "summary": "This code verifies the trajectory of code search processes by evaluating transitions, identifying files and spans, and expanding contexts for improved search results. It performs various checks and expands file contexts to ensure accurate and efficient identification of expected and alternative code spans.",
        "key_variables": "verify_search_trajectory, file_spans_to_dict, get_files_from_patch, Workspace",
        "id": 14
      },
      {
        "kind": "ClusterNode",
        "title": "Repository Setup and Management for Benchmarking",
        "summary": "These functions handle the setup and management of GitHub repositories for benchmarking purposes. They ensure the repository is cloned to a specified directory and the correct commit is checked out, either using provided instance data or an instance ID.",
        "key_variables": "setup_swebench_repo, setup_github_repo, get_repo_dir_name, maybe_clone",
        "id": 21
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Codebase Initialization and Indexing Framework",
        "summary": "This codebase provides a comprehensive framework for initializing and managing workspaces, repositories, and code indexing for software engineering benchmarks (SWE-bench). It includes functionality to clone repositories, create code indices, split code into manageable chunks, and manage context for code analysis, utilizing embedding models to enhance code search and verification.",
        "key_variables": "create_workspace, CodeIndex, Workspace, EpicSplitter",
        "id": 11
      },
      {
        "kind": "ClusterNode",
        "title": "Comprehensive Code Analysis and Verification Framework",
        "summary": "This collection of code provides a framework for parsing, analyzing, and verifying code modules and files. It includes functionality for identifying relevant code spans, parsing code content into modules, verifying code using tools like Maven, and managing workspace contexts.",
        "key_variables": "Module, CodeParser, ClarifyCodeChange, MavenVerifier",
        "id": 12
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Change Request and Management System",
        "summary": "This feature encompasses a system for handling code change requests, including identifying relevant code spans, applying changes, and managing responses. It leverages structured action requests and responses to ensure accurate code modifications and maintain a coherent workflow.",
        "key_variables": "ApplyChange, ActionRequest, FileWithSpans, CodeChange",
        "id": 8
      },
      {
        "kind": "ClusterNode",
        "title": "Modular Code Parsing and Verification Framework",
        "summary": "This code provides a framework for parsing and verifying code files written in Python and Java, utilizing parsers for each language to analyze code structure and content. It includes capabilities for code verification through Maven and supports managing code contexts and repositories.",
        "key_variables": "CodeParser, PythonParser, JavaParser, MavenVerifier",
        "id": 7
      },
      {
        "kind": "ClusterNode",
        "title": "Code Parsing and Management System for Structured Analysis",
        "summary": "This code defines a system for parsing, analyzing, and managing code blocks and their contexts. It includes functionality for categorizing code into blocks, managing visibility of code segments, and validating code structure, as well as tools for handling code transitions and modifications.",
        "key_variables": "CodeBlock, CodeParser, BlockSpan, TransitionRules",
        "id": 2
      },
      {
        "kind": "ClusterNode",
        "title": "Comprehensive Code Relationship Management System",
        "summary": "This code implements a system for managing and analyzing relationships between code blocks, utilizing various scopes and types to categorize and validate references in code. It provides functionality for creating references, handling imports, and defining relationships within the code structure.",
        "key_variables": "ReferenceScope, RelationshipType, Relationship, CodeParser",
        "id": 6
      },
      {
        "kind": "ClusterNode",
        "title": "Hierarchical Code Block Visualization and Annotation",
        "summary": "This feature provides a method to represent code blocks in a tree structure, allowing for the visualization and annotation of code with various customizable display options such as highlighting, token display, and reference inclusion. It supports hierarchical traversal and formatting of code elements for enhanced readability and analysis.",
        "key_variables": "CodeBlock, to_tree, Colors, CodeBlockType",
        "id": 16
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Change Verification and Messaging System",
        "summary": "This code feature handles the verification of line numbers for code changes and messaging for clarifications, ensuring that edits are within specified limits and providing system prompts and messages for user instructions. It also includes token counting functionality to manage the size of edits in relation to model constraints.",
        "key_variables": "ClarifyCodeChange, _verify_line_numbers, count_tokens, Message",
        "id": 19
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Block Processing and Transition System",
        "summary": "This code manages the identification, review, editing, and planning of changes to code blocks within a file. It handles transitions between different states based on specified actions and verifies code updates for consistency and correctness.",
        "key_variables": "EditCode, PlanToCode, ReviewCode, ActionResponse",
        "id": 3
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Evaluation and Transition Management System",
        "summary": "This code feature handles the identification, review, editing, and planning of changes to code blocks within a file. It manages transitions between different states based on specified actions and verifies code updates for consistency and correctness.",
        "key_variables": "EditCode, PlanToCode, AgenticState, Usage",
        "id": 4
      },
      {
        "kind": "ClusterNode",
        "title": "Contextual Code Search and Ranking System",
        "summary": "The code defines a system that performs contextual code searches within a repository and ranks the resulting code spans based on predefined criteria. It utilizes classes for managing code spans, executing search actions, and transitioning between different workflow states based on search results.",
        "key_variables": "RankedFileSpan, ContextSpan, CurrentPromptSpan, SearchCode",
        "id": 22
      },
      {
        "kind": "ClusterNode",
        "title": "Contextual Code Content Update and Span Management System",
        "summary": "This feature provides functionality to update file content by specific line numbers within a context file, while also managing and logging new code spans introduced during the update process.",
        "key_variables": "ContextFile, UpdateResult, logger, add_spans",
        "id": 26
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Search and Contextual Transition Management",
        "summary": "This code handles the management of retries and transitions during a code search process, including determining the appropriate system prompts based on the model type. It defines the behavior for retrying actions and managing context changes based on the model and file context.",
        "key_variables": "SearchCode, ActionResponse, instructor_mode_by_model, SEARCH_SYSTEM_PROMPT",
        "id": 23
      },
      {
        "kind": "ClusterNode",
        "title": "Code Embedding and Indexing Framework",
        "summary": "This feature provides a framework for creating and managing code embeddings using a Faiss-based vector store, enabling efficient code indexing and retrieval. It includes classes and methods for setting up vector stores, handling persistent storage, and managing document and vector information.",
        "key_variables": "CodeIndex, SimpleFaissVectorStore, IndexSettings, FileRepository",
        "id": 20
      },
      {
        "kind": "ClusterNode",
        "title": "Code Search and Retrieval System",
        "summary": "This feature provides a comprehensive system for searching, indexing, and retrieving code snippets based on various parameters such as class names, function names, and file patterns. It supports both semantic and name-based search approaches, handling exact matches and filtering results to present the most relevant code snippets.",
        "key_variables": "CodeIndex, semantic_search, find_by_name, SearchCodeResponse",
        "id": 13
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Vector Search and Filtering System",
        "summary": "This feature provides a vector-based search capability for code repositories, allowing for precise retrieval of code snippets based on queries, file patterns, categories, and content matches. It filters and ranks code snippets from a document store, supporting complex criteria like exact matches and metadata filtering to refine search results.",
        "key_variables": "CodeIndex, _vector_search, CodeSnippet, SpanHit",
        "id": 24
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Chunking and Embedding Framework",
        "summary": "This code defines a framework for breaking down code into manageable chunks and embedding them using a specified model for efficient indexing and retrieval. It includes components for handling code and non-code files, managing chunk sizes, and embedding strategies.",
        "key_variables": "CodeIndex, EpicSplitter, CommentStrategy, IndexSettings",
        "id": 15
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Node Creation and Tokenization Framework",
        "summary": "This feature provides a framework for creating code nodes with metadata and tokenization, allowing for efficient parsing and management of code blocks and their metadata. It includes functionality for generating unique hashes, managing node creation with metadata, and token counting for code content.",
        "key_variables": "CodeNode, EpicSplitter, _create_node, _count_tokens",
        "id": 25
      },
      {
        "kind": "ClusterNode",
        "title": "Dynamic State Resolution and Transition Validation Framework",
        "summary": "This code feature dynamically resolves and validates state transitions using predefined or dynamically imported state classes, ensuring the appropriate state management for code changes. It includes mechanisms to verify and initialize transition rules based on state properties and configurations.",
        "key_variables": "get_state_class, TransitionRules, validate_before_init, AgenticState",
        "id": 18
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Evaluation and Transition Strategy System",
        "summary": "This code feature facilitates automated evaluation of code search and transition strategies by orchestrating a series of state transitions and evaluations. It manages the transitions between different code states, evaluates their relevance, and executes detailed evaluations using predefined global parameters and state configurations.",
        "key_variables": "TransitionRules, Evaluation, SearchCode, PlanToCode",
        "id": 5693
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code State Management and Transition System",
        "summary": "This code defines a framework for managing and transitioning between various states during automated code evaluation and modification processes. It includes classes for handling code changes, planning, reviewing, and executing state transitions within a loop, ensuring efficient code management and modifications.",
        "key_variables": "ClarifyCodeChange, EditCode, AgenticLoop, PlanToCode",
        "id": 97236
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Context Expansion and Decision Making System",
        "summary": "This feature manages the decision-making process for determining the relevance of code context, identifying and searching relevant code spans, and transitioning between different states based on relevance criteria. It ensures efficient code analysis by controlling the flow of actions and expanding context when necessary.",
        "key_variables": "DecideRelevance, IdentifyCode, SearchCode, ActionResponse",
        "id": 77036
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Loop Execution and State Transition System",
        "summary": "The 'AgenticLoop' class manages the execution of a loop with state transitions, ensuring the loop runs until completion or a terminal state is reached. It handles state execution, evaluates transitions, and maintains loop integrity by managing costs, retries, and transitions.",
        "key_variables": "AgenticLoop, _execute_state_until_transition, _create_state, transition_to",
        "id": 57098
      },
      {
        "kind": "ClusterNode",
        "title": "State-Based Code Evaluation and Transition Framework",
        "summary": "This code defines a framework for managing state transitions and evaluating code within an agentic loop. It includes classes for handling different code states, executing actions, and managing transitions based on predefined rules, while maintaining evaluation integrity and generating reports.",
        "key_variables": "AgenticState, TransitionRule, Trajectory, TransitionRules",
        "id": 31509
      },
      {
        "kind": "ClusterNode",
        "title": "Automated Code Block Transition and Parsing Management",
        "summary": "The code provides a comprehensive framework for managing state transitions and parsing operations on code blocks. It allows the identification, modification, and evaluation of code through defined transition rules and parsing techniques to ensure proper code flow and analysis.",
        "key_variables": "TransitionRule, CodeBlock, CodeParser, NodeMatch",
        "id": 11371
      }
    ],
    "links": [
      {
        "src": "benchmark/claude_evaluation.py::1",
        "dst": "moatless/transitions.py::7",
        "kind": "CallTo",
        "ref": "search_and_code_transitions",
        "source": "benchmark/claude_evaluation.py::1",
        "target": "moatless/transitions.py::7"
      },
      {
        "src": "benchmark/claude_evaluation.py::1",
        "dst": "moatless/transitions.py::7",
        "kind": "ImportFrom",
        "ref": "search_and_code_transitions",
        "source": "benchmark/claude_evaluation.py::1",
        "target": "moatless/transitions.py::7"
      },
      {
        "src": "benchmark/claude_evaluation.py::1",
        "dst": 5693,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::1",
        "target": 5693
      },
      {
        "src": "benchmark/claude_evaluation.py::1",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::1",
        "target": 10
      },
      {
        "src": "benchmark/claude_evaluation.py::3",
        "dst": "moatless/transitions.py::7",
        "kind": "ImportFrom",
        "ref": "search_and_code_transitions",
        "source": "benchmark/claude_evaluation.py::3",
        "target": "moatless/transitions.py::7"
      },
      {
        "src": "benchmark/claude_evaluation.py::3",
        "dst": 5693,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::3",
        "target": 5693
      },
      {
        "src": "benchmark/claude_evaluation.py::3",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::3",
        "target": 10
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "benchmark/evaluation.py::9",
        "kind": "ImportFrom",
        "ref": "create_evaluation_name",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "benchmark/evaluation.py::9"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "benchmark/evaluation.py::2",
        "kind": "CallTo",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": "benchmark/evaluation.py::2",
        "kind": "ImportFrom",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::4",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": 5693,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::4",
        "target": 5693
      },
      {
        "src": "benchmark/claude_evaluation.py::4",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::4",
        "target": 10
      },
      {
        "src": "benchmark/claude_evaluation.py::5",
        "dst": "moatless/transitions.py::5",
        "kind": "CallTo",
        "ref": "search_transitions",
        "source": "benchmark/claude_evaluation.py::5",
        "target": "moatless/transitions.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::5",
        "dst": "moatless/transitions.py::5",
        "kind": "ImportFrom",
        "ref": "search_transitions",
        "source": "benchmark/claude_evaluation.py::5",
        "target": "moatless/transitions.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::5",
        "dst": "benchmark/evaluation.py::9",
        "kind": "ImportFrom",
        "ref": "create_evaluation_name",
        "source": "benchmark/claude_evaluation.py::5",
        "target": "benchmark/evaluation.py::9"
      },
      {
        "src": "benchmark/claude_evaluation.py::5",
        "dst": "benchmark/evaluation.py::2",
        "kind": "CallTo",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::5",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::5",
        "dst": "benchmark/evaluation.py::2",
        "kind": "ImportFrom",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::5",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::5",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::5",
        "target": 10
      },
      {
        "src": "benchmark/claude_evaluation.py::6",
        "dst": "benchmark/evaluation.py::9",
        "kind": "ImportFrom",
        "ref": "create_evaluation_name",
        "source": "benchmark/claude_evaluation.py::6",
        "target": "benchmark/evaluation.py::9"
      },
      {
        "src": "benchmark/claude_evaluation.py::6",
        "dst": "benchmark/evaluation.py::2",
        "kind": "CallTo",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::6",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::6",
        "dst": "benchmark/evaluation.py::2",
        "kind": "ImportFrom",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::6",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::6",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::6",
        "target": 10
      },
      {
        "src": "benchmark/claude_evaluation.py::7",
        "dst": "benchmark/evaluation.py::9",
        "kind": "ImportFrom",
        "ref": "create_evaluation_name",
        "source": "benchmark/claude_evaluation.py::7",
        "target": "benchmark/evaluation.py::9"
      },
      {
        "src": "benchmark/claude_evaluation.py::7",
        "dst": "benchmark/evaluation.py::2",
        "kind": "CallTo",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::7",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::7",
        "dst": "benchmark/evaluation.py::2",
        "kind": "ImportFrom",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::7",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::7",
        "dst": "moatless/transitions.py::2",
        "kind": "CallTo",
        "ref": "code_transitions",
        "source": "benchmark/claude_evaluation.py::7",
        "target": "moatless/transitions.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::7",
        "dst": "moatless/transitions.py::2",
        "kind": "ImportFrom",
        "ref": "code_transitions",
        "source": "benchmark/claude_evaluation.py::7",
        "target": "moatless/transitions.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::7",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::7",
        "target": 10
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/decide.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/decide.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/decide.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/decide.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/decide.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "find/decide.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Rejected",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "moatless/state.py::5"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "benchmark/evaluation.py::9",
        "kind": "ImportFrom",
        "ref": "create_evaluation_name",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "benchmark/evaluation.py::9"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "benchmark/evaluation.py::2",
        "kind": "CallTo",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": "benchmark/evaluation.py::2",
        "kind": "ImportFrom",
        "ref": "Evaluation",
        "source": "benchmark/claude_evaluation.py::8",
        "target": "benchmark/evaluation.py::2"
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": 5693,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::8",
        "target": 5693
      },
      {
        "src": "benchmark/claude_evaluation.py::8",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/claude_evaluation.py::8",
        "target": 10
      },
      {
        "src": "benchmark/create_dataset.py::2",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "benchmark/create_dataset.py::2",
        "target": "repository/file.py::5"
      },
      {
        "src": "benchmark/create_dataset.py::2",
        "dst": "benchmark/utils.py::4",
        "kind": "ImportFrom",
        "ref": "get_file_spans_from_patch",
        "source": "benchmark/create_dataset.py::2",
        "target": "benchmark/utils.py::4"
      },
      {
        "src": "benchmark/create_dataset.py::2",
        "dst": "benchmark/utils.py::4",
        "kind": "ImportFrom",
        "ref": "get_file_spans_from_patch",
        "source": "benchmark/create_dataset.py::2",
        "target": "benchmark/utils.py::4"
      },
      {
        "src": "benchmark/create_dataset.py::2",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "benchmark/create_dataset.py::2",
        "target": 5
      },
      {
        "src": "benchmark/evaluation.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "benchmark/evaluation.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "benchmark/evaluation.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "benchmark/evaluation.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "benchmark/evaluation.py::2",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/evaluation.py::2",
        "target": 10
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "moatless/trajectory.py::2",
        "kind": "CallTo",
        "ref": "Trajectory",
        "source": "benchmark/evaluation.py::5",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "benchmark/evaluation.py::5",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "moatless/trajectory.py::2",
        "kind": "CallTo",
        "ref": "Trajectory",
        "source": "benchmark/evaluation.py::5",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "benchmark/evaluation.py::5",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "moatless/workspace.py::2",
        "kind": "ImportFrom",
        "ref": "Workspace",
        "source": "benchmark/evaluation.py::5",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "benchmark/utils.py::8",
        "kind": "ImportFrom",
        "ref": "trace_metadata",
        "source": "benchmark/evaluation.py::5",
        "target": "benchmark/utils.py::8"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "moatless/loop.py::2",
        "kind": "CallTo",
        "ref": "AgenticLoop",
        "source": "benchmark/evaluation.py::5",
        "target": "moatless/loop.py::2"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "moatless/loop.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticLoop",
        "source": "benchmark/evaluation.py::5",
        "target": "moatless/loop.py::2"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "repository/git.py::1",
        "kind": "CallTo",
        "ref": "GitRepository",
        "source": "benchmark/evaluation.py::5",
        "target": "repository/git.py::1"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": "repository/git.py::1",
        "kind": "ImportFrom",
        "ref": "GitRepository",
        "source": "benchmark/evaluation.py::5",
        "target": "repository/git.py::1"
      },
      {
        "src": "benchmark/evaluation.py::5",
        "dst": 9,
        "kind": "ChunkToCluster",
        "source": "benchmark/evaluation.py::5",
        "target": 9
      },
      {
        "src": "benchmark/evaluation.py::6",
        "dst": "benchmark/report_v2.py::1",
        "kind": "CallTo",
        "ref": "to_result",
        "source": "benchmark/evaluation.py::6",
        "target": "benchmark/report_v2.py::1"
      },
      {
        "src": "benchmark/evaluation.py::6",
        "dst": "benchmark/report_v2.py::1",
        "kind": "ImportFrom",
        "ref": "to_result",
        "source": "benchmark/evaluation.py::6",
        "target": "benchmark/report_v2.py::1"
      },
      {
        "src": "benchmark/evaluation.py::6",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/evaluation.py::6",
        "target": 10
      },
      {
        "src": "benchmark/evaluation.py::7",
        "dst": "benchmark/report_v2.py::1",
        "kind": "ImportFrom",
        "ref": "to_result",
        "source": "benchmark/evaluation.py::7",
        "target": "benchmark/report_v2.py::1"
      },
      {
        "src": "benchmark/evaluation.py::7",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/evaluation.py::7",
        "target": 10
      },
      {
        "src": "benchmark/evaluation.py::9",
        "dst": "benchmark/report_v2.py::1",
        "kind": "CallTo",
        "ref": "to_result",
        "source": "benchmark/evaluation.py::9",
        "target": "benchmark/report_v2.py::1"
      },
      {
        "src": "benchmark/evaluation.py::9",
        "dst": "benchmark/report_v2.py::1",
        "kind": "ImportFrom",
        "ref": "to_result",
        "source": "benchmark/evaluation.py::9",
        "target": "benchmark/report_v2.py::1"
      },
      {
        "src": "benchmark/evaluation.py::9",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/evaluation.py::9",
        "target": 10
      },
      {
        "src": "benchmark/report_v1.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "ImportFrom",
        "ref": "get_missing_files",
        "source": "benchmark/report_v1.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "benchmark/report_v1.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "ImportFrom",
        "ref": "get_missing_files",
        "source": "benchmark/report_v1.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "benchmark/report_v1.py::2",
        "dst": 17,
        "kind": "ChunkToCluster",
        "source": "benchmark/report_v1.py::2",
        "target": 17
      },
      {
        "src": "benchmark/report_v1.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "CallTo",
        "ref": "FileContext",
        "source": "benchmark/report_v1.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "benchmark/report_v1.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "ImportFrom",
        "ref": "FileContext",
        "source": "benchmark/report_v1.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "benchmark/report_v1.py::4",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "benchmark/report_v1.py::4",
        "target": 5
      },
      {
        "src": "benchmark/report_v2.py::1",
        "dst": "moatless/trajectory.py::2",
        "kind": "CallTo",
        "ref": "Trajectory",
        "source": "benchmark/report_v2.py::1",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/report_v2.py::1",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "benchmark/report_v2.py::1",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/report_v2.py::1",
        "dst": 10,
        "kind": "ChunkToCluster",
        "source": "benchmark/report_v2.py::1",
        "target": 10
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "moatless/trajectory.py::2",
        "kind": "CallTo",
        "ref": "Trajectory",
        "source": "benchmark/report_v2.py::2",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "benchmark/report_v2.py::2",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "benchmark/report_v2.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "benchmark/report_v2.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "CallTo",
        "ref": "get_missing_files",
        "source": "benchmark/report_v2.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "ImportFrom",
        "ref": "get_missing_files",
        "source": "benchmark/report_v2.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "CallTo",
        "ref": "get_missing_files",
        "source": "benchmark/report_v2.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "ImportFrom",
        "ref": "get_missing_files",
        "source": "benchmark/report_v2.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "benchmark/report_v2.py::2",
        "dst": 17,
        "kind": "ChunkToCluster",
        "source": "benchmark/report_v2.py::2",
        "target": 17
      },
      {
        "src": "benchmark/report_v2.py::3",
        "dst": "moatless/trajectory.py::2",
        "kind": "CallTo",
        "ref": "Trajectory",
        "source": "benchmark/report_v2.py::3",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/report_v2.py::3",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "benchmark/report_v2.py::3",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "benchmark/report_v2.py::3",
        "dst": "moatless/file_context.py::14",
        "kind": "CallTo",
        "ref": "FileContext",
        "source": "benchmark/report_v2.py::3",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "benchmark/report_v2.py::3",
        "dst": "moatless/file_context.py::14",
        "kind": "ImportFrom",
        "ref": "FileContext",
        "source": "benchmark/report_v2.py::3",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "benchmark/report_v2.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Content",
        "source": "benchmark/report_v2.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "benchmark/report_v2.py::3",
        "dst": 9,
        "kind": "ChunkToCluster",
        "source": "benchmark/report_v2.py::3",
        "target": 9
      },
      {
        "src": "benchmark/report_v2.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "CallTo",
        "ref": "FileContext",
        "source": "benchmark/report_v2.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "benchmark/report_v2.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "ImportFrom",
        "ref": "FileContext",
        "source": "benchmark/report_v2.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "benchmark/report_v2.py::4",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "benchmark/report_v2.py::4",
        "target": 5
      },
      {
        "src": "swebench/utils.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "CallTo",
        "ref": "get_missing_spans",
        "source": "swebench/utils.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "swebench/utils.py::2",
        "dst": "benchmark/utils.py::6",
        "kind": "ImportFrom",
        "ref": "get_missing_spans",
        "source": "swebench/utils.py::2",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "swebench/utils.py::2",
        "dst": 17,
        "kind": "ChunkToCluster",
        "source": "swebench/utils.py::2",
        "target": 17
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "moatless/workspace.py::2",
        "kind": "ImportFrom",
        "ref": "Workspace",
        "source": "swebench/utils.py::3",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "CallTo",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "CallTo",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::5",
        "kind": "ImportFrom",
        "ref": "file_spans_to_dict",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::5"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::6",
        "kind": "CallTo",
        "ref": "get_missing_files",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": "benchmark/utils.py::6",
        "kind": "ImportFrom",
        "ref": "get_missing_files",
        "source": "swebench/utils.py::3",
        "target": "benchmark/utils.py::6"
      },
      {
        "src": "swebench/utils.py::3",
        "dst": 14,
        "kind": "ChunkToCluster",
        "source": "swebench/utils.py::3",
        "target": 14
      },
      {
        "src": "swebench/utils.py::4",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "swebench/utils.py::4",
        "target": "repository/file.py::5"
      },
      {
        "src": "swebench/utils.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "CallTo",
        "ref": "FileContext",
        "source": "swebench/utils.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "swebench/utils.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "ImportFrom",
        "ref": "FileContext",
        "source": "swebench/utils.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "swebench/utils.py::4",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "swebench/utils.py::4",
        "target": 5
      },
      {
        "src": "swebench/utils.py::5",
        "dst": "utils/repo.py::1",
        "kind": "CallTo",
        "ref": "setup_github_repo",
        "source": "swebench/utils.py::5",
        "target": "utils/repo.py::1"
      },
      {
        "src": "swebench/utils.py::5",
        "dst": "utils/repo.py::1",
        "kind": "ImportFrom",
        "ref": "setup_github_repo",
        "source": "swebench/utils.py::5",
        "target": "utils/repo.py::1"
      },
      {
        "src": "swebench/utils.py::5",
        "dst": 21,
        "kind": "ChunkToCluster",
        "source": "swebench/utils.py::5",
        "target": 21
      },
      {
        "src": "swebench/utils.py::6",
        "dst": "repository/git.py::1",
        "kind": "CallTo",
        "ref": "GitRepository",
        "source": "swebench/utils.py::6",
        "target": "repository/git.py::1"
      },
      {
        "src": "swebench/utils.py::6",
        "dst": "repository/git.py::1",
        "kind": "ImportFrom",
        "ref": "GitRepository",
        "source": "swebench/utils.py::6",
        "target": "repository/git.py::1"
      },
      {
        "src": "swebench/utils.py::6",
        "dst": "index/code_index.py::2",
        "kind": "CallTo",
        "ref": "CodeIndex",
        "source": "swebench/utils.py::6",
        "target": "index/code_index.py::2"
      },
      {
        "src": "swebench/utils.py::6",
        "dst": "index/code_index.py::2",
        "kind": "ImportFrom",
        "ref": "CodeIndex",
        "source": "swebench/utils.py::6",
        "target": "index/code_index.py::2"
      },
      {
        "src": "swebench/utils.py::6",
        "dst": "moatless/workspace.py::2",
        "kind": "CallTo",
        "ref": "Workspace",
        "source": "swebench/utils.py::6",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "swebench/utils.py::6",
        "dst": "moatless/workspace.py::2",
        "kind": "ImportFrom",
        "ref": "Workspace",
        "source": "swebench/utils.py::6",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "swebench/utils.py::6",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "swebench/utils.py::6",
        "target": 11
      },
      {
        "src": "benchmark/utils.py::1",
        "dst": "codeblocks/module.py::1",
        "kind": "ImportFrom",
        "ref": "Module",
        "source": "benchmark/utils.py::1",
        "target": "codeblocks/module.py::1"
      },
      {
        "src": "benchmark/utils.py::1",
        "dst": "codeblocks/module.py::1",
        "kind": "ImportFrom",
        "ref": "Module",
        "source": "benchmark/utils.py::1",
        "target": "codeblocks/module.py::1"
      },
      {
        "src": "benchmark/utils.py::1",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::1",
        "target": 12
      },
      {
        "src": "benchmark/utils.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::1",
        "target": 7
      },
      {
        "src": "benchmark/utils.py::3",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "benchmark/utils.py::3",
        "target": "repository/file.py::5"
      },
      {
        "src": "benchmark/utils.py::3",
        "dst": "moatless/types.py::1",
        "kind": "CallTo",
        "ref": "FileWithSpans",
        "source": "benchmark/utils.py::3",
        "target": "moatless/types.py::1"
      },
      {
        "src": "benchmark/utils.py::3",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "FileWithSpans",
        "source": "benchmark/utils.py::3",
        "target": "moatless/types.py::1"
      },
      {
        "src": "benchmark/utils.py::3",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::3",
        "target": 8
      },
      {
        "src": "benchmark/utils.py::3",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::3",
        "target": 4
      },
      {
        "src": "benchmark/utils.py::4",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "benchmark/utils.py::4",
        "target": "repository/file.py::5"
      },
      {
        "src": "benchmark/utils.py::4",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::4",
        "target": 5
      },
      {
        "src": "benchmark/utils.py::5",
        "dst": 14,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::5",
        "target": 14
      },
      {
        "src": "benchmark/utils.py::6",
        "dst": 17,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::6",
        "target": 17
      },
      {
        "src": "benchmark/utils.py::8",
        "dst": 9,
        "kind": "ChunkToCluster",
        "source": "benchmark/utils.py::8",
        "target": 9
      },
      {
        "src": "codeblocks/__init__.py::1",
        "dst": "parser/parser.py::2",
        "kind": "CallTo",
        "ref": "CodeParser",
        "source": "codeblocks/__init__.py::1",
        "target": "parser/parser.py::2"
      },
      {
        "src": "codeblocks/__init__.py::1",
        "dst": "parser/parser.py::2",
        "kind": "ImportFrom",
        "ref": "CodeParser",
        "source": "codeblocks/__init__.py::1",
        "target": "parser/parser.py::2"
      },
      {
        "src": "codeblocks/__init__.py::1",
        "dst": "parser/python.py::1",
        "kind": "CallTo",
        "ref": "PythonParser",
        "source": "codeblocks/__init__.py::1",
        "target": "parser/python.py::1"
      },
      {
        "src": "codeblocks/__init__.py::1",
        "dst": "parser/python.py::1",
        "kind": "ImportFrom",
        "ref": "PythonParser",
        "source": "codeblocks/__init__.py::1",
        "target": "parser/python.py::1"
      },
      {
        "src": "codeblocks/__init__.py::1",
        "dst": "parser/java.py::1",
        "kind": "ImportFrom",
        "ref": "JavaParser",
        "source": "codeblocks/__init__.py::1",
        "target": "parser/java.py::1"
      },
      {
        "src": "codeblocks/__init__.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "codeblocks/__init__.py::1",
        "target": 7
      },
      {
        "src": "codeblocks/codeblocks.py::1",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::1",
        "target": 2
      },
      {
        "src": "codeblocks/codeblocks.py::1",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::1",
        "target": 11371
      },
      {
        "src": "codeblocks/codeblocks.py::2",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::2",
        "target": 2
      },
      {
        "src": "codeblocks/codeblocks.py::2",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::2",
        "target": 11371
      },
      {
        "src": "codeblocks/codeblocks.py::4",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::4",
        "target": 2
      },
      {
        "src": "codeblocks/codeblocks.py::4",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::4",
        "target": 11371
      },
      {
        "src": "codeblocks/codeblocks.py::6",
        "dst": 6,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::6",
        "target": 6
      },
      {
        "src": "codeblocks/codeblocks.py::7",
        "dst": 6,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::7",
        "target": 6
      },
      {
        "src": "codeblocks/codeblocks.py::8",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::8",
        "target": 2
      },
      {
        "src": "codeblocks/codeblocks.py::8",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::8",
        "target": 11371
      },
      {
        "src": "codeblocks/codeblocks.py::9",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::9",
        "target": 2
      },
      {
        "src": "codeblocks/codeblocks.py::9",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::9",
        "target": 11371
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "CallTo",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "CallTo",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "CallTo",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": "utils/colors.py::1",
        "kind": "ImportFrom",
        "ref": "Colors",
        "source": "codeblocks/codeblocks.py::14",
        "target": "utils/colors.py::1"
      },
      {
        "src": "codeblocks/codeblocks.py::14",
        "dst": 16,
        "kind": "ChunkToCluster",
        "source": "codeblocks/codeblocks.py::14",
        "target": 16
      },
      {
        "src": "codeblocks/module.py::1",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "codeblocks/module.py::1",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "codeblocks/module.py::1",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "codeblocks/module.py::1",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "codeblocks/module.py::1",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "codeblocks/module.py::1",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "codeblocks/module.py::1",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "codeblocks/module.py::1",
        "target": 12
      },
      {
        "src": "codeblocks/module.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "codeblocks/module.py::1",
        "target": 7
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/parser.py::2",
        "kind": "CallTo",
        "ref": "CodeParser",
        "source": "parser/create.py::1",
        "target": "parser/parser.py::2"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/parser.py::2",
        "kind": "ImportFrom",
        "ref": "CodeParser",
        "source": "parser/create.py::1",
        "target": "parser/parser.py::2"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/parser.py::2",
        "kind": "CallTo",
        "ref": "CodeParser",
        "source": "parser/create.py::1",
        "target": "parser/parser.py::2"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/parser.py::2",
        "kind": "ImportFrom",
        "ref": "CodeParser",
        "source": "parser/create.py::1",
        "target": "parser/parser.py::2"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/python.py::1",
        "kind": "CallTo",
        "ref": "PythonParser",
        "source": "parser/create.py::1",
        "target": "parser/python.py::1"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/python.py::1",
        "kind": "ImportFrom",
        "ref": "PythonParser",
        "source": "parser/create.py::1",
        "target": "parser/python.py::1"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/python.py::1",
        "kind": "CallTo",
        "ref": "PythonParser",
        "source": "parser/create.py::1",
        "target": "parser/python.py::1"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/python.py::1",
        "kind": "ImportFrom",
        "ref": "PythonParser",
        "source": "parser/create.py::1",
        "target": "parser/python.py::1"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/java.py::1",
        "kind": "ImportFrom",
        "ref": "JavaParser",
        "source": "parser/create.py::1",
        "target": "parser/java.py::1"
      },
      {
        "src": "parser/create.py::1",
        "dst": "parser/java.py::1",
        "kind": "ImportFrom",
        "ref": "JavaParser",
        "source": "parser/create.py::1",
        "target": "parser/java.py::1"
      },
      {
        "src": "parser/create.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "parser/create.py::1",
        "target": 7
      },
      {
        "src": "parser/java.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "parser/java.py::1",
        "target": 7
      },
      {
        "src": "parser/parser.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::1",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::1",
        "target": 2
      },
      {
        "src": "parser/parser.py::1",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::1",
        "target": 11371
      },
      {
        "src": "parser/parser.py::2",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::2",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::2",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::2",
        "target": 7
      },
      {
        "src": "parser/parser.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::4",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::4",
        "target": 2
      },
      {
        "src": "parser/parser.py::4",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::4",
        "target": 11371
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "BlockSpan",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "SpanType",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::5",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/module.py::1",
        "kind": "CallTo",
        "ref": "Module",
        "source": "parser/parser.py::5",
        "target": "codeblocks/module.py::1"
      },
      {
        "src": "parser/parser.py::5",
        "dst": "codeblocks/module.py::1",
        "kind": "ImportFrom",
        "ref": "Module",
        "source": "parser/parser.py::5",
        "target": "codeblocks/module.py::1"
      },
      {
        "src": "parser/parser.py::5",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::5",
        "target": 2
      },
      {
        "src": "parser/parser.py::5",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::5",
        "target": 11371
      },
      {
        "src": "parser/parser.py::6",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "parser/parser.py::6",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::6",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::6",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::6",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::6",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::6",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::6",
        "target": 2
      },
      {
        "src": "parser/parser.py::6",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::6",
        "target": 11371
      },
      {
        "src": "parser/parser.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::7",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::7",
        "target": 2
      },
      {
        "src": "parser/parser.py::7",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::7",
        "target": 11371
      },
      {
        "src": "parser/parser.py::10",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::10",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::10",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::10",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::10",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::10",
        "target": 2
      },
      {
        "src": "parser/parser.py::10",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::10",
        "target": 11371
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "CallTo",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "ImportFrom",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "CallTo",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "ImportFrom",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "CallTo",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "ImportFrom",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "CallTo",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::7",
        "kind": "ImportFrom",
        "ref": "Relationship",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::7"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "ReferenceScope",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "ReferenceScope",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "ReferenceScope",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "ReferenceScope",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "ReferenceScope",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "RelationshipType",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "ReferenceScope",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "ReferenceScope",
        "source": "parser/parser.py::11",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/parser.py::11",
        "dst": 6,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::11",
        "target": 6
      },
      {
        "src": "parser/parser.py::12",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "Parameter",
        "source": "parser/parser.py::12",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::12",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "Parameter",
        "source": "parser/parser.py::12",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::12",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::12",
        "target": 2
      },
      {
        "src": "parser/parser.py::12",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::12",
        "target": 11371
      },
      {
        "src": "parser/parser.py::13",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "parser/parser.py::13",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::13",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::13",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::13",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::13",
        "target": 2
      },
      {
        "src": "parser/parser.py::13",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::13",
        "target": 11371
      },
      {
        "src": "parser/parser.py::14",
        "dst": "codeblocks/module.py::1",
        "kind": "CallTo",
        "ref": "Module",
        "source": "parser/parser.py::14",
        "target": "codeblocks/module.py::1"
      },
      {
        "src": "parser/parser.py::14",
        "dst": "codeblocks/module.py::1",
        "kind": "ImportFrom",
        "ref": "Module",
        "source": "parser/parser.py::14",
        "target": "codeblocks/module.py::1"
      },
      {
        "src": "parser/parser.py::14",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::14",
        "target": 12
      },
      {
        "src": "parser/parser.py::14",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::14",
        "target": 7
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "SpanType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "SpanType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "SpanType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "SpanType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "SpanType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "SpanType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "SpanType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::15",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::15",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::15",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::15",
        "target": 2
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "BlockSpan",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::16",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/parser.py::16",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/parser.py::16",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::16",
        "target": 2
      },
      {
        "src": "parser/parser.py::17",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/parser.py::17",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/parser.py::17",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::17",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::17",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::17",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::17",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::17",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::17",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "parser/parser.py::17",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "parser/parser.py::17",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/parser.py::17",
        "target": 2
      },
      {
        "src": "parser/python.py::1",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/python.py::1",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/python.py::1",
        "dst": "parser/parser.py::1",
        "kind": "ImportFrom",
        "ref": "NodeMatch",
        "source": "parser/python.py::1",
        "target": "parser/parser.py::1"
      },
      {
        "src": "parser/python.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/python.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/python.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "parser/python.py::1",
        "target": 7
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "CallTo",
        "ref": "ReferenceScope",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::6",
        "kind": "ImportFrom",
        "ref": "ReferenceScope",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::6"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "ValidationError",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/python.py::2",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "ValidationError",
        "source": "parser/python.py::2",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "parser/python.py::2",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "parser/python.py::2",
        "target": 2
      },
      {
        "src": "edit/clarify.py::1",
        "dst": "moatless/types.py::1",
        "kind": "CallTo",
        "ref": "ActionRequest",
        "source": "edit/clarify.py::1",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/clarify.py::1",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "edit/clarify.py::1",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/clarify.py::1",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::1",
        "target": 8
      },
      {
        "src": "edit/clarify.py::1",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::1",
        "target": 4
      },
      {
        "src": "edit/clarify.py::2",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "edit/clarify.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/clarify.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "edit/clarify.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/clarify.py::2",
        "dst": "repository/file.py::2",
        "kind": "CallTo",
        "ref": "CodeFile",
        "source": "edit/clarify.py::2",
        "target": "repository/file.py::2"
      },
      {
        "src": "edit/clarify.py::2",
        "dst": "repository/file.py::2",
        "kind": "ImportFrom",
        "ref": "CodeFile",
        "source": "edit/clarify.py::2",
        "target": "repository/file.py::2"
      },
      {
        "src": "edit/clarify.py::2",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "CallTo",
        "ref": "BlockSpan",
        "source": "edit/clarify.py::2",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "edit/clarify.py::2",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "edit/clarify.py::2",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "edit/clarify.py::2",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::2",
        "target": 97236
      },
      {
        "src": "edit/clarify.py::3",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "FileWithSpans",
        "source": "edit/clarify.py::3",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/clarify.py::3",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/clarify.py::3",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/clarify.py::3",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::3",
        "target": 8
      },
      {
        "src": "edit/clarify.py::3",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::3",
        "target": 4
      },
      {
        "src": "edit/clarify.py::5",
        "dst": "repository/file.py::2",
        "kind": "ImportFrom",
        "ref": "CodeFile",
        "source": "edit/clarify.py::5",
        "target": "repository/file.py::2"
      },
      {
        "src": "edit/clarify.py::5",
        "dst": "codeblocks/codeblocks.py::8",
        "kind": "ImportFrom",
        "ref": "BlockSpan",
        "source": "edit/clarify.py::5",
        "target": "codeblocks/codeblocks.py::8"
      },
      {
        "src": "edit/clarify.py::5",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::5",
        "target": 12
      },
      {
        "src": "edit/clarify.py::5",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::5",
        "target": 7
      },
      {
        "src": "edit/clarify.py::6",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/clarify.py::6",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/clarify.py::6",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/clarify.py::6",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/clarify.py::6",
        "dst": "utils/tokenizer.py::1",
        "kind": "CallTo",
        "ref": "count_tokens",
        "source": "edit/clarify.py::6",
        "target": "utils/tokenizer.py::1"
      },
      {
        "src": "edit/clarify.py::6",
        "dst": "utils/tokenizer.py::1",
        "kind": "ImportFrom",
        "ref": "count_tokens",
        "source": "edit/clarify.py::6",
        "target": "utils/tokenizer.py::1"
      },
      {
        "src": "edit/clarify.py::6",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Message",
        "source": "edit/clarify.py::6",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/clarify.py::6",
        "dst": 19,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::6",
        "target": 19
      },
      {
        "src": "edit/clarify.py::6",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::6",
        "target": 97236
      },
      {
        "src": "edit/clarify.py::7",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/clarify.py::7",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/clarify.py::7",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/clarify.py::7",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/clarify.py::7",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::7",
        "target": 2
      },
      {
        "src": "edit/clarify.py::8",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::8",
        "target": 3
      },
      {
        "src": "edit/clarify.py::9",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/clarify.py::9",
        "target": 3
      },
      {
        "src": "edit/edit.py::1",
        "dst": "moatless/types.py::1",
        "kind": "CallTo",
        "ref": "ActionRequest",
        "source": "edit/edit.py::1",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/edit.py::1",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "edit/edit.py::1",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/edit.py::1",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/edit.py::1",
        "target": 8
      },
      {
        "src": "edit/edit.py::1",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/edit.py::1",
        "target": 4
      },
      {
        "src": "edit/edit.py::2",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "edit/edit.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/edit.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "edit/edit.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/edit.py::2",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "edit/edit.py::2",
        "target": 97236
      },
      {
        "src": "edit/edit.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Content",
        "source": "edit/edit.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/edit.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "AssistantMessage",
        "source": "edit/edit.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/edit.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/edit.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/edit.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/edit.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/edit.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/edit.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/edit.py::3",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/edit.py::3",
        "target": 3
      },
      {
        "src": "edit/edit.py::4",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Content",
        "source": "edit/edit.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/edit.py::4",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "VerificationError",
        "source": "edit/edit.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/edit.py::4",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "VerificationError",
        "source": "edit/edit.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/edit.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/edit.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/edit.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/edit.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/edit.py::4",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/edit.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/edit.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/edit.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/edit.py::4",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/edit.py::4",
        "target": 3
      },
      {
        "src": "edit/edit.py::6",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "UserMessage",
        "source": "edit/edit.py::6",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/edit.py::6",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/edit.py::6",
        "target": 4
      },
      {
        "src": "edit/plan.py::2",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "edit/plan.py::2",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/plan.py::2",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/plan.py::2",
        "target": 8
      },
      {
        "src": "edit/plan.py::2",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/plan.py::2",
        "target": 4
      },
      {
        "src": "edit/plan.py::3",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "edit/plan.py::3",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/plan.py::3",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "edit/plan.py::3",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/plan.py::3",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "edit/plan.py::3",
        "target": 97236
      },
      {
        "src": "edit/plan.py::4",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::4",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::4",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/plan.py::4",
        "target": 3
      },
      {
        "src": "edit/plan.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::5",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/plan.py::5",
        "target": 3
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "edit/plan.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "edit/clarify.py::8",
        "kind": "ImportFrom",
        "ref": "_get_pre_start_line",
        "source": "edit/plan.py::6",
        "target": "edit/clarify.py::8"
      },
      {
        "src": "edit/plan.py::6",
        "dst": "edit/clarify.py::9",
        "kind": "ImportFrom",
        "ref": "_get_post_end_line_index",
        "source": "edit/plan.py::6",
        "target": "edit/clarify.py::9"
      },
      {
        "src": "edit/plan.py::6",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/plan.py::6",
        "target": 3
      },
      {
        "src": "edit/plan.py::8",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "UserMessage",
        "source": "edit/plan.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/plan.py::8",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "UserMessage",
        "source": "edit/plan.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/plan.py::8",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "AssistantMessage",
        "source": "edit/plan.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/plan.py::8",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/plan.py::8",
        "target": 4
      },
      {
        "src": "edit/plan_lines.py::2",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "edit/plan_lines.py::2",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/plan_lines.py::2",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/plan_lines.py::2",
        "target": 8
      },
      {
        "src": "edit/plan_lines.py::2",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/plan_lines.py::2",
        "target": 4
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::3",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "edit/plan_lines.py::3",
        "target": 97236
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/plan_lines.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/plan_lines.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/plan_lines.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/plan_lines.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "edit/plan_lines.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "utils/tokenizer.py::1",
        "kind": "CallTo",
        "ref": "count_tokens",
        "source": "edit/plan_lines.py::4",
        "target": "utils/tokenizer.py::1"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "utils/tokenizer.py::1",
        "kind": "ImportFrom",
        "ref": "count_tokens",
        "source": "edit/plan_lines.py::4",
        "target": "utils/tokenizer.py::1"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "edit/clarify.py::8",
        "kind": "CallTo",
        "ref": "_get_pre_start_line",
        "source": "edit/plan_lines.py::4",
        "target": "edit/clarify.py::8"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "edit/clarify.py::8",
        "kind": "ImportFrom",
        "ref": "_get_pre_start_line",
        "source": "edit/plan_lines.py::4",
        "target": "edit/clarify.py::8"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": "edit/clarify.py::9",
        "kind": "ImportFrom",
        "ref": "_get_post_end_line_index",
        "source": "edit/plan_lines.py::4",
        "target": "edit/clarify.py::9"
      },
      {
        "src": "edit/plan_lines.py::4",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/plan_lines.py::4",
        "target": 3
      },
      {
        "src": "edit/plan_lines.py::6",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "UserMessage",
        "source": "edit/plan_lines.py::6",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/plan_lines.py::6",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "UserMessage",
        "source": "edit/plan_lines.py::6",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/plan_lines.py::6",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "AssistantMessage",
        "source": "edit/plan_lines.py::6",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/plan_lines.py::6",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/plan_lines.py::6",
        "target": 4
      },
      {
        "src": "edit/review.py::1",
        "dst": "moatless/types.py::1",
        "kind": "CallTo",
        "ref": "ActionRequest",
        "source": "edit/review.py::1",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/review.py::1",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "edit/review.py::1",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/review.py::1",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::1",
        "target": 8
      },
      {
        "src": "edit/review.py::1",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::1",
        "target": 4
      },
      {
        "src": "edit/review.py::2",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "edit/review.py::2",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/review.py::2",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::2",
        "target": 8
      },
      {
        "src": "edit/review.py::2",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::2",
        "target": 4
      },
      {
        "src": "edit/review.py::3",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "edit/review.py::3",
        "target": "moatless/types.py::1"
      },
      {
        "src": "edit/review.py::3",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::3",
        "target": 8
      },
      {
        "src": "edit/review.py::3",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::3",
        "target": 4
      },
      {
        "src": "edit/review.py::4",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "edit/review.py::4",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/review.py::4",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "edit/review.py::4",
        "target": "moatless/state.py::2"
      },
      {
        "src": "edit/review.py::4",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::4",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::4",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::4",
        "target": 97236
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::5",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::5",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::5",
        "target": 3
      },
      {
        "src": "edit/review.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::6",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::6",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "edit/review.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "edit/review.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "edit/review.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "edit/review.py::6",
        "dst": "edit/clarify.py::8",
        "kind": "ImportFrom",
        "ref": "_get_pre_start_line",
        "source": "edit/review.py::6",
        "target": "edit/clarify.py::8"
      },
      {
        "src": "edit/review.py::6",
        "dst": "edit/clarify.py::9",
        "kind": "ImportFrom",
        "ref": "_get_post_end_line_index",
        "source": "edit/review.py::6",
        "target": "edit/clarify.py::9"
      },
      {
        "src": "edit/review.py::6",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::6",
        "target": 3
      },
      {
        "src": "edit/review.py::7",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "edit/review.py::7",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::7",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::7",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::7",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::7",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::7",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "edit/review.py::7",
        "target": "moatless/types.py::2"
      },
      {
        "src": "edit/review.py::7",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::7",
        "target": 3
      },
      {
        "src": "edit/review.py::9",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "UserMessage",
        "source": "edit/review.py::9",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/review.py::9",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "UserMessage",
        "source": "edit/review.py::9",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/review.py::9",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "AssistantMessage",
        "source": "edit/review.py::9",
        "target": "moatless/types.py::3"
      },
      {
        "src": "edit/review.py::9",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "edit/review.py::9",
        "target": 4
      },
      {
        "src": "moatless/file_context.py::1",
        "dst": 22,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::1",
        "target": 22
      },
      {
        "src": "moatless/file_context.py::2",
        "dst": "repository/file.py::2",
        "kind": "ImportFrom",
        "ref": "CodeFile",
        "source": "moatless/file_context.py::2",
        "target": "repository/file.py::2"
      },
      {
        "src": "moatless/file_context.py::2",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::2",
        "target": 12
      },
      {
        "src": "moatless/file_context.py::2",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::2",
        "target": 7
      },
      {
        "src": "moatless/file_context.py::4",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "moatless/file_context.py::4",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "moatless/file_context.py::4",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::4",
        "target": 2
      },
      {
        "src": "moatless/file_context.py::4",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::4",
        "target": 11
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "SpanMarker",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "SpanMarker",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "moatless/file_context.py::6",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::6",
        "target": 2
      },
      {
        "src": "moatless/file_context.py::6",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::6",
        "target": 11
      },
      {
        "src": "moatless/file_context.py::11",
        "dst": "repository/file.py::1",
        "kind": "ImportFrom",
        "ref": "UpdateResult",
        "source": "moatless/file_context.py::11",
        "target": "repository/file.py::1"
      },
      {
        "src": "moatless/file_context.py::11",
        "dst": 26,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::11",
        "target": 26
      },
      {
        "src": "moatless/file_context.py::12",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "moatless/file_context.py::12",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "moatless/file_context.py::12",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::12",
        "target": 2
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "CallTo",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "CallTo",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "CallTo",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "CallTo",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "moatless/file_context.py::14",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/file_context.py::14",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "moatless/file_context.py::14",
        "target": 5
      },
      {
        "src": "find/decide.py::2",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "find/decide.py::2",
        "target": "moatless/types.py::1"
      },
      {
        "src": "find/decide.py::2",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "find/decide.py::2",
        "target": 8
      },
      {
        "src": "find/decide.py::2",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "find/decide.py::2",
        "target": 4
      },
      {
        "src": "find/decide.py::3",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "find/decide.py::3",
        "target": "moatless/state.py::2"
      },
      {
        "src": "find/decide.py::3",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "find/decide.py::3",
        "target": "moatless/state.py::2"
      },
      {
        "src": "find/decide.py::3",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "find/decide.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "find/decide.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "find/decide.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "find/decide.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "find/decide.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "find/decide.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "find/decide.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "find/decide.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "find/decide.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "find/decide.py::3",
        "dst": 77036,
        "kind": "ChunkToCluster",
        "source": "find/decide.py::3",
        "target": 77036
      },
      {
        "src": "find/identify.py::1",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "find/identify.py::1",
        "target": "moatless/types.py::1"
      },
      {
        "src": "find/identify.py::1",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "find/identify.py::1",
        "target": 8
      },
      {
        "src": "find/identify.py::1",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "find/identify.py::1",
        "target": 4
      },
      {
        "src": "find/identify.py::2",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "find/identify.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "find/identify.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "find/identify.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "find/identify.py::2",
        "dst": 77036,
        "kind": "ChunkToCluster",
        "source": "find/identify.py::2",
        "target": 77036
      },
      {
        "src": "find/identify.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "find/identify.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "find/identify.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "find/identify.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "find/identify.py::3",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "find/identify.py::3",
        "target": 3
      },
      {
        "src": "find/search.py::5",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "find/search.py::5",
        "target": "moatless/types.py::1"
      },
      {
        "src": "find/search.py::5",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "find/search.py::5",
        "target": 8
      },
      {
        "src": "find/search.py::5",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "find/search.py::5",
        "target": 4
      },
      {
        "src": "find/search.py::6",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "find/search.py::6",
        "target": "moatless/state.py::2"
      },
      {
        "src": "find/search.py::6",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "find/search.py::6",
        "target": "moatless/state.py::2"
      },
      {
        "src": "find/search.py::6",
        "dst": 77036,
        "kind": "ChunkToCluster",
        "source": "find/search.py::6",
        "target": 77036
      },
      {
        "src": "find/search.py::7",
        "dst": "moatless/file_context.py::1",
        "kind": "CallTo",
        "ref": "RankedFileSpan",
        "source": "find/search.py::7",
        "target": "moatless/file_context.py::1"
      },
      {
        "src": "find/search.py::7",
        "dst": "moatless/file_context.py::1",
        "kind": "ImportFrom",
        "ref": "RankedFileSpan",
        "source": "find/search.py::7",
        "target": "moatless/file_context.py::1"
      },
      {
        "src": "find/search.py::7",
        "dst": 22,
        "kind": "ChunkToCluster",
        "source": "find/search.py::7",
        "target": 22
      },
      {
        "src": "find/search.py::8",
        "dst": "utils/llm_utils.py::1",
        "kind": "CallTo",
        "ref": "instructor_mode_by_model",
        "source": "find/search.py::8",
        "target": "utils/llm_utils.py::1"
      },
      {
        "src": "find/search.py::8",
        "dst": "utils/llm_utils.py::1",
        "kind": "ImportFrom",
        "ref": "instructor_mode_by_model",
        "source": "find/search.py::8",
        "target": "utils/llm_utils.py::1"
      },
      {
        "src": "find/search.py::8",
        "dst": 23,
        "kind": "ChunkToCluster",
        "source": "find/search.py::8",
        "target": 23
      },
      {
        "src": "find/search.py::9",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "UserMessage",
        "source": "find/search.py::9",
        "target": "moatless/types.py::3"
      },
      {
        "src": "find/search.py::9",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "UserMessage",
        "source": "find/search.py::9",
        "target": "moatless/types.py::3"
      },
      {
        "src": "find/search.py::9",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "AssistantMessage",
        "source": "find/search.py::9",
        "target": "moatless/types.py::3"
      },
      {
        "src": "find/search.py::9",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "find/search.py::9",
        "target": 4
      },
      {
        "src": "index/code_index.py::1",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "IndexSettings",
        "source": "index/code_index.py::1",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/code_index.py::1",
        "dst": "index/simple_faiss.py::2",
        "kind": "ImportFrom",
        "ref": "SimpleFaissVectorStore",
        "source": "index/code_index.py::1",
        "target": "index/simple_faiss.py::2"
      },
      {
        "src": "index/code_index.py::1",
        "dst": 20,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::1",
        "target": 20
      },
      {
        "src": "index/code_index.py::2",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "index/code_index.py::2",
        "target": "repository/file.py::5"
      },
      {
        "src": "index/code_index.py::2",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "IndexSettings",
        "source": "index/code_index.py::2",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/code_index.py::2",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "IndexSettings",
        "source": "index/code_index.py::2",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/code_index.py::2",
        "dst": "index/embed_model.py::1",
        "kind": "CallTo",
        "ref": "get_embed_model",
        "source": "index/code_index.py::2",
        "target": "index/embed_model.py::1"
      },
      {
        "src": "index/code_index.py::2",
        "dst": "index/embed_model.py::1",
        "kind": "ImportFrom",
        "ref": "get_embed_model",
        "source": "index/code_index.py::2",
        "target": "index/embed_model.py::1"
      },
      {
        "src": "index/code_index.py::2",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::2",
        "target": 11
      },
      {
        "src": "index/code_index.py::3",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "index/code_index.py::3",
        "target": "repository/file.py::5"
      },
      {
        "src": "index/code_index.py::3",
        "dst": "index/simple_faiss.py::2",
        "kind": "CallTo",
        "ref": "SimpleFaissVectorStore",
        "source": "index/code_index.py::3",
        "target": "index/simple_faiss.py::2"
      },
      {
        "src": "index/code_index.py::3",
        "dst": "index/simple_faiss.py::2",
        "kind": "ImportFrom",
        "ref": "SimpleFaissVectorStore",
        "source": "index/code_index.py::3",
        "target": "index/simple_faiss.py::2"
      },
      {
        "src": "index/code_index.py::3",
        "dst": 20,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::3",
        "target": 20
      },
      {
        "src": "index/code_index.py::4",
        "dst": "repository/file.py::5",
        "kind": "CallTo",
        "ref": "FileRepository",
        "source": "index/code_index.py::4",
        "target": "repository/file.py::5"
      },
      {
        "src": "index/code_index.py::4",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "index/code_index.py::4",
        "target": "repository/file.py::5"
      },
      {
        "src": "index/code_index.py::4",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::4",
        "target": 5
      },
      {
        "src": "index/code_index.py::5",
        "dst": "repository/file.py::5",
        "kind": "CallTo",
        "ref": "FileRepository",
        "source": "index/code_index.py::5",
        "target": "repository/file.py::5"
      },
      {
        "src": "index/code_index.py::5",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "index/code_index.py::5",
        "target": "repository/file.py::5"
      },
      {
        "src": "index/code_index.py::5",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::5",
        "target": 5
      },
      {
        "src": "index/code_index.py::6",
        "dst": "index/types.py::2",
        "kind": "CallTo",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::6",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::6",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::6",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::6",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::6",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::6",
        "dst": 13,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::6",
        "target": 13
      },
      {
        "src": "index/code_index.py::7",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::7",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::7",
        "dst": 13,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::7",
        "target": 13
      },
      {
        "src": "index/code_index.py::8",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeHit",
        "source": "index/code_index.py::8",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::8",
        "dst": 13,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::8",
        "target": 13
      },
      {
        "src": "index/code_index.py::9",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::9",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::9",
        "dst": "index/types.py::2",
        "kind": "CallTo",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::9",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::9",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::9",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::9",
        "dst": 13,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::9",
        "target": 13
      },
      {
        "src": "index/code_index.py::10",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::10",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::10",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::10",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::10",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::10",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::10",
        "dst": "index/types.py::2",
        "kind": "CallTo",
        "ref": "SearchCodeHit",
        "source": "index/code_index.py::10",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::10",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeHit",
        "source": "index/code_index.py::10",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::10",
        "dst": 13,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::10",
        "target": 13
      },
      {
        "src": "index/code_index.py::11",
        "dst": "index/types.py::2",
        "kind": "CallTo",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::11",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::11",
        "dst": "index/types.py::2",
        "kind": "ImportFrom",
        "ref": "SearchCodeResponse",
        "source": "index/code_index.py::11",
        "target": "index/types.py::2"
      },
      {
        "src": "index/code_index.py::11",
        "dst": 13,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::11",
        "target": 13
      },
      {
        "src": "index/code_index.py::12",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/code_index.py::12",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/code_index.py::12",
        "dst": "moatless/types.py::1",
        "kind": "CallTo",
        "ref": "FileWithSpans",
        "source": "index/code_index.py::12",
        "target": "moatless/types.py::1"
      },
      {
        "src": "index/code_index.py::12",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "FileWithSpans",
        "source": "index/code_index.py::12",
        "target": "moatless/types.py::1"
      },
      {
        "src": "index/code_index.py::12",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::12",
        "target": 8
      },
      {
        "src": "index/code_index.py::12",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::12",
        "target": 4
      },
      {
        "src": "index/code_index.py::13",
        "dst": "index/types.py::1",
        "kind": "CallTo",
        "ref": "CodeSnippet",
        "source": "index/code_index.py::13",
        "target": "index/types.py::1"
      },
      {
        "src": "index/code_index.py::13",
        "dst": "index/types.py::1",
        "kind": "ImportFrom",
        "ref": "CodeSnippet",
        "source": "index/code_index.py::13",
        "target": "index/types.py::1"
      },
      {
        "src": "index/code_index.py::13",
        "dst": 24,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::13",
        "target": 24
      },
      {
        "src": "index/code_index.py::16",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "index/code_index.py::16",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/code_index.py::16",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/code_index.py::16",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/code_index.py::16",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/code_index.py::16",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/code_index.py::16",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/code_index.py::16",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/code_index.py::16",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::16",
        "target": 2
      },
      {
        "src": "index/code_index.py::16",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::16",
        "target": 11
      },
      {
        "src": "index/code_index.py::17",
        "dst": "index/epic_split.py::2",
        "kind": "CallTo",
        "ref": "EpicSplitter",
        "source": "index/code_index.py::17",
        "target": "index/epic_split.py::2"
      },
      {
        "src": "index/code_index.py::17",
        "dst": "index/epic_split.py::2",
        "kind": "ImportFrom",
        "ref": "EpicSplitter",
        "source": "index/code_index.py::17",
        "target": "index/epic_split.py::2"
      },
      {
        "src": "index/code_index.py::17",
        "dst": 15,
        "kind": "ChunkToCluster",
        "source": "index/code_index.py::17",
        "target": 15
      },
      {
        "src": "index/code_node.py::1",
        "dst": 25,
        "kind": "ChunkToCluster",
        "source": "index/code_node.py::1",
        "target": 25
      },
      {
        "src": "index/embed_model.py::1",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "index/embed_model.py::1",
        "target": 11
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::1",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::1",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::1",
        "target": 2
      },
      {
        "src": "index/epic_split.py::1",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::1",
        "target": 11
      },
      {
        "src": "index/epic_split.py::2",
        "dst": "index/settings.py::1",
        "kind": "CallTo",
        "ref": "CommentStrategy",
        "source": "index/epic_split.py::2",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/epic_split.py::2",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "CommentStrategy",
        "source": "index/epic_split.py::2",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/epic_split.py::2",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "CommentStrategy",
        "source": "index/epic_split.py::2",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/epic_split.py::2",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "CommentStrategy",
        "source": "index/epic_split.py::2",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/epic_split.py::2",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::2",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::2",
        "dst": 15,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::2",
        "target": 15
      },
      {
        "src": "index/epic_split.py::3",
        "dst": "parser/create.py::1",
        "kind": "CallTo",
        "ref": "create_parser",
        "source": "index/epic_split.py::3",
        "target": "parser/create.py::1"
      },
      {
        "src": "index/epic_split.py::3",
        "dst": "parser/create.py::1",
        "kind": "ImportFrom",
        "ref": "create_parser",
        "source": "index/epic_split.py::3",
        "target": "parser/create.py::1"
      },
      {
        "src": "index/epic_split.py::3",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::3",
        "target": 7
      },
      {
        "src": "index/epic_split.py::4",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::4",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::4",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::4",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::4",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::4",
        "target": 2
      },
      {
        "src": "index/epic_split.py::4",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::4",
        "target": 11
      },
      {
        "src": "index/epic_split.py::5",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::5",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::5",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::5",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::5",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::5",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::5",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "CommentStrategy",
        "source": "index/epic_split.py::5",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/epic_split.py::5",
        "dst": "index/settings.py::1",
        "kind": "CallTo",
        "ref": "CommentStrategy",
        "source": "index/epic_split.py::5",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/epic_split.py::5",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "CommentStrategy",
        "source": "index/epic_split.py::5",
        "target": "index/settings.py::1"
      },
      {
        "src": "index/epic_split.py::5",
        "dst": 15,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::5",
        "target": 15
      },
      {
        "src": "index/epic_split.py::6",
        "dst": "codeblocks/codeblocks.py::4",
        "kind": "CallTo",
        "ref": "PathTree",
        "source": "index/epic_split.py::6",
        "target": "codeblocks/codeblocks.py::4"
      },
      {
        "src": "index/epic_split.py::6",
        "dst": "codeblocks/codeblocks.py::4",
        "kind": "ImportFrom",
        "ref": "PathTree",
        "source": "index/epic_split.py::6",
        "target": "codeblocks/codeblocks.py::4"
      },
      {
        "src": "index/epic_split.py::6",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::6",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::6",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::6",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::6",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::6",
        "target": 2
      },
      {
        "src": "index/epic_split.py::6",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::6",
        "target": 11
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "CallTo",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::9",
        "kind": "ImportFrom",
        "ref": "CodeBlock",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::9"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::4",
        "kind": "CallTo",
        "ref": "PathTree",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::4"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::4",
        "kind": "ImportFrom",
        "ref": "PathTree",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::4"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "index/epic_split.py::7",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "index/epic_split.py::7",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::7",
        "target": 2
      },
      {
        "src": "index/epic_split.py::7",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::7",
        "target": 11
      },
      {
        "src": "index/epic_split.py::8",
        "dst": "index/code_node.py::1",
        "kind": "CallTo",
        "ref": "CodeNode",
        "source": "index/epic_split.py::8",
        "target": "index/code_node.py::1"
      },
      {
        "src": "index/epic_split.py::8",
        "dst": "index/code_node.py::1",
        "kind": "ImportFrom",
        "ref": "CodeNode",
        "source": "index/epic_split.py::8",
        "target": "index/code_node.py::1"
      },
      {
        "src": "index/epic_split.py::8",
        "dst": 25,
        "kind": "ChunkToCluster",
        "source": "index/epic_split.py::8",
        "target": 25
      },
      {
        "src": "index/settings.py::1",
        "dst": 15,
        "kind": "ChunkToCluster",
        "source": "index/settings.py::1",
        "target": 15
      },
      {
        "src": "index/simple_faiss.py::2",
        "dst": 20,
        "kind": "ChunkToCluster",
        "source": "index/simple_faiss.py::2",
        "target": 20
      },
      {
        "src": "index/types.py::1",
        "dst": 24,
        "kind": "ChunkToCluster",
        "source": "index/types.py::1",
        "target": 24
      },
      {
        "src": "index/types.py::2",
        "dst": 13,
        "kind": "ChunkToCluster",
        "source": "index/types.py::2",
        "target": 13
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/loop.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/loop.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/workspace.py::2",
        "kind": "ImportFrom",
        "ref": "Workspace",
        "source": "moatless/loop.py::2",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "moatless/loop.py::2",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "moatless/loop.py::2",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/trajectory.py::2",
        "kind": "CallTo",
        "ref": "Trajectory",
        "source": "moatless/loop.py::2",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/trajectory.py::2",
        "kind": "ImportFrom",
        "ref": "Trajectory",
        "source": "moatless/loop.py::2",
        "target": "moatless/trajectory.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Pending",
        "source": "moatless/loop.py::2",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Pending",
        "source": "moatless/loop.py::2",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::2",
        "dst": 9,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::2",
        "target": 9
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Response",
        "source": "moatless/loop.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Response",
        "source": "moatless/loop.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Pending",
        "source": "moatless/loop.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Pending",
        "source": "moatless/loop.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "moatless/loop.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/loop.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Rejected",
        "source": "moatless/loop.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "moatless/loop.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::3",
        "dst": 57098,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::3",
        "target": 57098
      },
      {
        "src": "moatless/loop.py::3",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::3",
        "target": 97236
      },
      {
        "src": "moatless/loop.py::4",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::4",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::4",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "moatless/loop.py::4",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::4",
        "dst": 57098,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::4",
        "target": 57098
      },
      {
        "src": "moatless/loop.py::4",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::4",
        "target": 97236
      },
      {
        "src": "moatless/loop.py::5",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::5",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::5",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Pending",
        "source": "moatless/loop.py::5",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::5",
        "dst": 57098,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::5",
        "target": 57098
      },
      {
        "src": "moatless/loop.py::5",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::5",
        "target": 97236
      },
      {
        "src": "moatless/loop.py::6",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/loop.py::6",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/loop.py::6",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::6",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::6",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "moatless/loop.py::6",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::6",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/loop.py::6",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::6",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Rejected",
        "source": "moatless/loop.py::6",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::6",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "moatless/loop.py::6",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::6",
        "dst": 57098,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::6",
        "target": 57098
      },
      {
        "src": "moatless/loop.py::6",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::6",
        "target": 97236
      },
      {
        "src": "moatless/loop.py::7",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "NoopState",
        "source": "moatless/loop.py::7",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::7",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "NoopState",
        "source": "moatless/loop.py::7",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/loop.py::7",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "moatless/loop.py::7",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::7",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::7",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::7",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "moatless/loop.py::7",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::7",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::7",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::7",
        "dst": 57098,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::7",
        "target": 57098
      },
      {
        "src": "moatless/loop.py::7",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::7",
        "target": 97236
      },
      {
        "src": "moatless/loop.py::8",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Usage",
        "source": "moatless/loop.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::8",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "Usage",
        "source": "moatless/loop.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::8",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Usage",
        "source": "moatless/loop.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::8",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Content",
        "source": "moatless/loop.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::8",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "Usage",
        "source": "moatless/loop.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::8",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Usage",
        "source": "moatless/loop.py::8",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/loop.py::8",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::8",
        "target": 4
      },
      {
        "src": "moatless/loop.py::9",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/loop.py::9",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/loop.py::9",
        "dst": 57098,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::9",
        "target": 57098
      },
      {
        "src": "moatless/loop.py::9",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::9",
        "target": 97236
      },
      {
        "src": "moatless/loop.py::10",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "moatless/loop.py::10",
        "target": "moatless/types.py::1"
      },
      {
        "src": "moatless/loop.py::10",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::10",
        "target": 8
      },
      {
        "src": "moatless/loop.py::10",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "moatless/loop.py::10",
        "target": 4
      },
      {
        "src": "repository/file.py::1",
        "dst": 26,
        "kind": "ChunkToCluster",
        "source": "repository/file.py::1",
        "target": 26
      },
      {
        "src": "repository/file.py::2",
        "dst": "codeblocks/module.py::1",
        "kind": "ImportFrom",
        "ref": "Module",
        "source": "repository/file.py::2",
        "target": "codeblocks/module.py::1"
      },
      {
        "src": "repository/file.py::2",
        "dst": "parser/python.py::1",
        "kind": "CallTo",
        "ref": "PythonParser",
        "source": "repository/file.py::2",
        "target": "parser/python.py::1"
      },
      {
        "src": "repository/file.py::2",
        "dst": "parser/python.py::1",
        "kind": "ImportFrom",
        "ref": "PythonParser",
        "source": "repository/file.py::2",
        "target": "parser/python.py::1"
      },
      {
        "src": "repository/file.py::2",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "repository/file.py::2",
        "target": 12
      },
      {
        "src": "repository/file.py::2",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "repository/file.py::2",
        "target": 7
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "CallTo",
        "ref": "CodeBlockType",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::2",
        "kind": "ImportFrom",
        "ref": "CodeBlockType",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::2"
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "CallTo",
        "ref": "CodeBlockTypeGroup",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "repository/file.py::4",
        "dst": "codeblocks/codeblocks.py::1",
        "kind": "ImportFrom",
        "ref": "CodeBlockTypeGroup",
        "source": "repository/file.py::4",
        "target": "codeblocks/codeblocks.py::1"
      },
      {
        "src": "repository/file.py::4",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "repository/file.py::4",
        "target": 2
      },
      {
        "src": "repository/file.py::5",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "repository/file.py::5",
        "target": 5
      },
      {
        "src": "repository/git.py::1",
        "dst": "utils/repo.py::5",
        "kind": "ImportFrom",
        "ref": "checkout_commit",
        "source": "repository/git.py::1",
        "target": "utils/repo.py::5"
      },
      {
        "src": "repository/git.py::1",
        "dst": "utils/repo.py::2",
        "kind": "ImportFrom",
        "ref": "maybe_clone",
        "source": "repository/git.py::1",
        "target": "utils/repo.py::2"
      },
      {
        "src": "repository/git.py::1",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "repository/git.py::1",
        "target": 5
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/types.py::1",
        "kind": "CallTo",
        "ref": "ActionRequest",
        "source": "moatless/state.py::2",
        "target": "moatless/types.py::1"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "moatless/state.py::2",
        "target": "moatless/types.py::1"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "Usage",
        "source": "moatless/state.py::2",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Usage",
        "source": "moatless/state.py::2",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "ActionTransaction",
        "source": "moatless/state.py::2",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/types.py::2",
        "kind": "CallTo",
        "ref": "ActionResponse",
        "source": "moatless/state.py::2",
        "target": "moatless/types.py::2"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "moatless/state.py::2",
        "target": "moatless/types.py::2"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/file_context.py::14",
        "kind": "CallTo",
        "ref": "FileContext",
        "source": "moatless/state.py::2",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "moatless/state.py::2",
        "dst": "moatless/file_context.py::14",
        "kind": "ImportFrom",
        "ref": "FileContext",
        "source": "moatless/state.py::2",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "moatless/state.py::2",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/state.py::2",
        "target": 31509
      },
      {
        "src": "moatless/state.py::4",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "Content",
        "source": "moatless/state.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::4",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Content",
        "source": "moatless/state.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::4",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "AssistantMessage",
        "source": "moatless/state.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::4",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "AssistantMessage",
        "source": "moatless/state.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::4",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "AssistantMessage",
        "source": "moatless/state.py::4",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/state.py::4",
        "dst": "moatless/types.py::1",
        "kind": "ImportFrom",
        "ref": "ActionRequest",
        "source": "moatless/state.py::4",
        "target": "moatless/types.py::1"
      },
      {
        "src": "moatless/state.py::4",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "moatless/state.py::4",
        "target": 4
      },
      {
        "src": "moatless/state.py::5",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/state.py::5",
        "target": 31509
      },
      {
        "src": "moatless/state.py::6",
        "dst": 18,
        "kind": "ChunkToCluster",
        "source": "moatless/state.py::6",
        "target": 18
      },
      {
        "src": "moatless/trajectory.py::1",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/trajectory.py::1",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/trajectory.py::1",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/trajectory.py::1",
        "target": 31509
      },
      {
        "src": "moatless/trajectory.py::2",
        "dst": "moatless/workspace.py::2",
        "kind": "ImportFrom",
        "ref": "Workspace",
        "source": "moatless/trajectory.py::2",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "moatless/trajectory.py::2",
        "dst": 9,
        "kind": "ChunkToCluster",
        "source": "moatless/trajectory.py::2",
        "target": 9
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/workspace.py::2",
        "kind": "CallTo",
        "ref": "Workspace",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/workspace.py::2",
        "kind": "ImportFrom",
        "ref": "Workspace",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/workspace.py::2"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/state.py::6",
        "kind": "CallTo",
        "ref": "get_state_class",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/state.py::6",
        "kind": "ImportFrom",
        "ref": "get_state_class",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "Content",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Content",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "Usage",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "Usage",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": "moatless/types.py::2",
        "kind": "ImportFrom",
        "ref": "ActionResponse",
        "source": "moatless/trajectory.py::3",
        "target": "moatless/types.py::2"
      },
      {
        "src": "moatless/trajectory.py::3",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "moatless/trajectory.py::3",
        "target": 4
      },
      {
        "src": "moatless/trajectory.py::6",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/trajectory.py::6",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/trajectory.py::6",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/trajectory.py::6",
        "target": 31509
      },
      {
        "src": "moatless/transition_rules.py::1",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::1",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::1",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::1",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::1",
        "dst": "moatless/state.py::6",
        "kind": "CallTo",
        "ref": "get_state_class",
        "source": "moatless/transition_rules.py::1",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/transition_rules.py::1",
        "dst": "moatless/state.py::6",
        "kind": "ImportFrom",
        "ref": "get_state_class",
        "source": "moatless/transition_rules.py::1",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/transition_rules.py::1",
        "dst": "moatless/state.py::6",
        "kind": "ImportFrom",
        "ref": "get_state_class",
        "source": "moatless/transition_rules.py::1",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/transition_rules.py::1",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/transition_rules.py::1",
        "target": 31509
      },
      {
        "src": "moatless/transition_rules.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::2",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::2",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::2",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::2",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/transition_rules.py::2",
        "target": 31509
      },
      {
        "src": "moatless/transition_rules.py::3",
        "dst": "moatless/state.py::6",
        "kind": "CallTo",
        "ref": "get_state_class",
        "source": "moatless/transition_rules.py::3",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/transition_rules.py::3",
        "dst": "moatless/state.py::6",
        "kind": "ImportFrom",
        "ref": "get_state_class",
        "source": "moatless/transition_rules.py::3",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/transition_rules.py::3",
        "dst": "moatless/state.py::6",
        "kind": "ImportFrom",
        "ref": "get_state_class",
        "source": "moatless/transition_rules.py::3",
        "target": "moatless/state.py::6"
      },
      {
        "src": "moatless/transition_rules.py::3",
        "dst": 18,
        "kind": "ChunkToCluster",
        "source": "moatless/transition_rules.py::3",
        "target": 18
      },
      {
        "src": "moatless/transition_rules.py::4",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::4",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::4",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/transition_rules.py::4",
        "target": 31509
      },
      {
        "src": "moatless/transition_rules.py::5",
        "dst": "moatless/state.py::2",
        "kind": "CallTo",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::5",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::5",
        "dst": "moatless/state.py::2",
        "kind": "ImportFrom",
        "ref": "AgenticState",
        "source": "moatless/transition_rules.py::5",
        "target": "moatless/state.py::2"
      },
      {
        "src": "moatless/transition_rules.py::5",
        "dst": 31509,
        "kind": "ChunkToCluster",
        "source": "moatless/transition_rules.py::5",
        "target": 31509
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::1",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/edit.py::2",
        "kind": "CallTo",
        "ref": "EditCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::1",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/clarify.py::2",
        "kind": "ImportFrom",
        "ref": "ClarifyCodeChange",
        "source": "moatless/transitions.py::1",
        "target": "edit/clarify.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/clarify.py::2",
        "kind": "ImportFrom",
        "ref": "ClarifyCodeChange",
        "source": "moatless/transitions.py::1",
        "target": "edit/clarify.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/clarify.py::2",
        "kind": "CallTo",
        "ref": "ClarifyCodeChange",
        "source": "moatless/transitions.py::1",
        "target": "edit/clarify.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/clarify.py::2",
        "kind": "ImportFrom",
        "ref": "ClarifyCodeChange",
        "source": "moatless/transitions.py::1",
        "target": "edit/clarify.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/clarify.py::2",
        "kind": "CallTo",
        "ref": "ClarifyCodeChange",
        "source": "moatless/transitions.py::1",
        "target": "edit/clarify.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "edit/clarify.py::2",
        "kind": "ImportFrom",
        "ref": "ClarifyCodeChange",
        "source": "moatless/transitions.py::1",
        "target": "edit/clarify.py::2"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "moatless/transitions.py::1",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/transitions.py::1",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Rejected",
        "source": "moatless/transitions.py::1",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "moatless/transitions.py::1",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::1",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::1",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::1",
        "target": 2
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::2",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::2",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::2",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::2",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::2",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::2",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::2",
        "target": 2
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "CallTo",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "CallTo",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "CallTo",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "CallTo",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/plan_lines.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCodeWithLines",
        "source": "moatless/transitions.py::3",
        "target": "edit/plan_lines.py::3"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::3",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::3",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/edit.py::2",
        "kind": "CallTo",
        "ref": "EditCode",
        "source": "moatless/transitions.py::3",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::3",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::3",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "moatless/transitions.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/transitions.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Rejected",
        "source": "moatless/transitions.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "moatless/transitions.py::3",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::3",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::3",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::3",
        "target": 2
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::4",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::4",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::4",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::4",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::4",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "edit/edit.py::2",
        "kind": "CallTo",
        "ref": "EditCode",
        "source": "moatless/transitions.py::4",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::4",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "edit/edit.py::2",
        "kind": "ImportFrom",
        "ref": "EditCode",
        "source": "moatless/transitions.py::4",
        "target": "edit/edit.py::2"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::4",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::4",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::4",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "moatless/transitions.py::4",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/transitions.py::4",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Rejected",
        "source": "moatless/transitions.py::4",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::4",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::4",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::4",
        "target": 2
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::5",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::5",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::5",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::5",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::5",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::5",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::5",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::5",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::5",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::5",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::5",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::5",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::5",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::5",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::5",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "moatless/transitions.py::5",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/transitions.py::5",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/transitions.py::5",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::5",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::5",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::5",
        "target": 2
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::6",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::6",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::6",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::6",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::6",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::6",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::6",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::6",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::6",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::6",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::6",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::6",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::6",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Finished",
        "source": "moatless/transitions.py::6",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/transitions.py::6",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Finished",
        "source": "moatless/transitions.py::6",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::6",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::6",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::6",
        "target": 2
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::7",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "edit/plan.py::3",
        "kind": "CallTo",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::7",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::7",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::7",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::7",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/state.py::5",
        "kind": "CallTo",
        "ref": "Pending",
        "source": "moatless/transitions.py::7",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "moatless/state.py::5",
        "kind": "ImportFrom",
        "ref": "Pending",
        "source": "moatless/transitions.py::7",
        "target": "moatless/state.py::5"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::7",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::7",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::7",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::7",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::7",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::7",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::7",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::7",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::7",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::7",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::7",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/decide.py::3",
        "kind": "CallTo",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::7",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": "find/decide.py::3",
        "kind": "ImportFrom",
        "ref": "DecideRelevance",
        "source": "moatless/transitions.py::7",
        "target": "find/decide.py::3"
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::7",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::7",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::7",
        "target": 2
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::8",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::8",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "moatless/transition_rules.py::2",
        "kind": "CallTo",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::8",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "moatless/transition_rules.py::2",
        "kind": "ImportFrom",
        "ref": "TransitionRules",
        "source": "moatless/transitions.py::8",
        "target": "moatless/transition_rules.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/search.py::6",
        "kind": "CallTo",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/search.py::6",
        "kind": "ImportFrom",
        "ref": "SearchCode",
        "source": "moatless/transitions.py::8",
        "target": "find/search.py::6"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/identify.py::2",
        "kind": "CallTo",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "find/identify.py::2",
        "kind": "ImportFrom",
        "ref": "IdentifyCode",
        "source": "moatless/transitions.py::8",
        "target": "find/identify.py::2"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "edit/plan.py::3",
        "kind": "ImportFrom",
        "ref": "PlanToCode",
        "source": "moatless/transitions.py::8",
        "target": "edit/plan.py::3"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "CallTo",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": "moatless/transition_rules.py::1",
        "kind": "ImportFrom",
        "ref": "TransitionRule",
        "source": "moatless/transitions.py::8",
        "target": "moatless/transition_rules.py::1"
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": 11371,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::8",
        "target": 11371
      },
      {
        "src": "moatless/transitions.py::8",
        "dst": 2,
        "kind": "ChunkToCluster",
        "source": "moatless/transitions.py::8",
        "target": 2
      },
      {
        "src": "moatless/types.py::1",
        "dst": 8,
        "kind": "ChunkToCluster",
        "source": "moatless/types.py::1",
        "target": 8
      },
      {
        "src": "moatless/types.py::1",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "moatless/types.py::1",
        "target": 4
      },
      {
        "src": "moatless/types.py::2",
        "dst": 3,
        "kind": "ChunkToCluster",
        "source": "moatless/types.py::2",
        "target": 3
      },
      {
        "src": "moatless/types.py::3",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "moatless/types.py::3",
        "target": 4
      },
      {
        "src": "utils/colors.py::1",
        "dst": 16,
        "kind": "ChunkToCluster",
        "source": "utils/colors.py::1",
        "target": 16
      },
      {
        "src": "utils/llm_utils.py::1",
        "dst": 23,
        "kind": "ChunkToCluster",
        "source": "utils/llm_utils.py::1",
        "target": 23
      },
      {
        "src": "utils/repo.py::1",
        "dst": 21,
        "kind": "ChunkToCluster",
        "source": "utils/repo.py::1",
        "target": 21
      },
      {
        "src": "utils/repo.py::2",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "utils/repo.py::2",
        "target": 5
      },
      {
        "src": "utils/repo.py::5",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "utils/repo.py::5",
        "target": 5
      },
      {
        "src": "utils/tokenizer.py::1",
        "dst": 19,
        "kind": "ChunkToCluster",
        "source": "utils/tokenizer.py::1",
        "target": 19
      },
      {
        "src": "utils/tokenizer.py::1",
        "dst": 97236,
        "kind": "ChunkToCluster",
        "source": "utils/tokenizer.py::1",
        "target": 97236
      },
      {
        "src": "verify/lint.py::1",
        "dst": "repository/file.py::2",
        "kind": "ImportFrom",
        "ref": "CodeFile",
        "source": "verify/lint.py::1",
        "target": "repository/file.py::2"
      },
      {
        "src": "verify/lint.py::1",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "VerificationError",
        "source": "verify/lint.py::1",
        "target": "moatless/types.py::3"
      },
      {
        "src": "verify/lint.py::1",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "VerificationError",
        "source": "verify/lint.py::1",
        "target": "moatless/types.py::3"
      },
      {
        "src": "verify/lint.py::1",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "verify/lint.py::1",
        "target": 4
      },
      {
        "src": "verify/maven.py::1",
        "dst": "repository/file.py::2",
        "kind": "ImportFrom",
        "ref": "CodeFile",
        "source": "verify/maven.py::1",
        "target": "repository/file.py::2"
      },
      {
        "src": "verify/maven.py::1",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "verify/maven.py::1",
        "target": 12
      },
      {
        "src": "verify/maven.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "verify/maven.py::1",
        "target": 7
      },
      {
        "src": "verify/maven.py::2",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "VerificationError",
        "source": "verify/maven.py::2",
        "target": "moatless/types.py::3"
      },
      {
        "src": "verify/maven.py::2",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "VerificationError",
        "source": "verify/maven.py::2",
        "target": "moatless/types.py::3"
      },
      {
        "src": "verify/maven.py::2",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "verify/maven.py::2",
        "target": 4
      },
      {
        "src": "verify/maven.py::3",
        "dst": "moatless/types.py::3",
        "kind": "CallTo",
        "ref": "VerificationError",
        "source": "verify/maven.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "verify/maven.py::3",
        "dst": "moatless/types.py::3",
        "kind": "ImportFrom",
        "ref": "VerificationError",
        "source": "verify/maven.py::3",
        "target": "moatless/types.py::3"
      },
      {
        "src": "verify/maven.py::3",
        "dst": 4,
        "kind": "ChunkToCluster",
        "source": "verify/maven.py::3",
        "target": 4
      },
      {
        "src": "moatless/workspace.py::1",
        "dst": "parser/python.py::1",
        "kind": "ImportFrom",
        "ref": "PythonParser",
        "source": "moatless/workspace.py::1",
        "target": "parser/python.py::1"
      },
      {
        "src": "moatless/workspace.py::1",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "moatless/workspace.py::1",
        "target": 7
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "moatless/workspace.py::2",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "index/settings.py::1",
        "kind": "ImportFrom",
        "ref": "IndexSettings",
        "source": "moatless/workspace.py::2",
        "target": "index/settings.py::1"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "index/code_index.py::2",
        "kind": "ImportFrom",
        "ref": "CodeIndex",
        "source": "moatless/workspace.py::2",
        "target": "index/code_index.py::2"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "index/code_index.py::2",
        "kind": "CallTo",
        "ref": "CodeIndex",
        "source": "moatless/workspace.py::2",
        "target": "index/code_index.py::2"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "index/code_index.py::2",
        "kind": "ImportFrom",
        "ref": "CodeIndex",
        "source": "moatless/workspace.py::2",
        "target": "index/code_index.py::2"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "index/code_index.py::2",
        "kind": "CallTo",
        "ref": "CodeIndex",
        "source": "moatless/workspace.py::2",
        "target": "index/code_index.py::2"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "index/code_index.py::2",
        "kind": "ImportFrom",
        "ref": "CodeIndex",
        "source": "moatless/workspace.py::2",
        "target": "index/code_index.py::2"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "moatless/file_context.py::14",
        "kind": "ImportFrom",
        "ref": "FileContext",
        "source": "moatless/workspace.py::2",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "verify/maven.py::1",
        "kind": "ImportFrom",
        "ref": "MavenVerifier",
        "source": "moatless/workspace.py::2",
        "target": "verify/maven.py::1"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": "verify/lint.py::1",
        "kind": "ImportFrom",
        "ref": "PylintVerifier",
        "source": "moatless/workspace.py::2",
        "target": "verify/lint.py::1"
      },
      {
        "src": "moatless/workspace.py::2",
        "dst": 11,
        "kind": "ChunkToCluster",
        "source": "moatless/workspace.py::2",
        "target": 11
      },
      {
        "src": "moatless/workspace.py::3",
        "dst": "repository/git.py::1",
        "kind": "ImportFrom",
        "ref": "GitRepository",
        "source": "moatless/workspace.py::3",
        "target": "repository/git.py::1"
      },
      {
        "src": "moatless/workspace.py::3",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "moatless/workspace.py::3",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/workspace.py::3",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "moatless/workspace.py::3",
        "target": 5
      },
      {
        "src": "moatless/workspace.py::4",
        "dst": "repository/git.py::1",
        "kind": "CallTo",
        "ref": "GitRepository",
        "source": "moatless/workspace.py::4",
        "target": "repository/git.py::1"
      },
      {
        "src": "moatless/workspace.py::4",
        "dst": "repository/git.py::1",
        "kind": "ImportFrom",
        "ref": "GitRepository",
        "source": "moatless/workspace.py::4",
        "target": "repository/git.py::1"
      },
      {
        "src": "moatless/workspace.py::4",
        "dst": "repository/file.py::5",
        "kind": "ImportFrom",
        "ref": "FileRepository",
        "source": "moatless/workspace.py::4",
        "target": "repository/file.py::5"
      },
      {
        "src": "moatless/workspace.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "CallTo",
        "ref": "FileContext",
        "source": "moatless/workspace.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "moatless/workspace.py::4",
        "dst": "moatless/file_context.py::14",
        "kind": "ImportFrom",
        "ref": "FileContext",
        "source": "moatless/workspace.py::4",
        "target": "moatless/file_context.py::14"
      },
      {
        "src": "moatless/workspace.py::4",
        "dst": "index/code_index.py::2",
        "kind": "ImportFrom",
        "ref": "CodeIndex",
        "source": "moatless/workspace.py::4",
        "target": "index/code_index.py::2"
      },
      {
        "src": "moatless/workspace.py::4",
        "dst": 5,
        "kind": "ChunkToCluster",
        "source": "moatless/workspace.py::4",
        "target": 5
      },
      {
        "src": "moatless/workspace.py::5",
        "dst": "repository/file.py::2",
        "kind": "ImportFrom",
        "ref": "CodeFile",
        "source": "moatless/workspace.py::5",
        "target": "repository/file.py::2"
      },
      {
        "src": "moatless/workspace.py::5",
        "dst": 12,
        "kind": "ChunkToCluster",
        "source": "moatless/workspace.py::5",
        "target": 12
      },
      {
        "src": "moatless/workspace.py::5",
        "dst": 7,
        "kind": "ChunkToCluster",
        "source": "moatless/workspace.py::5",
        "target": 7
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 10,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 10,
        "target": 31509
      },
      {
        "src": 9,
        "dst": 4,
        "ref": "Content",
        "src_node": "benchmark/report_v2.py::3",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 9,
        "target": 4
      },
      {
        "src": 9,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::2",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 9,
        "target": 31509
      },
      {
        "src": 9,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::2",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 9,
        "target": 31509
      },
      {
        "src": 14,
        "dst": 17,
        "ref": "get_missing_files",
        "src_node": "swebench/utils.py::3",
        "dst_node": "benchmark/utils.py::6",
        "kind": "ClusterRef",
        "source": 14,
        "target": 17
      },
      {
        "src": 14,
        "dst": 17,
        "ref": "get_missing_files",
        "src_node": "swebench/utils.py::3",
        "dst_node": "benchmark/utils.py::6",
        "kind": "ClusterRef",
        "source": 14,
        "target": 17
      },
      {
        "src": 11,
        "dst": 5,
        "ref": "FileRepository",
        "src_node": "index/code_index.py::2",
        "dst_node": "repository/file.py::5",
        "kind": "ClusterRef",
        "source": 11,
        "target": 5
      },
      {
        "src": 11,
        "dst": 5,
        "ref": "FileRepository",
        "src_node": "moatless/workspace.py::2",
        "dst_node": "repository/file.py::5",
        "kind": "ClusterRef",
        "source": 11,
        "target": 5
      },
      {
        "src": 11,
        "dst": 15,
        "ref": "IndexSettings",
        "src_node": "index/code_index.py::2",
        "dst_node": "index/settings.py::1",
        "kind": "ClusterRef",
        "source": 11,
        "target": 15
      },
      {
        "src": 11,
        "dst": 15,
        "ref": "IndexSettings",
        "src_node": "index/code_index.py::2",
        "dst_node": "index/settings.py::1",
        "kind": "ClusterRef",
        "source": 11,
        "target": 15
      },
      {
        "src": 11,
        "dst": 15,
        "ref": "IndexSettings",
        "src_node": "moatless/workspace.py::2",
        "dst_node": "index/settings.py::1",
        "kind": "ClusterRef",
        "source": 11,
        "target": 15
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/code_index.py::16",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/code_index.py::16",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/code_index.py::16",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/code_index.py::16",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::4",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::4",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::4",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::4",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "PathTree",
        "src_node": "index/epic_split.py::6",
        "dst_node": "codeblocks/codeblocks.py::4",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "PathTree",
        "src_node": "index/epic_split.py::6",
        "dst_node": "codeblocks/codeblocks.py::4",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::6",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::6",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "PathTree",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::4",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "PathTree",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::4",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "moatless/file_context.py::4",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "SpanMarker",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "SpanMarker",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 11,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "moatless/file_context.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11,
        "target": 2
      },
      {
        "src": 12,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "codeblocks/module.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 12,
        "target": 2
      },
      {
        "src": 12,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "codeblocks/module.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 12,
        "target": 2
      },
      {
        "src": 12,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "codeblocks/module.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 12,
        "target": 2
      },
      {
        "src": 12,
        "dst": 2,
        "ref": "BlockSpan",
        "src_node": "edit/clarify.py::5",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 12,
        "target": 2
      },
      {
        "src": 8,
        "dst": 5,
        "ref": "FileRepository",
        "src_node": "benchmark/utils.py::3",
        "dst_node": "repository/file.py::5",
        "kind": "ClusterRef",
        "source": 8,
        "target": 5
      },
      {
        "src": 8,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/clarify.py::3",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 8,
        "target": 2
      },
      {
        "src": 8,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/code_index.py::12",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 8,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::2",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/python.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/python.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/python.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/python.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/python.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/python.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "codeblocks/module.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "codeblocks/module.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "codeblocks/module.py::1",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 7,
        "dst": 2,
        "ref": "BlockSpan",
        "src_node": "edit/clarify.py::5",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 7,
        "target": 2
      },
      {
        "src": 2,
        "dst": 6,
        "ref": "ReferenceScope",
        "src_node": "parser/python.py::2",
        "dst_node": "codeblocks/codeblocks.py::6",
        "kind": "ClusterRef",
        "source": 2,
        "target": 6
      },
      {
        "src": 2,
        "dst": 6,
        "ref": "ReferenceScope",
        "src_node": "parser/python.py::2",
        "dst_node": "codeblocks/codeblocks.py::6",
        "kind": "ClusterRef",
        "source": 2,
        "target": 6
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/transitions.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 2,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/transitions.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 2,
        "target": 31509
      },
      {
        "src": 6,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::11",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 6,
        "target": 2
      },
      {
        "src": 6,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::11",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 6,
        "target": 2
      },
      {
        "src": 6,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::11",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 6,
        "target": 2
      },
      {
        "src": 6,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::11",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 6,
        "target": 2
      },
      {
        "src": 19,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/clarify.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 19,
        "target": 2
      },
      {
        "src": 19,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/clarify.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 19,
        "target": 2
      },
      {
        "src": 19,
        "dst": 4,
        "ref": "Message",
        "src_node": "edit/clarify.py::6",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 19,
        "target": 4
      },
      {
        "src": 3,
        "dst": 4,
        "ref": "Content",
        "src_node": "edit/edit.py::3",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 3,
        "target": 4
      },
      {
        "src": 3,
        "dst": 4,
        "ref": "AssistantMessage",
        "src_node": "edit/edit.py::3",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 3,
        "target": 4
      },
      {
        "src": 3,
        "dst": 4,
        "ref": "Content",
        "src_node": "edit/edit.py::4",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 3,
        "target": 4
      },
      {
        "src": 3,
        "dst": 4,
        "ref": "VerificationError",
        "src_node": "edit/edit.py::4",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 3,
        "target": 4
      },
      {
        "src": 3,
        "dst": 4,
        "ref": "VerificationError",
        "src_node": "edit/edit.py::4",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 3,
        "target": 4
      },
      {
        "src": 3,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "edit/plan.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 3,
        "target": 2
      },
      {
        "src": 3,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/plan_lines.py::4",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 3,
        "target": 2
      },
      {
        "src": 3,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/plan_lines.py::4",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 3,
        "target": 2
      },
      {
        "src": 3,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/plan_lines.py::4",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 3,
        "target": 2
      },
      {
        "src": 3,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/plan_lines.py::4",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 3,
        "target": 2
      },
      {
        "src": 3,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "edit/review.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 3,
        "target": 2
      },
      {
        "src": 3,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "edit/review.py::6",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 3,
        "target": 2
      },
      {
        "src": 3,
        "dst": 19,
        "ref": "count_tokens",
        "src_node": "edit/plan_lines.py::4",
        "dst_node": "utils/tokenizer.py::1",
        "kind": "ClusterRef",
        "source": 3,
        "target": 19
      },
      {
        "src": 3,
        "dst": 19,
        "ref": "count_tokens",
        "src_node": "edit/plan_lines.py::4",
        "dst_node": "utils/tokenizer.py::1",
        "kind": "ClusterRef",
        "source": 3,
        "target": 19
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "moatless/state.py::4",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "FileWithSpans",
        "src_node": "benchmark/utils.py::3",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "FileWithSpans",
        "src_node": "benchmark/utils.py::3",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/clarify.py::1",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/clarify.py::1",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "FileWithSpans",
        "src_node": "edit/clarify.py::3",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/edit.py::1",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/edit.py::1",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/plan.py::2",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/plan_lines.py::2",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/review.py::1",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/review.py::1",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/review.py::2",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "edit/review.py::3",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "find/decide.py::2",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "find/identify.py::1",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "find/search.py::5",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "FileWithSpans",
        "src_node": "index/code_index.py::12",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "FileWithSpans",
        "src_node": "index/code_index.py::12",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "moatless/loop.py::10",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 8
      },
      {
        "src": 4,
        "dst": 18,
        "ref": "get_state_class",
        "src_node": "moatless/trajectory.py::3",
        "dst_node": "moatless/state.py::6",
        "kind": "ClusterRef",
        "source": 4,
        "target": 18
      },
      {
        "src": 4,
        "dst": 18,
        "ref": "get_state_class",
        "src_node": "moatless/trajectory.py::3",
        "dst_node": "moatless/state.py::6",
        "kind": "ClusterRef",
        "source": 4,
        "target": 18
      },
      {
        "src": 4,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "moatless/trajectory.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 4,
        "target": 3
      },
      {
        "src": 4,
        "dst": 5,
        "ref": "FileRepository",
        "src_node": "benchmark/utils.py::3",
        "dst_node": "repository/file.py::5",
        "kind": "ClusterRef",
        "source": 4,
        "target": 5
      },
      {
        "src": 4,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/clarify.py::3",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 4,
        "target": 2
      },
      {
        "src": 4,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/code_index.py::12",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 4,
        "target": 2
      },
      {
        "src": 20,
        "dst": 15,
        "ref": "IndexSettings",
        "src_node": "index/code_index.py::1",
        "dst_node": "index/settings.py::1",
        "kind": "ClusterRef",
        "source": 20,
        "target": 15
      },
      {
        "src": 20,
        "dst": 5,
        "ref": "FileRepository",
        "src_node": "index/code_index.py::3",
        "dst_node": "repository/file.py::5",
        "kind": "ClusterRef",
        "source": 20,
        "target": 5
      },
      {
        "src": 15,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::2",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 15,
        "target": 2
      },
      {
        "src": 15,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "index/epic_split.py::5",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 15,
        "target": 2
      },
      {
        "src": 15,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::5",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 15,
        "target": 2
      },
      {
        "src": 15,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "index/epic_split.py::5",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 15,
        "target": 2
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 5693,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "benchmark/claude_evaluation.py::8",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 5693,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 2,
        "ref": "BlockSpan",
        "src_node": "edit/clarify.py::2",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 2
      },
      {
        "src": 97236,
        "dst": 2,
        "ref": "BlockSpan",
        "src_node": "edit/clarify.py::2",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 2
      },
      {
        "src": 97236,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/clarify.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 2
      },
      {
        "src": 97236,
        "dst": 2,
        "ref": "CodeBlockTypeGroup",
        "src_node": "edit/clarify.py::6",
        "dst_node": "codeblocks/codeblocks.py::1",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 2
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/plan_lines.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/plan_lines.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/plan_lines.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/plan_lines.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/plan_lines.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/plan_lines.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/plan_lines.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "edit/review.py::4",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 3
      },
      {
        "src": 97236,
        "dst": 4,
        "ref": "Response",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 4
      },
      {
        "src": 97236,
        "dst": 4,
        "ref": "Response",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 4
      },
      {
        "src": 97236,
        "dst": 4,
        "ref": "Message",
        "src_node": "edit/clarify.py::6",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 4
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "NoopState",
        "src_node": "moatless/loop.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 31509,
        "ref": "NoopState",
        "src_node": "moatless/loop.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 31509
      },
      {
        "src": 97236,
        "dst": 19,
        "ref": "count_tokens",
        "src_node": "edit/clarify.py::6",
        "dst_node": "utils/tokenizer.py::1",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 19
      },
      {
        "src": 97236,
        "dst": 19,
        "ref": "count_tokens",
        "src_node": "edit/clarify.py::6",
        "dst_node": "utils/tokenizer.py::1",
        "kind": "ClusterRef",
        "source": 97236,
        "target": 19
      },
      {
        "src": 77036,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "find/decide.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 77036,
        "target": 3
      },
      {
        "src": 77036,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "find/decide.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 77036,
        "target": 3
      },
      {
        "src": 77036,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "find/decide.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 77036,
        "target": 3
      },
      {
        "src": 77036,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "find/decide.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 77036,
        "target": 3
      },
      {
        "src": 77036,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "find/decide.py::3",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 77036,
        "target": 3
      },
      {
        "src": 57098,
        "dst": 4,
        "ref": "Response",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 4
      },
      {
        "src": 57098,
        "dst": 4,
        "ref": "Response",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 4
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/loop.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/loop.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "NoopState",
        "src_node": "moatless/loop.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 57098,
        "dst": 31509,
        "ref": "NoopState",
        "src_node": "moatless/loop.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 57098,
        "target": 31509
      },
      {
        "src": 31509,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "moatless/state.py::2",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 8
      },
      {
        "src": 31509,
        "dst": 8,
        "ref": "ActionRequest",
        "src_node": "moatless/state.py::2",
        "dst_node": "moatless/types.py::1",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 8
      },
      {
        "src": 31509,
        "dst": 4,
        "ref": "Usage",
        "src_node": "moatless/state.py::2",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 4
      },
      {
        "src": 31509,
        "dst": 4,
        "ref": "Usage",
        "src_node": "moatless/state.py::2",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 4
      },
      {
        "src": 31509,
        "dst": 4,
        "ref": "ActionTransaction",
        "src_node": "moatless/state.py::2",
        "dst_node": "moatless/types.py::3",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 4
      },
      {
        "src": 31509,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "moatless/state.py::2",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 3
      },
      {
        "src": 31509,
        "dst": 3,
        "ref": "ActionResponse",
        "src_node": "moatless/state.py::2",
        "dst_node": "moatless/types.py::2",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 3
      },
      {
        "src": 31509,
        "dst": 18,
        "ref": "get_state_class",
        "src_node": "moatless/transition_rules.py::1",
        "dst_node": "moatless/state.py::6",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 18
      },
      {
        "src": 31509,
        "dst": 18,
        "ref": "get_state_class",
        "src_node": "moatless/transition_rules.py::1",
        "dst_node": "moatless/state.py::6",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 18
      },
      {
        "src": 31509,
        "dst": 18,
        "ref": "get_state_class",
        "src_node": "moatless/transition_rules.py::1",
        "dst_node": "moatless/state.py::6",
        "kind": "ClusterRef",
        "source": 31509,
        "target": 18
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::1",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::3",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Rejected",
        "src_node": "moatless/transitions.py::4",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::5",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Finished",
        "src_node": "moatless/transitions.py::6",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/transitions.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 31509,
        "ref": "Pending",
        "src_node": "moatless/transitions.py::7",
        "dst_node": "moatless/state.py::5",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 31509
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::1",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::4",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::4",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "BlockSpan",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "BlockSpan",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "SpanType",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::5",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::6",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::6",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "BlockSpan",
        "src_node": "parser/parser.py::6",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::7",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::10",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlockType",
        "src_node": "parser/parser.py::10",
        "dst_node": "codeblocks/codeblocks.py::2",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "Parameter",
        "src_node": "parser/parser.py::12",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "Parameter",
        "src_node": "parser/parser.py::12",
        "dst_node": "codeblocks/codeblocks.py::8",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::13",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      },
      {
        "src": 11371,
        "dst": 2,
        "ref": "CodeBlock",
        "src_node": "parser/parser.py::13",
        "dst_node": "codeblocks/codeblocks.py::9",
        "kind": "ClusterRef",
        "source": 11371,
        "target": 2
      }
    ]
  }
}