Cluster Graph-based Code Clustering and Management
Summary: This feature manages code chunk clustering using graph structures, leveraging algorithms like Infomap for clustering operations. It defines classes and methods for creating, manipulating, and summarizing clusters of code chunks, and includes utilities for splitting, regrouping, and summarizing clusters, as well as handling graph nodes and edges for both chunks and clusters.
  Chunk: types/clustering.py::1
  Chunk: chunk_resolution/chunk_graph.py::8
  Chunk: chunk_resolution/graph.py::2
  Chunk: cluster/cluster_graph.py::4
  Chunk: cluster/cluster_graph.py::5
  Chunk: cluster/cluster_graph.py::6
  Chunk: cluster/cluster_graph.py::7
  Chunk: cluster/cluster_graph.py::8
  Chunk: cluster/cluster_graph.py::9
  Chunk: cluster/cluster_graph.py::11
  Chunk: cluster/graph.py::1
  Chunk: cluster/graph.py::2
  Chunk: cluster/graph.py::4
  Chunk: cluster/infomap.py::1
  Chunk: lmp/graph_ops.py::2
  Chunk: lmp/split_cluster.py::1
  Chunk: lmp/walkthrough.py::3
  Chunk: cluster/path.py::1
  Chunk: rtfs/graph.py::1
  Chunk: rtfs/graph.py::2
  Chunk: repo_resolution/graph.py::1
  Chunk: chunkers/python.py::4
  Chunk: src/models.py::3

Cluster Feature Flag Management
Summary: This feature is designed to manage feature flags within the application, allowing for dynamic enabling and disabling of features. It ensures that features can be tested and deployed incrementally without affecting the entire user base.

Cluster Code Parsing and Node Splitting System
Summary: This collection of code chunks is responsible for parsing code files, identifying their language, and splitting them into manageable nodes or code blocks. It includes support for Python and Java, utilizing specific parsers and leveraging tree-sitter for syntax tree parsing, and provides functionality for handling code spans and generating structured outputs.
  Chunk: moatless/__init__.py::1
  Chunk: codeblocks/__init__.py::1
  Chunk: parser/create.py::1
  Chunk: parser/java.py::1
  Chunk: parser/parser.py::2
  Chunk: parser/python.py::1
  Chunk: moatless/file_context.py::2
  Chunk: index/epic_split.py::3
  Chunk: moatless/repository.py::2
  Chunk: moatless/workspace.py::1
  Chunk: moatless/epic_split.py::3

Cluster Codebase Evaluation and Reporting System
Summary: This cluster of code chunks is responsible for generating evaluation reports and summaries for a codebase, tracking resolved tasks, and managing code clusters, particularly using markdown for documentation. It encompasses functions for creating detailed markdown reports, handling file spans, managing code context, and processing task queues, alongside utilities for setting up and managing a workspace and indexing code structures.
  Chunk: main.py::1
  Chunk: benchmark/create_dataset.py::2
  Chunk: benchmark/evaluation.py::13
  Chunk: swebench/utils.py::4
  Chunk: benchmark/utils.py::4
  Chunk: codeblocks/codeblocks.py::1
  Chunk: codeblocks/codeblocks.py::2
  Chunk: codeblocks/codeblocks.py::4
  Chunk: codeblocks/codeblocks.py::8
  Chunk: codeblocks/codeblocks.py::9
  Chunk: parser/parser.py::1
  Chunk: parser/parser.py::4
  Chunk: parser/parser.py::5
  Chunk: parser/parser.py::7
  Chunk: parser/parser.py::10
  Chunk: parser/parser.py::12
  Chunk: parser/parser.py::13
  Chunk: parser/parser.py::14
  Chunk: parser/parser.py::15
  Chunk: parser/parser.py::16
  Chunk: parser/parser.py::17
  Chunk: parser/python.py::2
  Chunk: edit/clarify.py::7
  Chunk: moatless/file_context.py::3
  Chunk: moatless/file_context.py::5
  Chunk: moatless/file_context.py::11
  Chunk: moatless/file_context.py::13
  Chunk: index/code_index.py::2
  Chunk: index/code_index.py::21
  Chunk: index/embed_model.py::1
  Chunk: index/epic_split.py::1
  Chunk: index/epic_split.py::4
  Chunk: moatless/repository.py::4
  Chunk: moatless/repository.py::5
  Chunk: moatless/workspace.py::2
  Chunk: moatless/workspace.py::3
  Chunk: moatless/epic_split.py::1
  Chunk: moatless/epic_split.py::4
  Chunk: moatless/module.py::1
  Chunk: lmp/walkthrough.py::5
  Chunk: chunkers/python.py::3
  Chunk: code/search.py::3
  Chunk: code/search.py::4
  Chunk: code/search.py::5
  Chunk: src/exceptions.py::1
  Chunk: middleware/db.py::1
  Chunk: middleware/exception.py::1
  Chunk: middleware/task_queue.py::1
  Chunk: queue/core.py::1
  Chunk: queue/service.py::1
  Chunk: repo/views.py::2
  Chunk: search/search.py::3
  Chunk: search/search.py::4
  Chunk: search/search.py::5

Cluster Agentic Code Evaluation and Transition System
Summary: This code cluster implements a framework for evaluating, editing, planning, identifying, and searching code using an agentic state-based system. It defines various classes and transitions to manage different states and actions in a loop, facilitating automated code changes based on specified instructions and conditions. The system supports file context expansion, decision-making on code relevance, and structured transitions between states to achieve specific coding objectives.
  Chunk: benchmark/evaluation.py::2
  Chunk: edit/clarify.py::1
  Chunk: edit/clarify.py::2
  Chunk: edit/edit.py::1
  Chunk: edit/edit.py::2
  Chunk: edit/edit.py::6
  Chunk: edit/plan.py::2
  Chunk: edit/plan.py::3
  Chunk: edit/plan.py::8
  Chunk: edit/plan_lines.py::2
  Chunk: edit/plan_lines.py::3
  Chunk: edit/plan_lines.py::8
  Chunk: find/decide.py::2
  Chunk: find/decide.py::3
  Chunk: find/identify.py::1
  Chunk: find/identify.py::2
  Chunk: find/identify.py::4
  Chunk: find/search.py::4
  Chunk: find/search.py::5
  Chunk: find/search.py::8
  Chunk: find/search_v2.py::5
  Chunk: find/search_v2.py::6
  Chunk: find/search_v2.py::9
  Chunk: moatless/loop.py::1
  Chunk: moatless/loop.py::2
  Chunk: moatless/loop.py::3
  Chunk: moatless/loop.py::6
  Chunk: moatless/loop.py::7
  Chunk: moatless/loop.py::9
  Chunk: moatless/loop.py::10
  Chunk: moatless/loop.py::11
  Chunk: moatless/state.py::1
  Chunk: moatless/state.py::2
  Chunk: moatless/trajectory.py::1
  Chunk: moatless/trajectory.py::3
  Chunk: moatless/trajectory.py::4
  Chunk: moatless/transitions.py::1
  Chunk: moatless/transitions.py::2
  Chunk: moatless/transitions.py::3
  Chunk: moatless/transitions.py::4
  Chunk: moatless/transitions.py::5
  Chunk: moatless/transitions.py::6
  Chunk: moatless/transitions.py::7
  Chunk: moatless/types.py::2

Cluster Automated Evaluation and Cost Tracking System
Summary: This code cluster implements a system for evaluating problem-solving instances using an agentic loop framework. It handles instance setup, tracks evaluation metadata, manages cost tracking, and logs evaluation trajectories, facilitating automated benchmarking and performance assessment in a controlled environment.
  Chunk: benchmark/evaluation.py::5
  Chunk: benchmark/utils.py::8
  Chunk: moatless/loop.py::4

Cluster Code Evaluation and Span Verification Framework
Summary: This set of code chunks provides a framework for evaluating code transitions and verifying identified code spans within a given trajectory. It includes methods for converting evaluation instances into results, checking for missing and alternative spans, and syncing file contexts with search trajectories. The framework aims to assess various transition actions such as searching, identifying, planning, and editing code, to ensure successful code span identification and verification.
  Chunk: benchmark/evaluation.py::11
  Chunk: swebench/utils.py::2
  Chunk: swebench/utils.py::3
  Chunk: benchmark/utils.py::5
  Chunk: benchmark/utils.py::6

Cluster Repository Setup and Workspace Initialization
Summary: These code snippets are responsible for setting up a GitHub repository locally and creating a workspace for it. The code handles the cloning of a specified repository at a given commit and organizes the necessary directories for future operations.
  Chunk: swebench/utils.py::5
  Chunk: utils/repo.py::1

Cluster Span Identification and Token Summation in Code Modules
Summary: This cluster of code provides functionality to identify relevant code spans within modules and calculate the token count of these spans. It includes methods for comparing original and updated code blocks to determine changes and dependencies, utilizing a graph-based approach for span management.
  Chunk: benchmark/utils.py::1
  Chunk: codeblocks/module.py::1

Cluster Code Context and Change Analysis
Summary: The code clusters work together to analyze and manage code changes and contexts. They provide utilities for comparing code patches, creating file spans, clarifying code changes in context, indexing code for search hits, and defining data structures to handle file paths and code spans.
  Chunk: benchmark/utils.py::3
  Chunk: edit/clarify.py::3
  Chunk: index/code_index.py::15
  Chunk: moatless/types.py::1

Cluster Epic Splitter: Code Block Parsing and Chunking
Summary: The Epic Splitter feature is responsible for parsing and managing code blocks within a codebase. It creates a hierarchical path tree for organizing code blocks, filters out irrelevant comments, and converts code blocks into context strings. Additionally, it chunks code blocks into manageable pieces based on size constraints, ensuring efficient code processing while preserving logical code structures.
  Chunk: index/epic_split.py::7
  Chunk: moatless/epic_split.py::5
  Chunk: moatless/epic_split.py::7

Cluster Code Relationship and Reference Management
Summary: This cluster of code is responsible for defining and managing relationships and references within the codebase. It includes enumerations for reference scopes and relationship types, a 'Relationship' class to handle path validations and hashing, and a 'CodeParser' class that creates references based on code blocks and their relationships.
  Chunk: codeblocks/codeblocks.py::6
  Chunk: codeblocks/codeblocks.py::7
  Chunk: parser/parser.py::11

Cluster Code Block Tree Representation with Color Highlighting
Summary: This feature defines a `CodeBlock` class that converts code blocks into a tree structure with support for various display options, such as highlighting specific spans and showing identifiers, tokens, and references. It utilizes the `Colors` class for enhancing the visual representation of code blocks by adding colored formatting to differentiate elements like visibility, spans, and content in the generated tree.
  Chunk: codeblocks/codeblocks.py::14
  Chunk: utils/colors.py::1

Cluster Cluster 8: User Authentication Module
Summary: This cluster of code is responsible for managing user authentication processes within the application. It includes functions for user login, logout, and verifying user credentials to ensure secure access to the system.

Cluster Code Change Clarification and Token Counting Utilities
Summary: This feature provides a mechanism to verify and clarify code change requests by checking if specified line numbers are valid and within a permissible token limit, using the 'ClarifyCodeChange' class. Additionally, it includes a utility function to count tokens in a given text, supporting different models and handling tokenization dependencies efficiently.
  Chunk: edit/clarify.py::6
  Chunk: utils/tokenizer.py::1

Cluster Code Editing and Management Workflow
Summary: This code cluster defines a comprehensive system for managing and editing code changes in a structured and automated manner. It includes utility functions for identifying line boundaries, classes for handling actions related to code edits, planning code adjustments, identifying code sections, and generating action responses for transitioning between different states in the editing process.
  Chunk: edit/clarify.py::8
  Chunk: edit/clarify.py::9
  Chunk: edit/edit.py::3
  Chunk: edit/edit.py::4
  Chunk: edit/plan.py::4
  Chunk: edit/plan.py::5
  Chunk: edit/plan.py::6
  Chunk: edit/plan_lines.py::5
  Chunk: edit/plan_lines.py::6
  Chunk: find/identify.py::3
  Chunk: moatless/types.py::3

Cluster Code Search and Span Ranking System
Summary: This code cluster implements a system for searching code files based on various attributes such as file pattern, query, code snippet, class name, and function name. It ranks the found code spans and returns structured responses, supporting versioned search capabilities while handling edge cases like test file searches.
  Chunk: moatless/file_context.py::1
  Chunk: find/search.py::6
  Chunk: find/search_v2.py::7

Cluster File Content Update with Logging and Span Management
Summary: This feature provides the functionality to update the content of a file by specifying line numbers to be replaced, and logs the addition of new spans if applicable. It utilizes a `ContextFile` class that interacts with an `UpdateResult` data structure to track changes and potential errors during the update process, integrating with a logging system for operational transparency.
  Chunk: moatless/file_context.py::10
  Chunk: moatless/repository.py::1

Cluster Cluster Node Management in Code Indexing
Summary: This feature facilitates the creation and management of cluster nodes within a code indexing system. It defines a 'ClusterNode' class inheriting from 'TextNode' and implements a method to transform cluster data dictionaries into hierarchical structures of 'ClusterNode' instances, preserving metadata and relationships.
  Chunk: index/cluster_node.py::1
  Chunk: index/code_index.py::14

Cluster Code Indexing and Splitting System for Efficient Search and Retrieval
Summary: This code cluster implements a comprehensive system for indexing code and non-code documents, allowing efficient search and retrieval. It includes functionalities for downloading and storing code repositories, defining embedding and vector store settings, splitting documents into manageable chunks, and managing comment strategies during indexing.
  Chunk: index/code_index.py::1
  Chunk: index/code_index.py::4
  Chunk: index/epic_split.py::2
  Chunk: index/epic_split.py::5
  Chunk: index/settings.py::1

Cluster Feature Management and Validation
Summary: This code cluster is responsible for managing and validating the features within the codebase. It includes functionality to ensure that features meet certain criteria and are correctly implemented, helping maintain code quality and consistency.

Cluster Advanced Code Search and Indexing System
Summary: This code cluster defines a sophisticated system for searching and indexing code snippets, leveraging vector stores for semantic search capabilities. It includes classes and methods for searching code by name, semantic matching, and managing indexed data, using technologies like FAISS for vector storage and retrieval, and supports operations like persistence and retrieval of code and related metadata.
  Chunk: index/code_index.py::3
  Chunk: index/code_index.py::5
  Chunk: index/code_index.py::6
  Chunk: index/code_index.py::7
  Chunk: index/code_index.py::8
  Chunk: index/code_index.py::9
  Chunk: index/code_index.py::10
  Chunk: index/code_index.py::11
  Chunk: index/code_index.py::12
  Chunk: index/code_index.py::13
  Chunk: index/code_index.py::16
  Chunk: index/code_index.py::23
  Chunk: index/simple_faiss.py::1
  Chunk: index/simple_faiss.py::2
  Chunk: index/types.py::2

Cluster Code Vector and Cluster Search Functionality
Summary: The given code chunks implement a vector search functionality within a 'CodeIndex' class, designed to retrieve relevant code snippets based on a query. The search process leverages vector embeddings to find and rank code snippets either from a code vector store or a cluster vector store, applying filters such as file patterns and excluding test files, and returning results as 'CodeSnippet' objects.
  Chunk: index/code_index.py::17
  Chunk: index/code_index.py::18
  Chunk: index/types.py::1

Cluster Code Node Hashing and Epic Node Creation
Summary: The provided code involves defining a 'CodeNode' class, which extends 'TextNode', and includes a method to compute a hash of the node's content and metadata, excluding specific metadata keys to minimize unnecessary changes. Additionally, an 'EpicSplitter' class is implemented for creating nodes from code blocks, where metadata like line numbers and span IDs are managed, and token counts are calculated to facilitate efficient code parsing and embedding.
  Chunk: index/code_node.py::1
  Chunk: index/epic_split.py::8

Cluster Code Verification and Execution Framework
Summary: This code cluster implements a framework for verifying and executing code, primarily focusing on defining and managing execution loops, handling verification through tools like Pylint and Maven, and managing code responses and errors. It includes classes like 'AgenticLoop' for running execution loops with cost and retry limits, 'Trajectory' for managing execution transitions, and 'Verifier' with concrete implementations like 'PylintVerifier' and 'MavenVerifier' for code verification tasks.
  Chunk: moatless/loop.py::5
  Chunk: moatless/trajectory.py::2
  Chunk: moatless/types.py::4
  Chunk: verify/lint.py::1
  Chunk: verify/maven.py::1
  Chunk: verify/maven.py::2
  Chunk: verify/maven.py::3
  Chunk: verify/verify.py::1

Cluster API Model Integration and Summary Generation
Summary: This code integrates various AI models, including Anthropic and OpenAI, to facilitate the summarization of code nodes. It defines model configurations, handles API interactions, and implements a function to generate summaries using the selected model based on input parameters.
  Chunk: summary/models.py::1
  Chunk: summary/models.py::5
  Chunk: summary/models.py::7
  Chunk: summary/summarize.py::2

Cluster Scope Graph Construction for Python Code Analysis
Summary: This code defines a function, `build_scope_graph`, that constructs a scope graph from source code in Python. It utilizes a language parser to identify various code elements like definitions, references, imports, and calls, capturing their respective text ranges and building a structured graph representation of the code's scope for further analysis.
  Chunk: rtfs/build_scopes.py::2

Cluster Scope Graph Construction for Python Codebases
Summary: The code chunks collectively define a function to construct a scope graph for Python codebases, parsing and organizing various code elements like imports, definitions, references, and calls. The function processes bytecode to capture and categorize these elements into a graph structure, facilitating subsequent scope resolution and code analysis.
  Chunk: new_rtfs/build_scopes.py::3
  Chunk: rtfs/build_scopes.py::3
  Chunk: scope_resolution/imports.py::1

Cluster Import Management and Analysis for Python
Summary: This code provides a framework for managing and analyzing import statements in Python. It includes classes and methods for representing import details, validating them against Python-specific rules, and resolving import paths to absolute paths using a Python-specific implementation.
  Chunk: captures/imports.py::1
  Chunk: language/python.py::1
  Chunk: language/python.py::3
  Chunk: language/python.py::4

Cluster Codebase Graph Construction and Management
Summary: This feature is responsible for constructing and managing graphs representing code relationships within a repository. It includes classes and functions for creating nodes from code chunks, establishing references and dependencies among them, and utilizing machine learning models for enhanced analysis. The feature supports different graph types, facilitates filesystem interactions, and provides mechanisms for persisting graph data.
  Chunk: aider_graph/aider_graph.py::1
  Chunk: chunk_resolution/chunk_graph.py::2
  Chunk: rtfs/chunker.py::2
  Chunk: cluster/cluster_graph.py::2
  Chunk: rtfs/fs.py::1
  Chunk: rtfs/models.py::3
  Chunk: rtfs/models.py::7
  Chunk: repo_resolution/repo_graph.py::2
  Chunk: repo_resolution/repo_graph.py::5
  Chunk: repo/graph.py::2

Cluster Cluster 45: Data Processing and Transformation Module
Summary: This cluster of code focuses on data processing and transformation, providing functions and utilities to clean, filter, and modify datasets for further analysis or machine learning tasks. It streamlines data handling operations, ensuring consistency and efficiency in preparing data for various applications.

Cluster Chunk Graph and Clustering Management
Summary: This code defines and manages the structure and functions for handling code chunks and their clustering. It includes a class for representing a graph of code chunks, methods for chunk retrieval and naming, and functions for generating and organizing clusters of code topics from a repository path.
  Chunk: chunk_resolution/chunk_graph.py::6
  Chunk: chunk/models.py::2
  Chunk: cluster/cluster_v1.py::9

Cluster JSON Tree Traversal and Graph Representation
Summary: This code provides a mechanism to represent clusters as structured strings from JSON data by utilizing depth-first traversal. The 'ChunkGraph' class transforms a JSON tree into a string format, while the 'dfs_json' function traverses JSON tree structures, supporting the hierarchical representation of clusters.
  Chunk: chunk_resolution/chunk_graph.py::9
  Chunk: rtfs/utils.py::1

Cluster ChunkGraph Generation and Management
Summary: This code is responsible for generating and managing a ChunkGraph from a repository path. It includes functionality to categorize files, create a graph representation, summarize clusters, and output results in different formats via a command-line interface.
  Chunk: rtfs/chunker.py::1
  Chunk: rtfs/cli.py::3

Cluster Cluster Path and Import-Export Mapping in Code Graphs
Summary: This code cluster focuses on managing and analyzing paths within clustered code graphs and mapping import-export relationships between code chunks. It includes functionality for finding the longest paths between clusters, managing cluster path segments, and building import-export mappings for code chunks, leveraging graph representations to facilitate code analysis and refactoring.
  Chunk: chunk_resolution/chunk_graph.py::5
  Chunk: cluster/cluster_graph.py::10
  Chunk: cluster/path.py::3
  Chunk: repo_resolution/repo_graph.py::1

Cluster Import Resolution and Namespace Management in Codebase
Summary: This code cluster is responsible for managing and resolving import statements and namespaces in the codebase. It defines classes and functions for handling local import statements, constructing import objects, determining module types (system, third-party, or local), and managing namespaces using both dataclasses and utility functions for path resolution and module checking.
  Chunk: repo_resolution/exports.py::1
  Chunk: repo_resolution/imports.py::2
  Chunk: repo_resolution/imports.py::3
  Chunk: repo_resolution/namespace.py::1
  Chunk: repo_resolution/repo_graph.py::6
  Chunk: scope_resolution/imports.py::2
  Chunk: rtfs/utils.py::4
  Chunk: rtfs/utils.py::5

Cluster Document Splitting and Ingestion Module
Summary: This code defines a class 'EpicSplitter' that is responsible for splitting text documents, including both code and non-code files, into manageable chunks based on specified parameters like chunk size and file extensions. The 'ingest' function utilizes this class to read files from a repository, process them using the 'EpicSplitter', and prepare them for further indexing or analysis.
  Chunk: moatless/epic_split.py::2
  Chunk: moatless/ingest.py::2

Cluster Python Codebase Structure and Authentication Handling
Summary: This code cluster encompasses several modules that handle Python code parsing, user authentication, health checks, and data storage. The 'ts.py' module utilizes the Tree Sitter library for parsing Python code, while 'auth/models.py' defines data models for user authentication and management. 'chunkers/python.py' provides functions for extracting context from code chunks. 'health/views.py' implements a health check endpoint using FastAPI, and 'stores/base.py' outlines an abstract base class for vector storage. Finally, 'src/models.py' contains data models and utility classes for handling timestamps, metadata, and function contexts.
  Chunk: rtfs_rewrite/ts.py::1
  Chunk: auth/models.py::4
  Chunk: chunkers/python.py::2
  Chunk: health/views.py::1
  Chunk: stores/base.py::1
  Chunk: src/models.py::1

Cluster User Authentication and Repository Management
Summary: This code cluster handles user authentication, permission management, and repository operations in a web application. It defines user models, manages user sessions and permissions, and provides endpoints for user registration, login, and repository management, including listing, retrieving, summarizing, and deleting repositories.
  Chunk: auth/models.py::2
  Chunk: auth/permissions.py::1
  Chunk: auth/service.py::1
  Chunk: auth/service.py::3
  Chunk: auth/views.py::1
  Chunk: auth/views.py::2
  Chunk: auth/views.py::3
  Chunk: chat/views.py::2
  Chunk: chat/views.py::3
  Chunk: database/core.py::3
  Chunk: queue/core.py::4
  Chunk: queue/permissions.py::1
  Chunk: queue/views.py::1
  Chunk: queue/views.py::2
  Chunk: repo/service.py::1
  Chunk: repo/service.py::3
  Chunk: repo/views.py::3
  Chunk: repo/views.py::4
  Chunk: repo/views.py::5
  Chunk: repo/views.py::6
  Chunk: repo/views.py::7
  Chunk: search/views.py::2

Cluster Walkthrough Chat Generation and Management
Summary: This code cluster focuses on generating and managing walkthrough chats within a chat application. It includes functions for creating walkthrough chats from model transitions, defining data structures to manage chat metadata, and ensuring the integrity of chat data through validation mechanisms. The code uses classes and methods to define chat message types, handle data validation, and ensure proper chat transitions and metadata management.
  Chunk: lmp/walkthrough.py::7
  Chunk: chat/models.py::2
  Chunk: chat/models.py::3
  Chunk: chat/models.py::4
  Chunk: repo/models.py::4

Cluster Code Clustering and Evaluation Framework
Summary: This collection of code chunks provides a comprehensive framework for clustering code snippets into cohesive topics and evaluating their coherence within a codebase. It includes functions to convert raw clusters into structured topics, generate clusters using language models, evaluate cluster coherence on a scale, and calculate perplexity scores for model predictions, facilitating both the organization and assessment of code clustering methodologies.
  Chunk: chunk/adapter.py::1
  Chunk: lmp/cluster_v4.py::5
  Chunk: cluster/models.py::1
  Chunk: evals/eval_cluster.py::2
  Chunk: evals/eval_compare.py::1
  Chunk: lmps/eval_coherence.py::1
  Chunk: lmps/eval_coherence.py::2
  Chunk: lmp_base/logprobs.py::1
  Chunk: lmp_base/logprobs.py::2

Cluster Codebase Chunking and Summarization System
Summary: This feature implements a system for chunking code repositories into manageable segments and generating summaries for these chunks. It includes classes and functions for defining chunking strategies, creating and managing code indices, defining tasks and their statuses, and summarizing the content to provide insights and statistics on the codebase.
  Chunk: chunk/chunk.py::2
  Chunk: chunk/summarizer.py::1
  Chunk: index/service.py::1
  Chunk: queue/models.py::1
  Chunk: repo/graph.py::3
  Chunk: repo/tasks.py::1

Cluster Automated Code Clustering and Summarization Framework
Summary: This code defines a framework for creating and managing clusters of code chunks from a larger codebase. It includes functionality for generating, summarizing, and evaluating clusters using various strategies, such as full code, random sampling, and summarization. The framework utilizes multithreading for efficient processing and leverages language models to generate summaries and identify irrelevant code chunks.
  Chunk: chunk/chunk.py::5
  Chunk: lmp/sum_chunks.py::1
  Chunk: cluster/cluster_v1.py::2
  Chunk: cluster/cluster_v1.py::7
  Chunk: cluster/cluster_v1.py::8
  Chunk: cluster/cluster_v1.py::10
  Chunk: lmp/remove_chunks.py::1
  Chunk: evals/eval_cluster.py::5
  Chunk: llm/invoke_mt.py::1
  Chunk: src/utils.py::1

Cluster Configuration and Language Support for Code Chunkers
Summary: This code defines a configuration setup for a software project, including environment variables, API keys, database connections, and directories for code search functionalities. It also specifies language support for chunkers, currently supporting Python, through an enumeration class and a dictionary mapping.
  Chunk: chunkers/__init__.py::1
  Chunk: src/config.py::1

Cluster File Classification and Directory Tree Management
Summary: This code cluster is responsible for classifying files within a directory based on predefined categories. It includes generating a visual representation of the directory structure, filtering out excluded files, and iteratively classifying the remaining files using a language model. The system updates its state to manage the classification process and handles permission errors gracefully during tree generation.
  Chunk: chunk/classify_files.py::1
  Chunk: lmp/classify_tree.py::1
  Chunk: tree/tree.py::2

Cluster Code Summarization and Metadata Management
Summary: The code primarily focuses on generating detailed code summaries and managing metadata for code chunks. It defines a process that utilizes a language model to convert raw summaries into structured descriptions, and it uses data classes to facilitate the handling and conversion of metadata related to code chunks.
  Chunk: lmp/summarize.py::2
  Chunk: src/models.py::2

Cluster Code Chunk Clustering and Enrichment System
Summary: This feature provides an abstraction for handling code chunks, defining a structure for input processing and clustering. It includes a mechanism to generate clusters from a list of code chunks using specified operations and allows for additional enrichment procedures on the clustered data.
  Chunk: chunk/models.py::1
  Chunk: cluster/cluster.py::2

Cluster Enhanced Multi-Step Clustering with LLM
Summary: This feature implements a series of functions for multi-step clustering using a language model, enhancing the ability to generate clusters from input data with various levels of structure. Different versions of the clustering function are provided, each improving on the previous by introducing capabilities such as identifying specific data structures and logic types, tracking unique and total clustered chunks, and calculating session costs to optimize clustering performance.
  Chunk: cluster/cluster_v1.py::4
  Chunk: cluster/cluster_v1.py::5
  Chunk: cluster/cluster_v1.py::6
  Chunk: lmp/cluster_v4.py::1
  Chunk: llm/utils.py::4

Cluster Repository and User Interaction Management
Summary: This feature manages the configuration and interactions of repositories within the codebase. It defines a SQLAlchemy model for repositories, capturing metadata like owner, size, and file paths, and facilitates user-repo relationships, while also providing a script for querying repositories associated with a specific user by email.
  Chunk: repo/models.py::1
  Chunk: scripts/get_users.py::1

Cluster Git Repository Management and Database Table Operations
Summary: This code cluster manages Git repository operations, including cloning and deleting repositories using the 'GitRepo' class, and provides a command-line interface for database table operations, specifically for dropping tables and cleaning up associated Git repositories. The functionality is integrated with SQLAlchemy for database interactions and uses Click for command-line command definitions.
  Chunk: repo/repository.py::3
  Chunk: scripts/drop_tables.py::1

Cluster Repository Deletion and Cleanup
Summary: This code handles the deletion of a repository from a database and the associated file system cleanup. The `delete` function in `repo/service.py` removes a repository from the database and deletes its files if it's the last user. The `rm_tree` function in `src/utils.py` ensures cross-platform deletion of files and directories, handling retries for Windows systems.
  Chunk: repo/service.py::2
  Chunk: src/utils.py::3

Cluster Scope Graph Construction and Management
Summary: This code cluster is responsible for constructing and managing a 'Scope Graph' within a codebase, which involves parsing source code to identify scopes, definitions, imports, and references. It provides mechanisms to insert and manage these elements in a hierarchical graph structure, thereby facilitating efficient scope resolution and reference management across different parts of the code.
  Chunk: new_rtfs/build_scopes.py::2
  Chunk: scope_graph/graph.py::2
  Chunk: scope_graph/graph.py::3
  Chunk: scope_graph/graph.py::4
  Chunk: scope_graph/graph.py::5
  Chunk: scope_graph/graph.py::6
  Chunk: scope_graph/graph.py::7
  Chunk: scope_graph/graph.py::8
  Chunk: scope_graph/graph.py::9

Cluster Scope Graph Management and Representation
Summary: These code chunks define the 'ScopeGraph' class, which is responsible for managing and representing scope-related information within a codebase. It provides methods to retrieve and manipulate scopes, imports, definitions, references, and their relationships, as well as a function to output a string representation of the graph's structure.
  Chunk: scope_graph/graph.py::10
  Chunk: scope_graph/graph.py::11

Cluster Scope Resolution and Interval Management in Abstract Syntax Trees
Summary: This feature defines classes and methods for managing nodes and edges within an abstract syntax tree (AST) using scope resolution and interval trees. It includes definitions of node and edge kinds for different code elements, a ScopeNode class representing nodes with various properties, and an IntervalGraph class that manages scope intervals using an interval tree to efficiently check for overlapping and contained scopes.
  Chunk: scope_resolution/graph_types.py::1
  Chunk: scope_resolution/interval_tree.py::1

Cluster Symbol Reference and Definition Management
Summary: This cluster of code implements classes and functions for managing symbol references and definitions within a source code, specifically capturing their text ranges and identifiers. It includes the creation of 'Reference' and 'LocalDef' objects, as well as a function to extract such references from source code using language-specific parsers.
  Chunk: scope_resolution/capture_refs.py::1
  Chunk: scope_resolution/definition.py::1
  Chunk: scope_resolution/reference.py::1

Cluster Scope Graph Management for Code Resolution
Summary: This code implements a system for managing and resolving scopes, definitions, imports, references, and calls within a codebase using a directed graph structure (ScopeGraph). It allows for the organization and hierarchical representation of code elements, facilitating efficient scope resolution and referencing by maintaining relationships between nodes such as definitions, imports, and references.
  Chunk: scope_resolution/scope.py::1
  Chunk: scope_resolution/scope_graph.py::2
  Chunk: scope_resolution/scope_graph.py::3
  Chunk: scope_resolution/scope_graph.py::4
  Chunk: scope_resolution/scope_graph.py::5
  Chunk: scope_resolution/scope_graph.py::6
  Chunk: scope_resolution/scope_graph.py::7
  Chunk: scope_resolution/scope_graph.py::8
  Chunk: scope_resolution/scope_graph.py::9
  Chunk: scope_resolution/scope_graph.py::10
  Chunk: scope_resolution/scope_graph.py::11

Cluster Scope and Repository Graph Testing Suite
Summary: This code snippet is part of a testing suite designed to evaluate the functionality of scope graph and repository graph construction in Python. It utilizes the 'build_scope_graph' function to create a scope graph from a Python code string and potentially checks for missing imports in a repository graph, highlighting areas where the code may fail.
  Chunk: tests/simple_test.py::1

Cluster Local Code Element Captures and Import Part Types
Summary: This cluster defines several dataclasses to capture various local code elements such as function calls, definitions, and references within a codebase. It also includes an enumeration to categorize different types of import parts, facilitating structured representation and handling of these elements in the code.
  Chunk: ts/capture_types.py::1

Cluster TextRange Class for Text Span Manipulation
Summary: The TextRange class defines a data structure for representing a span within a text file, marked by byte offsets and point coordinates. It includes validation for its attributes, methods for adjusting the range through offsets, and comparison functionality to determine if one range contains another or overlaps in terms of line numbers.
  Chunk: rtfs/utils.py::2

Cluster Export Extraction from Scope Graph
Summary: This code defines a method within the RepoGraph class that extracts exportable definitions (classes and functions) from a given scope graph, ignoring non-class/function definitions at the root scope, and returns them as a list of tuples containing their names and scope identifiers.
  Chunk: repo_resolution/repo_graph.py::7

Cluster LocalCall Class Definition and Node Representation
Summary: This code defines a data class named LocalCall, which represents a function call with attributes for its text range, name, and parameters. It provides an initialization method and a to_node method that converts the object into a dictionary format suitable for node representation.
  Chunk: scope_resolution/call.py::1

