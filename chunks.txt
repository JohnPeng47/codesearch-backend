Chunk ID: llm_code_generator\main.py::2
Filepath: llm_code_generator\main.py
Content:
#!/usr/bin/env python3

from src.cli import CLI
from src.logger import setup_logger
from src.config_validator import ConfigValidator
from src.template_engine import TemplateEngine
from src.project_structure_generator import ProjectStructureGenerator
from src.error_handler import ConfigurationError, LLMAPIError, CodeGenerationError

logger = setup_logger()

def main():
    try:
        cli = CLI()
        args = cli.parse_args()

        config = cli.load_config(args.config)
        ConfigValidator.validate_config(config)

        template_engine = TemplateEngine('templates')
        project_structure_generator = ProjectStructureGenerator(config, template_engine)

        repo = cli.initialize_repository(config)
        project_structure_generator.generate_structure(repo.output_path)

        cli.run_generation_process(repo, args)

        logger.info(f"Repository generated successfully at {config.output_path}/{config.repo_name}")

    except ConfigurationError as e:
        logger.error(f"Configuration error: {str(e)}")
    except LLMAPIError as e:
        logger.error(f"LLM API error: {str(e)}")
    except CodeGenerationError as e:
        logger.error(f"Code generation error: {str(e)}")
    except Exception as e:
        logger.exception("An unexpected error occurred")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
Chunk ID: src\cicd_generator.py::1
Filepath: llm_code_generator\src\cicd_generator.py
Content:
import os
import yaml

class CICDGenerator:
    def __init__(self, config):
        self.config = config

    def generate_config(self, repo):
        github_actions_config = self._generate_github_actions_config()

        github_dir = os.path.join(self.config.output_path, repo.name, ".github", "workflows")
        os.makedirs(github_dir, exist_ok=True)

        with open(os.path.join(github_dir, "main.yml"), "w") as f:
            yaml.dump(github_actions_config, f)

    def _generate_github_actions_config(self):
        return {
            "name": "CI/CD",
            "on": ["push", "pull_request"],
            "jobs": {
                "test": {
                    "runs-on": "ubuntu-latest",
                    "steps": [
                        {"uses": "actions/checkout@v2"},
                        {"name": "Set up Python", "uses": "actions/setup-python@v2", "with": {"python-version": "3.9"}},
                        {"name": "Install dependencies", "run": "pip install -r requirements.txt"},
                        {"name": "Run tests", "run": "pytest"},
                        {"name": "Run linter", "run": "pylint **/*.py"},
                        {"name": "Run type checker", "run": "mypy ."}
                    ]
                }
            }
        }
--------------------------------------------------------------------------------
Chunk ID: src\cli.py::1
Filepath: llm_code_generator\src\cli.py
Content:
import argparse
import logging
from .configuration import Configuration
from .repository import Repository
from .llm_provider import OpenAIProvider
from .metrics_collector import MetricsCollector
from .pytest_runner import PyTestRunner
from .dependency_manager import DependencyManager
from .documentation_generator import DocumentationGenerator
from .code_analyzer import CodeAnalyzer
from .cicd_generator import CICDGenerator

class CLI:
    def __init__(self):
        self.parser = argparse.ArgumentParser(description="LLM Code Generator")
        self.setup_arguments()

    def setup_arguments(self):
        self.parser.add_argument("--config", type=str, help="Path to configuration file")
        self.parser.add_argument("--analyze", action="store_true", help="Run code analysis after generation")
        self.parser.add_argument("--docs", action="store_true", help="Generate documentation")
        self.parser.add_argument("--cicd", action="store_true", help="Generate CI/CD configuration")
--------------------------------------------------------------------------------
Chunk ID: src\cli.py::2
Filepath: llm_code_generator\src\cli.py
Content:
class CLI:

    def run(self):
        args = self.parser.parse_args()
        config = Configuration(args.config)
        metrics_collector = MetricsCollector()
        llm_provider = OpenAIProvider(config.api_key)
        repo = Repository(config, llm_provider, metrics_collector)

        logging.info("Generating repository...")
        repo.generate_repository()

        dependency_manager = DependencyManager(config)
        dependency_manager.generate_requirements(repo)

        if args.analyze:
            logging.info("Running code analysis...")
            analyzer = CodeAnalyzer(config)
            analysis_results = analyzer.analyze_repo(repo)
            print("Code Analysis Results:", analysis_results)

        if args.docs:
            logging.info("Generating documentation...")
            doc_generator = DocumentationGenerator(config)
            doc_generator.generate_docs(repo)

        if args.cicd:
            logging.info("Generating CI/CD configuration...")
            cicd_generator = CICDGenerator(config)
            cicd_generator.generate_config(repo)

        logging.info("Running tests...")
        pytest_runner = PyTestRunner(f"{config.output_path}/{config.repo_name}")
        test_results = pytest_runner.run_tests()
        logging.info(f"Test results: {test_results}")

        logging.info("Collecting metrics...")
        print(metrics_collector.get_report())

        logging.info(f"Repository generated successfully at {config.output_path}/{config.repo_name}")
--------------------------------------------------------------------------------
Chunk ID: src\code_analyzer.py::1
Filepath: llm_code_generator\src\code_analyzer.py
Content:
import os
import subprocess
from typing import Dict, Any

class CodeAnalyzer:
    def __init__(self, config):
        self.config = config

    def analyze_repo(self, repo) -> Dict[str, Any]:
        repo_path = os.path.join(self.config.output_path, repo.name)
        return {
            "pylint_score": self._run_pylint(repo_path),
            "mypy_results": self._run_mypy(repo_path),
            "complexity": self._analyze_complexity(repo_path)
        }

    def _run_pylint(self, repo_path: str) -> float:
        result = subprocess.run(["pylint", repo_path], capture_output=True, text=True)
        for line in result.stdout.split("\n"):
            if line.startswith("Your code has been rated at"):
                return float(line.split()[6].split("/")[0])
        return 0.0

    def _run_mypy(self, repo_path: str) -> str:
        result = subprocess.run(["mypy", repo_path], capture_output=True, text=True)
        return result.stdout
--------------------------------------------------------------------------------
Chunk ID: src\code_analyzer.py::2
Filepath: llm_code_generator\src\code_analyzer.py
Content:
class CodeAnalyzer:

    def _analyze_complexity(self, repo_path: str) -> Dict[str, int]:
        result = subprocess.run(["radon", "cc", repo_path, "-s"], capture_output=True, text=True)
        complexity = {"A": 0, "B": 0, "C": 0, "D": 0, "E": 0, "F": 0}
        for line in result.stdout.split("\n"):
            parts = line.split()
            if len(parts) == 2 and parts[0] in complexity:
                complexity[parts[0]] = int(parts[1])
        return complexity
--------------------------------------------------------------------------------
Chunk ID: src\code_formatter.py::1
Filepath: llm_code_generator\src\code_formatter.py
Content:
import subprocess
import os
from typing import Dict, Any

class CodeFormatter:
    def __init__(self, config: Dict[str, Any]):
        self.config = config

    def detect_language(self, file_path: str) -> str:
        _, ext = os.path.splitext(file_path)
        return {
            '.py': 'python',
            '.js': 'javascript',
            '.java': 'java',
            '.cpp': 'cpp',
            '.cs': 'csharp'
        }.get(ext.lower(), 'unknown')

    def format_code(self, code: str, file_path: str) -> str:
        language = self.detect_language(file_path)
        if language == 'python':
            return self.format_python(code)
        elif language == 'javascript':
            return self.format_javascript(code)
        # Add more language-specific formatting methods as needed
        else:
            return code  # Return unformatted code for unsupported languages

    def format_python(self, code: str) -> str:
        try:
            result = subprocess.run(
                ['black', '-', '-q'] + self.config.get('black_options', []),
                input=code,
                text=True,
                capture_output=True,
                check=True
            )
            return result.stdout
        except subprocess.CalledProcessError as e:
            print(f"Error formatting Python code: {e}")
            return code

    def format_javascript(self, code: str) -> str:
        try:
            result = subprocess.run(
                ['prettier', '--parser', 'babel'] + self.config.get('prettier_options', []),
                input=code,
                text=True,
                capture_output=True,
                check=True
            )
            return result.stdout
        except subprocess.CalledProcessError as e:
            print(f"Error formatting JavaScript code: {e}")
            return code

    # Add more language-specific formatting methods as needed
--------------------------------------------------------------------------------
Chunk ID: src\config_validator.py::1
Filepath: llm_code_generator\src\config_validator.py
Content:
from jsonschema import validate
from typing import Dict, Any

class ConfigValidator:
    SCHEMA = {
        "type": "object",
        "properties": {
            "repo_name": {"type": "string"},
            "api_key": {"type": "string"},
            "repo_description": {"type": "string"},
            "num_components": {"type": "integer", "minimum": 1},
            "primary_language": {"type": "string"},
            "primary_language_extension": {"type": "string"},
            "output_path": {"type": "string"},
            "formatting_options": {
                "type": "object",
                "properties": {
                    "black_options": {"type": "array", "items": {"type": "string"}},
                    "prettier_options": {"type": "array", "items": {"type": "string"}}
                }
            }
        },
        "required": ["repo_name", "api_key", "repo_description", "num_components", "primary_language", "output_path"]
    }

    @classmethod
    def validate_config(cls, config: Dict[str, Any]):
        validate(instance=config, schema=cls.SCHEMA)
--------------------------------------------------------------------------------
Chunk ID: src\configuration.py::1
Filepath: llm_code_generator\src\configuration.py
Content:
import yaml
from typing import Dict, Any

class Configuration:
    def __init__(self, config_path: str = None):
        self.config: Dict[str, Any] = self._load_config(config_path)

    def _load_config(self, config_path: str) -> Dict[str, Any]:
        if config_path:
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
        else:
            # Load default configuration
            with open('config/default_config.yaml', 'r') as f:
                return yaml.safe_load(f)

    @property
    def repo_name(self) -> str:
        return self.config.get('repo_name', 'generated_repo')

    @property
    def api_key(self) -> str:
        return self.config.get('api_key', '')

    @property
    def repo_description(self) -> str:
        return self.config.get('repo_description', '')

    @property
    def num_components(self) -> int:
        return self.config.get('num_components', 5)

    @property
    def primary_language(self) -> str:
        return self.config.get('primary_language', 'python')

    @property
    def primary_language_extension(self) -> str:
        return self.config.get('primary_language_extension', 'py')

    # Add more properties as needed for other configuration options
--------------------------------------------------------------------------------
Chunk ID: src\dependency_manager.py::1
Filepath: llm_code_generator\src\dependency_manager.py
Content:
import os
from typing import List

class DependencyManager:
    def __init__(self, config):
        self.config = config

    def generate_requirements(self, repo) -> List[str]:
        dependencies = set()
        for component in repo.components:
            dependencies.update(self._extract_dependencies(component.implementation))

        requirements_path = os.path.join(self.config.output_path, repo.name, "requirements.txt")
        with open(requirements_path, "w") as f:
            for dep in sorted(dependencies):
                f.write(f"{dep}\n")

        return list(dependencies)

    def _extract_dependencies(self, code: str) -> List[str]:
        # This is a simple implementation. In a real-world scenario,
        # you'd want to use an AST parser or a more sophisticated method.
        import_lines = [line for line in code.split("\n") if line.startswith("import") or line.startswith("from")]
        dependencies = []
        for line in import_lines:
            parts = line.split()
            if line.startswith("import"):
                dependencies.append(parts[1].split(".")[0])
            elif line.startswith("from"):
                dependencies.append(parts[1].split(".")[0])
        return list(set(dependencies))
--------------------------------------------------------------------------------
Chunk ID: src\documentation_generator.py::1
Filepath: llm_code_generator\src\documentation_generator.py
Content:
import os
from typing import List

class DocumentationGenerator:
    def __init__(self, config):
        self.config = config

    def generate_docs(self, repo):
        docs_path = os.path.join(self.config.output_path, repo.name, "docs")
        os.makedirs(docs_path, exist_ok=True)

        self._generate_readme(repo, docs_path)
        self._generate_component_docs(repo, docs_path)

    def _generate_readme(self, repo, docs_path):
        readme_content = f"# {repo.name}\n\n"
        readme_content += f"{repo.config.repo_description}\n\n"
        readme_content += "## Components\n\n"
        for component in repo.components:
            readme_content += f"- [{component.name}](docs/{component.name.lower().replace(' ', '_')}.md)\n"

        with open(os.path.join(self.config.output_path, repo.name, "README.md"), "w") as f:
            f.write(readme_content)
--------------------------------------------------------------------------------
Chunk ID: src\documentation_generator.py::2
Filepath: llm_code_generator\src\documentation_generator.py
Content:
class DocumentationGenerator:

    def _generate_component_docs(self, repo, docs_path):
        for component in repo.components:
            doc_content = f"# {component.name}\n\n"
            doc_content += f"{component.description}\n\n"
            doc_content += "## Data Structures\n\n"
            for structure in component.data_structures:
                doc_content += f"### {structure['name']}\n"
                doc_content += f"```\n{structure['structure']}\n```\n\n"
            doc_content += "## Logic\n\n"
            doc_content += f"```python\n{component.logic}\n```\n"

            with open(os.path.join(docs_path, f"{component.name.lower().replace(' ', '_')}.md"), "w") as f:
                f.write(doc_content)
--------------------------------------------------------------------------------
Chunk ID: src\error_handler.py::1
Filepath: llm_code_generator\src\error_handler.py
Content:
import sys
import traceback
from .logger import setup_logger

logger = setup_logger()

class LLMCodeGeneratorError(Exception):
    """Base class for exceptions in this module."""
    pass

class ConfigurationError(LLMCodeGeneratorError):
    """Raised when there's an issue with the configuration."""
    pass

class LLMAPIError(LLMCodeGeneratorError):
    """Raised when there's an issue with the LLM API."""
    pass

class CodeGenerationError(LLMCodeGeneratorError):
    """Raised when there's an issue during code generation."""
    pass

def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, LLMCodeGeneratorError):
        logger.error(f"{exc_type.__name__}: {exc_value}")
    else:
        logger.error("An unexpected error occurred:", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception
--------------------------------------------------------------------------------
Chunk ID: src\file_relation.py::1
Filepath: llm_code_generator\src\file_relation.py
Content:
from typing import List

class FileRelation:
    def __init__(self, path: str, component: str, dependencies: List[str] = None):
        self.path = path
        self.component = component
        self.dependencies = dependencies or []

    def add_dependency(self, dependency: str):
        if dependency not in self.dependencies:
            self.dependencies.append(dependency);
--------------------------------------------------------------------------------
Chunk ID: src\functional_component.py::1
Filepath: llm_code_generator\src\functional_component.py
Content:
from typing import List, Dict

class FunctionalComponent:
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.data_structures: List[Dict[str, str]] = []
        self.logic: str = ""

    def add_data_structure(self, name: str, structure: str):
        self.data_structures.append({"name": name, "structure": structure})

    def set_logic(self, logic: str):
        self.logic = logic;
--------------------------------------------------------------------------------
Chunk ID: src\llm_provider.py::1
Filepath: llm_code_generator\src\llm_provider.py
Content:
from abc import ABC, abstractmethod

class LLMProvider(ABC):
    @abstractmethod
    def send_prompt(self, prompt: str) -> str:
        pass

class OpenAIProvider(LLMProvider):
    def __init__(self, api_key: str):
        self.api_key = api_key
        # Initialize OpenAI client here

    def send_prompt(self, prompt: str) -> str:
        # Implement OpenAI API call here
        pass;
--------------------------------------------------------------------------------
Chunk ID: src\logger.py::1
Filepath: llm_code_generator\src\logger.py
Content:
import logging
import os

def setup_logger(log_file: str = 'llm_code_generator.log'):
    logger = logging.getLogger('llm_code_generator')
    logger.setLevel(logging.DEBUG)

    # Create handlers
    c_handler = logging.StreamHandler()
    f_handler = logging.FileHandler(log_file)
    c_handler.setLevel(logging.INFO)
    f_handler.setLevel(logging.DEBUG)

    # Create formatters and add it to handlers
    c_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    f_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    c_handler.setFormatter(c_format)
    f_handler.setFormatter(f_format)

    # Add handlers to the logger
    logger.addHandler(c_handler)
    logger.addHandler(f_handler)

    return logger
--------------------------------------------------------------------------------
Chunk ID: src\metrics_collector.py::1
Filepath: llm_code_generator\src\metrics_collector.py
Content:
from typing import Dict
import time

class MetricsCollector:
    def __init__(self):
        self.start_time = time.time()
        self.metrics: Dict[str, float] = {
            "total_files": 0,
            "total_lines": 0,
            "total_functions": 0,
            "total_components": 0,
            "generation_time": 0,
            "llm_api_calls": 0,
            "llm_tokens_used": 0,
        }
        self.step_times: Dict[str, float] = {}

    def update_metric(self, key: str, value: float):
        self.metrics[key] = value

    def increment_metric(self, key: str, value: float = 1):
        self.metrics[key] += value

    def start_step(self, step_name: str):
        self.step_times[step_name] = time.time()

    def end_step(self, step_name: str):
        if step_name in self.step_times:
            elapsed_time = time.time() - self.step_times[step_name]
            self.metrics[f"{step_name}_time"] = elapsed_time
            del self.step_times[step_name]

    def record_llm_call(self, tokens_used: int):
        self.increment_metric("llm_api_calls")
        self.increment_metric("llm_tokens_used", tokens_used)

    def finalize(self):
        self.metrics["generation_time"] = time.time() - self.start_time

    def get_report(self) -> str:
        self.finalize()
        report = "Code Generation Metrics:\n"
        report += "========================\n"
        for key, value in self.metrics.items():
            if key.endswith("_time"):
                report += f"{key}: {value:.2f} seconds\n"
            else:
                report += f"{key}: {value}\n"
        return report
--------------------------------------------------------------------------------
Chunk ID: src\project_structure_generator.py::1
Filepath: llm_code_generator\src\project_structure_generator.py
Content:
import os
from typing import List, Dict

class ProjectStructureGenerator:
    def __init__(self, config, template_engine):
        self.config = config
        self.template_engine = template_engine

    def generate_structure(self, repo_path: str):
        self._create_directories(repo_path)
        self._create_initial_files(repo_path)

    def _create_directories(self, repo_path: str):
        directories = [
            'src',
            'tests',
            'docs',
            'config',
            'scripts',
            'data'
        ]
        for directory in directories:
            os.makedirs(os.path.join(repo_path, directory), exist_ok=True)
--------------------------------------------------------------------------------
Chunk ID: src\project_structure_generator.py::2
Filepath: llm_code_generator\src\project_structure_generator.py
Content:
class ProjectStructureGenerator:

    def _create_initial_files(self, repo_path: str):
        files = [
            ('README.md', 'readme.md.j2'),
            ('setup.py', 'setup.py.j2'),
            ('requirements.txt', 'requirements.txt.j2'),
            ('.gitignore', 'gitignore.j2'),
            ('src/__init__.py', 'init.py.j2'),
            ('tests/__init__.py', 'init.py.j2'),
        ]
        for file_path, template_name in files:
            self.template_engine.generate_file(
                template_name,
                os.path.join(repo_path, file_path),
                {'project_name': self.config.repo_name}
            )
--------------------------------------------------------------------------------
Chunk ID: src\prompt_generator.py::1
Filepath: llm_code_generator\src\prompt_generator.py
Content:
from typing import List
from .configuration import Configuration
from .functional_component import FunctionalComponent
from .file_relation import FileRelation
from .metrics_collector import MetricsCollector
from .prompts import generate_initial_prompt, generate_unit_test_prompt, generate_implementation_prompt

class PromptGenerator:
    def __init__(self, config: Configuration, metrics_collector: MetricsCollector):
        self.config = config
        self.metrics_collector = metrics_collector

    def generate_initial_prompt(self) -> str:
        return generate_initial_prompt(self.config, self.metrics_collector)

    def generate_unit_test_prompt(self, component: FunctionalComponent) -> str:
        return generate_unit_test_prompt(component, self.metrics_collector)

    def generate_implementation_prompt(self, component: FunctionalComponent) -> str:
        return generate_implementation_prompt(component, self.config, self.metrics_collector)
--------------------------------------------------------------------------------
Chunk ID: src\prompt_generator.py::2
Filepath: llm_code_generator\src\prompt_generator.py
Content:
class ResponseProcessor:
    def __init__(self, metrics_collector: MetricsCollector):
        self.metrics_collector = metrics_collector

    def process_initial_response(self, response: str) -> List[FunctionalComponent]:
        # Assume response is a JSON array of component objects
        import json
        components = []
        try:
            component_data = json.loads(response)
            for data in component_data:
                component = FunctionalComponent(data['name'], data['description'])
                for structure in data.get('data_structures', []):
                    component.add_data_structure(structure['name'], structure['structure'])
                component.set_logic(data.get('logic', ''))
                components.append(component)
            self.metrics_collector.update_metric("total_components", len(components))
        except json.JSONDecodeError:
            print("Error: Invalid JSON response from LLM")
        return components
--------------------------------------------------------------------------------
Chunk ID: src\prompt_generator.py::3
Filepath: llm_code_generator\src\prompt_generator.py
Content:
class ResponseProcessor:

    def process_unit_test_response(self, response: str, component: FunctionalComponent):
        # Assume response is a JSON array of test case objects
        import json
        try:
            test_cases = json.loads(response)
            component.test_cases = test_cases
            self.metrics_collector.increment_metric("total_test_cases", len(test_cases))
        except json.JSONDecodeError:
            print(f"Error: Invalid JSON response for unit tests of {component.name}")

    def process_implementation_response(self, response: str, component: FunctionalComponent) -> FileRelation:
        # Assume response is a code block
        file_path = f"src/{component.name.lower().replace(' ', '_')}.{self.config.primary_language_extension}"
        component.implementation = response
        file_relation = FileRelation(file_path, component.name)
        self.metrics_collector.increment_metric("total_files")
        self.metrics_collector.increment_metric("total_lines", response.count('\n'))
        return file_relation
--------------------------------------------------------------------------------
Chunk ID: prompts\__init__.py::1
Filepath: llm_code_generator\src\prompts\__init__.py
Content:
from .initial_prompt import generate_initial_prompt
from .unit_test_prompt import generate_unit_test_prompt
from .implementation_prompt import generate_implementation_prompt

__all__ = ['generate_initial_prompt', 'generate_unit_test_prompt', 'generate_implementation_prompt']
--------------------------------------------------------------------------------
Chunk ID: prompts\implementation_prompt.py::1
Filepath: llm_code_generator\src\prompts\implementation_prompt.py
Content:
def generate_implementation_prompt(component, config, metrics_collector):
    prompt = f"""
    Implement the following component:
    Name: {component.name}
    Description: {component.description}

    Data Structures:
    {component.data_structures}

    Logic Description:
    {component.logic}

    Provide the implementation in {config.primary_language}.
    Include necessary imports, class definitions, and method implementations.
    Format the response as a code block.
    """
    metrics_collector.increment_metric("prompts_generated")
    return prompt
--------------------------------------------------------------------------------
Chunk ID: prompts\initial_prompt.py::1
Filepath: llm_code_generator\src\prompts\initial_prompt.py
Content:
def generate_initial_prompt(config, metrics_collector):
    prompt = f"""
    Create a software system with the following description:
    {config.repo_description}

    Generate {config.num_components} functional components for this system.
    For each component, provide:
    1. A name
    2. A brief description
    3. Key data structures it will use
    4. A high-level description of its logic

    Format the response as a JSON array of objects, each representing a component.
    """
    metrics_collector.increment_metric("prompts_generated")
    return prompt
--------------------------------------------------------------------------------
Chunk ID: prompts\unit_test_prompt.py::1
Filepath: llm_code_generator\src\prompts\unit_test_prompt.py
Content:
def generate_unit_test_prompt(component, metrics_collector):
    prompt = f"""
    Generate unit test cases for the following component:
    Name: {component.name}
    Description: {component.description}

    Provide at least 3 test cases, each including:
    1. A test name
    2. Input data
    3. Expected output or behavior
    4. A brief description of what the test is verifying

    Format the response as a JSON array of test case objects.
    """
    metrics_collector.increment_metric("prompts_generated")
    return prompt
--------------------------------------------------------------------------------
Chunk ID: src\pytest_runner.py::1
Filepath: llm_code_generator\src\pytest_runner.py
Content:
import pytest
import os
from typing import Dict, Any
import logging

class PyTestRunner:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path

    def run_tests(self) -> Dict[str, Any]:
        current_dir = os.getcwd()
        os.chdir(self.repo_path)

        try:
            pytest_output = pytest.main(['-v', '--capture=no'])
            test_results = self.process_pytest_output(pytest_output)
        except Exception as e:
            logging.error(f"Error running tests: {str(e)}")
            test_results = {"error": str(e)}
        finally:
            os.chdir(current_dir)

        return test_results
--------------------------------------------------------------------------------
Chunk ID: src\pytest_runner.py::2
Filepath: llm_code_generator\src\pytest_runner.py
Content:
class PyTestRunner:

    def process_pytest_output(self, pytest_output: int) -> Dict[str, Any]:
        if pytest_output == 0:
            return {"status": "success", "message": "All tests passed"}
        elif pytest_output == 1:
            return {"status": "failure", "message": "Some tests failed"}
        elif pytest_output == 2:
            return {"status": "error", "message": "Test execution was interrupted"}
        elif pytest_output == 3:
            return {"status": "error", "message": "Internal error in pytest"}
        elif pytest_output == 4:
            return {"status": "error", "message": "pytest command line usage error"}
        elif pytest_output == 5:
            return {"status": "error", "message": "No tests were collected"}
        else:
            return {"status": "unknown", "message": f"Unknown pytest return code: {pytest_output}"}
--------------------------------------------------------------------------------
Chunk ID: src\repository.py::1
Filepath: llm_code_generator\src\repository.py
Content:
import os
from typing import List
from .functional_component import FunctionalComponent
from .file_relation import FileRelation
from .configuration import Configuration
from .llm_provider import LLMProvider
from .prompt_generator import PromptGenerator, ResponseProcessor
from .metrics_collector import MetricsCollector
from .code_formatter import CodeFormatter
from .version_control import VersionControl
import logging

class Repository:
    def __init__(self, config: Configuration, llm_provider: LLMProvider, metrics_collector: MetricsCollector):
        self.name = config.repo_name
        self.config = config
        self.llm_provider = llm_provider
        self.metrics_collector = metrics_collector
        self.components: List[FunctionalComponent] = []
        self.file_relations: List[FileRelation] = []
        self.prompt_generator = PromptGenerator(config, metrics_collector)
        self.response_processor = ResponseProcessor(metrics_collector)
        self.code_formatter = CodeFormatter(config.formatting_options)
        self.version_control = VersionControl(os.path.join(config.output_path, self.name))
        logging.info(f"Initialized Repository for {self.name}")

    def generate_components(self):
        self.metrics_collector.start_step("generate_components")
        logging.info("Generating components...")
        prompt = self.prompt_generator.generate_initial_prompt()
        response = self.llm_provider.send_prompt(prompt)
        self.components = self.response_processor.process_initial_response(response)
        logging.info(f"Generated {len(self.components)} components")
        self.metrics_collector.end_step("generate_components")
        self.version_control.commit("Generated initial components")

    def generate_unit_tests(self):
        self.metrics_collector.start_step("generate_unit_tests")
        logging.info("Generating unit tests...")
        for component in self.components:
            logging.info(f"Generating unit tests for {component.name}")
            prompt = self.prompt_generator.generate_unit_test_prompt(component)
            response = self.llm_provider.send_prompt(prompt)
            self.response_processor.process_unit_test_response(response, component)
        self.metrics_collector.end_step("generate_unit_tests")
        self.version_control.commit("Generated unit tests")
--------------------------------------------------------------------------------
Chunk ID: src\repository.py::2
Filepath: llm_code_generator\src\repository.py
Content:
class Repository:

    def generate_implementations(self):
        self.metrics_collector.start_step("generate_implementations")
        logging.info("Generating implementations...")
        for component in self.components:
            logging.info(f"Generating implementation for {component.name}")
            prompt = self.prompt_generator.generate_implementation_prompt(component)
            response = self.llm_provider.send_prompt(prompt)
            file_relation = self.response_processor.process_implementation_response(response, component)
            self.file_relations.append(file_relation)
        self.metrics_collector.end_step("generate_implementations")
        self.version_control.commit("Generated component implementations")
--------------------------------------------------------------------------------
Chunk ID: src\repository.py::3
Filepath: llm_code_generator\src\repository.py
Content:
class Repository:

    def write_to_disk(self):
        self.metrics_collector.start_step("write_to_disk")
        logging.info(f"Writing repository to disk at {self.config.output_path}")
        repo_path = os.path.join(self.config.output_path, self.name)
        os.makedirs(repo_path, exist_ok=True)

        for file_relation in self.file_relations:
            file_path = os.path.join(repo_path, file_relation.path)
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            component = next((c for c in self.components if c.name == file_relation.component), None)
            if component:
                formatted_code = self.code_formatter.format_code(component.implementation, file_path)
                with open(file_path, 'w') as f:
                    f.write(formatted_code)
            else:
                logging.warning(f"No implementation found for {file_relation.path}")

        self.write_unit_tests(repo_path)
        self.write_pytest_config(repo_path)
        self.metrics_collector.end_step("write_to_disk")
        self.version_control.commit("Wrote generated code to disk")
--------------------------------------------------------------------------------
Chunk ID: src\repository.py::4
Filepath: llm_code_generator\src\repository.py
Content:
class Repository:

    def write_unit_tests(self, repo_path: str):
        logging.info("Writing unit tests to disk")
        test_dir = os.path.join(repo_path, 'tests')
        os.makedirs(test_dir, exist_ok=True)

        for component in self.components:
            test_file_path = os.path.join(test_dir, f"test_{component.name.lower().replace(' ', '_')}.py")
            test_content = self.generate_test_file_content(component)
            formatted_test_content = self.code_formatter.format_code(test_content, test_file_path)
            with open(test_file_path, 'w') as f:
                f.write(formatted_test_content)
--------------------------------------------------------------------------------
Chunk ID: src\repository.py::5
Filepath: llm_code_generator\src\repository.py
Content:
class Repository:

    def generate_test_file_content(self, component: FunctionalComponent) -> str:
        content = f"import pytest\nfrom src.{component.name.lower().replace(' ', '_')} import {component.name}\n\n"
        for test_case in component.test_cases:
            content += f"def test_{test_case['name'].lower().replace(' ', '_')}():\n"
            content += f"    # {test_case['description']}\n"
            content += f"    # Input: {test_case['input']}\n"
            content += f"    # Expected output: {test_case['expected_output']}\n"
            content += f"    assert {component.name}.some_method() == expected_output\n\n"
        return content
--------------------------------------------------------------------------------
Chunk ID: src\repository.py::6
Filepath: llm_code_generator\src\repository.py
Content:
class Repository:

    def write_pytest_config(self, repo_path: str):
        logging.info("Writing pytest configuration")
        config_content = """
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
"""
        with open(os.path.join(repo_path, 'pytest.ini'), 'w') as f:
            f.write(config_content)

    def generate_repository(self):
        logging.info("Starting repository generation process")
        self.metrics_collector.start_step("generate_repository")
        self.version_control.init_repo()
        self.generate_components()
        self.generate_unit_tests()
        self.generate_implementations()
        self.write_to_disk()
        self.metrics_collector.end_step("generate_repository")
        logging.info("Repository generation complete")
--------------------------------------------------------------------------------
Chunk ID: src\template_engine.py::1
Filepath: llm_code_generator\src\template_engine.py
Content:
import jinja2
import os

class TemplateEngine:
    def __init__(self, template_dir: str):
        self.env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(template_dir),
            autoescape=jinja2.select_autoescape(['html', 'xml'])
        )

    def render_template(self, template_name: str, context: dict) -> str:
        template = self.env.get_template(template_name)
        return template.render(context)

    def generate_file(self, template_name: str, output_path: str, context: dict):
        content = self.render_template(template_name, context)
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(content)
--------------------------------------------------------------------------------
Chunk ID: src\version_control.py::1
Filepath: llm_code_generator\src\version_control.py
Content:
import subprocess
import os

class VersionControl:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path

    def init_repo(self):
        subprocess.run(['git', 'init'], cwd=self.repo_path, check=True)
        self._create_gitignore()

    def _create_gitignore(self):
        gitignore_content = """
# Python
__pycache__/
*.py[cod]
*.so

# JavaScript
node_modules/
npm-debug.log
yarn-error.log

# IDEs
.vscode/
.idea/

# Miscellaneous
.DS_Store
*.log
*.bak
"""
        with open(os.path.join(self.repo_path, '.gitignore'), 'w') as f:
            f.write(gitignore_content)

    def add_files(self):
        subprocess.run(['git', 'add', '.'], cwd=self.repo_path, check=True)

    def commit(self, message: str):
        subprocess.run(['git', 'commit', '-m', message], cwd=self.repo_path, check=True)

    def create_branch(self, branch_name: str):
        subprocess.run(['git', 'branch', branch_name], cwd=self.repo_path, check=True)

    def switch_branch(self, branch_name: str):
        subprocess.run(['git', 'checkout', branch_name], cwd=self.repo_path, check=True)

    def push(self, remote: str = 'origin', branch: str = 'main'):
        subprocess.run(['git', 'push', remote, branch], cwd=self.repo_path, check=True);
--------------------------------------------------------------------------------
